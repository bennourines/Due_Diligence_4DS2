opera reasoning continuous common knowledge asynchronous distributed systems sang min choia jiho parka quan nguyena kiyoung jangb hyunjoon cheonb yo sub hanb byung ik ahna afantom lab fantom foundation bdepartment computer science yonsei university abstract paper introduces new family consensus protocols lachesis class denoted l distributed networks guaranteed byzantine fault tolerance lachesis protocol l l complete asynchrony lead erless round robin proof work eventual consensus core concept technology opera chain generated lachesis protocol general form node lachesis set k neighbours preference receiving transactions node creates shares event block neighbours event block signed hashes creating node k peers opera chain event blocks directed acyclic graph dag guarantees practical byzantine fault tolerance pbft framework presented lamport timestamps concurrent common knowledge present example lachesis consensus protocol l0 framework l0 protocol reach consensus 2 3 partici pants agreement event block additional communication overhead l0 protocol relies cost function identify k peers generate dag based opera chain creating binary ag table stores connection information share information blocks lach esis achieves consensus fewer steps pbft protocol consensus keywords consensus algorithm byzantine fault tolerance lachesis protocol lamport timestamp root clotho atropos main chain preprint submitted fantom technical report october 4 2018 contents 1 introduction 3 1 1 motivation 3 1 2 generic framework l protocols 4 1 3 lachesis protocol l0 7 1 4 contributions 8 2 related work 9 2 1 lamport timestamps 9 2 2 concurrent common knowledge 10 2 3 consensus algorithms 11 2 4 dag based approaches 11 3 generic framework lachesis protocols 14 3 1 opera chain 14 3 2 main chain 14 3 3 lachesis consensus algorithm lca 16 3 4 node structure 16 3 5 event block creation 18 3 6 topological ordering events lamport timestamps 18 3 7 topological consensus ordering 19 3 8 peer selection algorithm 21 4 lachesis consensus protocol l0 21 4 1 root selection 22 4 2 clotho selection 23 4 3 atropos selection 24 4 4 peer selection algorithm cost function 27 5 discussions 31 5 1 lamport timestamps 31 5 2 semantics lachesis protocols 32 6 conclusion 33 6 1 future work 33 1 7 appendix 35 7 1 proof lachesis consensus algorithm 35 7 1 1 preliminaries 35 7 1 2 proof byzantine fault tolerance lachesis con sensus algorithm 35 7 2 response attacks 39 7 2 1 transaction flooding 39 7 2 2 parasite chain attack 39 7 2 3 double spending 39 7 2 4 long range attack 40 7 2 5 bribery attack 40 7 2 6 denial service 41 7 2 7 sybil 41 8 reference 42 2 1 introduction success cryptocurrencies blockchain recently emerged technology platform o ers secure decentralized consistent transac tion ledgers powered innovations domains including nancial systems supply chains health care despite high demand dis tributed ledger technology 26 commercialization opportunities obstructed long processing time consensus high power consump tion issues addressed consensus algorithms 4 9 23 24 distributed database systems address byzantine fault tolerance 13 participant nodes compro mised consensus algorithms ensures integrity transactions participants distributed network 13 equivalent proof byzantine fault tolerance distributed database systems 1 12 byzan tine consensus guaranteed deterministic completely asynchronous system unbounded delays 8 achieving consensus feasible nondeterministic system probability approaches consensus distributed system original nakamoto consensus protocol bitcoin uses proof work pow requires large amounts computational work generate blocks participants 19 alternative schemes proof stake pos 25 14 proposed pos uses participants stakes generate blocks respectively approach utilizes directed acyclic graphs dag 16 23 24 21 17 facilitate consensus examples dag based consensus algorithms include tangle 22 byte ball 5 hashgraph 2 tangle selects blocks connect net work utilizing accumulated weight nonce monte carlo markov chain mcmc byteball generates main chain dag reaches con sensus index information chain hashgraph connects block node random node hashgraph searches 2 3 members reach block provides proof byzantine fault tolerance graph search 1 1 motivation practical byzantine fault tolerance pbft allows nodes success fully reach agreement block information byzantine node exists 3 pbft consensus reached created block shared 3 participants share information shared 10 18 consensus achieved block added participants chains 3 6 currently takes o n4 pbft hashgraph 2 proposes gossip gossip virtual voting reach consensus limitations hashgraph algo rithm operates known network needs awareness author itative participants second gossip propagation slow latency increases o n n participants remains unclear virtual voting faster chain weight aka longest chain proof work concept issues gossip problems consensus problems interested new approach address aforementioned issues pbft approaches 3 10 18 hashgraph 2 speci cally propose new consensus algorithm addresses following questions 1 reach local consensus k cluster faster k 2 gos sips faster broadcast based gossip subset 3 continuous common knowledge consensus decisions high probability 4 complex decisions reduced binary value consensus paper propose new approach quickly search byzantine nodes block dag particular introduce new class consensus protocols lachesis protocol denoted l core idea lachesis use new dag structure opera chain allows faster path search consensus propose example lachesis protocol class called lachesis protocol l0 1 2 generic framework l protocols introduce generic framework lachesis protocols called l ba sic idea lachesis protocol dag based asynchronous non deterministic protocol guarantees pbft propose opera chain new dag structure faster consensus lachesis protocol generates block asyn chronously lachesis algorithm achieves consensus con rming nodes know blocks opera chain figure 1 shows example opera chain constructed lachesis protocol main concepts lachesis given follows event block nodes create event blocks time t structure event block includes signature generation time transaction history hash information references information referenced event blocks copied node rst event block node called leaf event 4 1 1 1 1 1 2 2 3 4 3 5 5 6 7 6 7 7 8 8 9 10 figure 1 example opera chain lachesis protocol lachesis protocol rule set communicate tween nodes node creates event blocks determines nodes choose nodes broadcast node selection ran dom cost function happened happened relationship nodes event blocks path event block x y x happened y x happened y means node creating y knows event block x root event block called root 1 rst generated event block node 2 reach thirds roots root candidate clotho root set root set rs set roots frame cardinality set 2n 3 rs n n number nodes frame frame f natural number separates root sets frame increases 1 case root new set f 1 event blocks new set previous root set included frame f 5 flag table flag table stores reachability event block root sum reachabilities values ag table indicates number reacheabilities event block roots lamport timestamps topological ordering lamport timestamps al gorithm uses happened relation determine partial order event block based logical clocks clotho clotho root satis es known 2n 3 nodes 2n 3 nodes know information known nodes clotho candidate atropos atropos atropos assigned consensus time lachesis con sensus algorithm utilized determining order event blocks atropos blocks form main chain allows time consensus ordering responses attacks reselection solve byzantine agreement problem node rese lects consensus time clotho based collected consensus time root set previous frame consensus time reaches byzantine agreement clotho con rmed atropos time consensus ordering opera chain opera chain local view dag held node local view identify topological ordering select clotho create time consensus atropos selection main chain main chain core subset opera chain comprised atropos event blocks opera chain uses main chain nd rapid ordering event blocks opera chain event block assigned proper consensus position motivating example figure 2 illustrates consensus reached path search opera chain gure leaf set denoted rs0 consists rst event blocks created individual participant nodes v set event blocks belong rs0 root set rsi given vertex v v rsi exists path v reach leaf vertex u rs0 let r1 r2 root event blocks root set rs1 rs2 respectively r1 block quorum 6 r1 r2 r3 leaf set initial set vertices participants vertex set vn set vertices created participants root set rn blocks created participants leaf events v1 v2 v3 figure 2 consensus method path search dag combines chain con sensus process pbft blocks exist path reaches leaf event block path r1 leaf vertex contain vertex v1 exists vertex r v1 r created quorum participants r included rs1 likewise r2 block reached rs1 including r1 blocks quorum participants leaf event blocks reached r1 shared quorum participants presence r1 existence root r2 shows information r1 shared quorum kind path search allows chain reach consensus similar manner pbft consensus processes essential track blocks satisfying pbft consensus process quicker path search opera chain main chain track blocks 1 3 lachesis protocol l0 introduce new speci c lachesis consensus protocol called l0 new protocol l0 dag based asynchronous non deterministic proto col guarantees pbft l0 generates block asynchronously uses opera chain faster consensus checking nodes know blocks l0 protocol propose algorithms particular 7 introduce algorithm node identify lazy participants cost e ective peers k peers stress generic lachesis protocol depend k peer selection algorithm node choose k peers randomly message created node signed creating node k peers introduce ag table data structure stores connection information event blocks ag table allows quickly traverse opera chain nd reachability event blocks opera chain optimize path search certain event blocks root clotho atropos main chain core subgraph opera chain maintain reliable information event blocks reach consensus generating event blocks lachesis protocol opera chain main chain updated frequently respond strongly attack situations forking parasite attack ag table opera chain consensus quickly reached ordering speci c event block determined 1 4 contributions summary paper makes following contributions propose new family l lachesis protocols introduce opera chain main chain faster consensus de ne topological ordering nodes event blocks opera chain lamport timestamps ordering intuitive reliable distributed system introduce ag table block improve root detection present proof dag based protocol implement concur rent common knowledge consistent cuts lachesis protocols allow faster node synchronization k neighbor broadcasts speci c lachesis protocol l0 introduced speci c algo rithms bene ts lachesis protocol l0 include 1 root selection algorithm ag table 2 algorithm build main chain 3 algorithm k peers selection cost function 4 faster consensus selection k peer broadcasts 5 data pruning root creation 8 rest paper organised follows section 2 gives overview blockchain related work existing dag based protocols section 3 describes new lachesis protocol section 4 presents lachesis consensus algorithm discussions lachesis protocols presented section 5 section 6 concludes future work section 7 proof byzantine fault tolerance described section 7 1 section 7 2 present responses certain attacks lachesis protocol consensus algorithm 2 related work 2 1 lamport timestamps lamport 11 de nes happened relation pair events distributed system machines happened relation denoted de ned physical clocks partial ordering events system relation satis es following conditions 1 b b0 events process b comes b0 b b0 2 b sending message process b0 receipt message process b b0 3 b b0 b0 b00 b b00 distinct events b b0 said concurrent b 9 b0 b0 9 b happens relation viewed causality e ect b b0 implies event b causally ect event b0 events concurrent causally ect lamport introduces logical clocks way assigning number event clock ci process pi function assigns number ci b event b 2 pi entire system blocks represented function c assigns event b number c b c b cj b b event process pj clock condition states events b b0 b b0 c b c b0 satis es clock condition clocks satisfy conditions process pi increments ci successive events sec ond require message m contains timestamp tm equals time message sent receiving message times tamped tm process advance clock later tm given arbitrary total ordering processes total ordering de ned follows event process pi b event process pj b b0 ci b cj b0 ii 9 c b cj b0 pi pj clock condition implies b b0 b b0 2 2 concurrent common knowledge concurrent common knowledge cck paper 20 de ne model reason concurrent common knowledge asynchronous distributed systems system composed set processes communicate sending messages xed set channels network necessarily completely connected system asynchronous sense global clock system relative speeds processes independent delivery time messages nite unbounded local state process denoted sj actions state transformers action function local states local states action send m action m message receive m action internal action local history hi process possibly nite sequence alternating local states beginning distinguished initial state actions write sequence follows hi s0i 1i s1i 2i s2i 3i notation sj j refers j th state action process s local history event tuple hs s0i consisting state action state jth event process s history ej denoting hsj 1 j sj asynchronous system consists following sets 1 set p f1 ng process identi ers n total number processes system 2 set c f j s t j 2 pg channels occurrence j c indicates process send messages process j 3 set hi possible local histories process proc 4 set asynchronous runs asynchronous run vector local histories process indexed process identi ers use notation hh1 h2 h3 hni constraints set described section 5 set m messages message triple hi j bi 2 proc sender message j 2 proc message recipient b body message b special value e g tag denote special purpose message proposition run e g reset variable x zero assume ease exposition messages unique 10 set channels c assumptions behavior induce constraints runs send message j j channel second reception message m run sending m run implies network introduce spurious messages alter messages cck model asynchronous system mention time events ordered based lamport s happens relation use lamport s theory describe global states asynchronous system global state run n vector pre xes local histories pre x process happens relation de ne con sistent global state termed consistent cut follows de nition 2 1 consistent cut consistent cut run global state exi ey j ey j global state exi global state message chain asynchronous run sequence messages m1 m2 m3 receive mi send mi 1 consequently send m1 receive m1 send m2 receive m2 send m3 2 3 consensus algorithms consensus algorithm participant nodes distributed network share transactions agree integrity shared transactions 13 equivalent proof byzantine fault tolerance distributed database systems 1 12 practical byzantine fault tolerance pbft allows nodes successfully reach agreement block byzantine node exists 3 numerous consensus algorithms proposed 4 9 proof work pow requires large amounts computational work generate blocks 19 proof stake pos 25 14 use participants stakes delegated participants stake generate blocks respectively alternative schemes proposed improve algorithms directed acyclic graphs dag 16 dag based approaches utilize graph structures de cide consensus blocks connections considered vertexes edges respectively 2 4 dag based approaches iota 22 published dag based technology called tangle tips concept address scalability issues limitations 11 internet things nonce weight level composed achieve transaction consensus setting user s di culty solve double spending problem parasite attack markov chain monte carlo mcmc tip selection algorithm randomly selects tips based size accumulated transaction weights transaction con icts need examine past transaction history nd con ict byteball 5 uses internal pay system called bytes pay adding data distributed database storage unit linked includes hashes earlier storage units particular consensus ordering composed selecting single main chain determined root consisting roots majority roots detects double spend attempts consensus time main chain fee charged according size bytes list units searched updated process determining roots raiblocks 15 developed improve high fees slow trans action processing process obtaining consensus balance weighted vote con icting transactions node participating network principal manages data history locally raiblocks generate transactions similar way anti spam tool pow nodes communicate create transactions terms scalability need steps verify entire history transactions new node added hashgraph 2 asynchronous dag based distributed ledger node connected ancestor randomly communicates known events gossip protocol time famous node determined strong relationship round reach consensus quickly state 2 3 nodes reach consensus event assigned consensus position con ux 17 dag based nakamoto consensus protocol con ux fast scalable decentralized block chain system optimistically pro cesses concurrent blocks discarding forks con ux pro tocol achieves consensus total order blocks total order transactions decided participants network con ux toler ate half network malicious bft based approaches tolerate malicious nodes parsec 21 proposes algorithm reaching consensus presence 12 byzantine faults randomly synchronous network like hashgraph 2 leaders round robin proof work reaches eventual con sensus probability unlike hashgraph provide high speed presence faults parsec algorithm reaches bft consensus weak synchrony assumptions messages delivered random de lays average delay nite allows byzantine arbitrary failures phantom 24 pow based protocol permissionless ledger generalizes nakamoto s blockchain dag blocks phantom includes parameter k adjust tolerance level protocol blocks created concurrently set accommodate higher throughput avoids security scalability tradeo satoshi s protocol phan tom uses greedy algorithm dag distinguish blocks honest nodes non cooperating nodes distinction gives phantom robust total order blocks eventually agreed honest nodes similar phantom ghostdag protocol selects k cluster induces colouring blocks blues blocks selected clus ter reds blocks outside cluster instead searching largest k cluster ghostdag nds cluster greedy algorithm spectre 23 new protocol consensus core cryptocurrencies spectre pow based protocol relies data structure gen eralizes nakamoto s blockchain dag remains secure attackers 50% computational power high throughput fast con rmation times sprectre protocol satis es weaker properties classic consensus requires spectre order trans actions decided transactions performed honest users di erent conventional paradigm order decided non corrupt nodes blockmania 6 mechanism achieve consensus advan tages traditional pbft protocol variants blockma nia nodes quorum emit blocks linking blocks irrespective consensus state machine resulting directed acyclic graph blocks block dag later interpreted ensure consensus safety nality live liness resulting system communication complexity o n2 worse case low constant factors compared o n4 pbft 13 3 generic framework lachesis protocols section describes key concepts new family lachesis protocols 3 1 opera chain core idea lachesis protocols use dag based structure called opera chain consensus algorithm lachesis protocol participant node server machine distributed system node create messages send messages receive messages nodes communication nodes asynchronous lachesis protocol consists event blocks including user information edges event blocks lachesis protocol event blocks created node node communicates information opera chain node opera chain comprised event blocks vertices block communication edges let n number participant nodes consensus algorithm examines event block shared 2n 3 nodes n number nodes sharing event block 2n 3 nodes means thirds nodes opera chain knows event block 3 2 main chain faster consensus introduce main chain special sub graph opera chain improve path search propose use local hash table structure cache quickly determine closest root event block opera chain event block called root event block linked thirds previous roots leaf vertex root root event blocks track vital blocks 2n 3 network agree main chain core subgraph opera chain plays important role ordering event blocks main chain stores shortcuts connect atropos topological ordering computed event blocks lachesis protocol atropos blocks determined form main chain figure 3 shows example main chain composed atropos event blocks particular main chain consists atropos blocks derived root blocks agreed 2n 3 14 network nodes guarantees 2n 3 nodes come consensus main chain participant node copy main chain search con sensus position event blocks event block compute consensus position checking nearest atropos event block assign ing searching consensus position introduced consensus time selection section main chain provides quick access previous transaction history e ciently process new coming event blocks main chain informa tion unknown participants attackers easily viewed main chain e ciently transaction information management pro viding quick access new event blocks agreed majority nodes short main chain gives following advantages event blocks nodes need store information e cient data management access previous information e cient fast based advantages opera chain respond strongly e cient transaction treatment attacks main chain r r r r r r r r r r figure 3 example main chain 15 3 3 lachesis consensus algorithm lca lachesis algorithm lca presented lca consen sus algorithms solving byzantine agreement problem lca opera chain uses root clotho atropos blocks nd consensus time event blocks algorithm 1 shows pseudo algorithm opera chain algorithm consists parts runs parallel node requests synchronization creates event block line 3 node runs node selection algorithm node selection algorithm returns k ids nodes communicate line 4 5 node synchronizes opera chain nodes line 6 runs event block creation step node creates event block checks root node broadcasts created event block nodes line 7 step line optional line 8 9 clotho selection atropos time consensus algorithms invoked algorithms determinte speci ed root clotho assign consensus time con rm atropos second respond synchronization requests line 10 11 node receives synchronization request sends response opera chain algorithm 1 main procedure 1 procedure main procedure 2 loop 3 b k node selection algorithm 4 request sync node b 5 sync known events lachesis protocol 6 event block creation 7 optional broadcast message 8 root selection 9 clotho selection 10 atropos time consensus 11 loop 12 request sync node 13 sync known events lachesis protocol 3 4 node structure section gives overview node structure lachesis 16 node signature stamp height vector degree vector ag table root hash list main chain signature stamp data structure storing hash value indicates recently created event block node recently created event block event block ag table n dimensional vector event block e created ith node reach jth root jth value ag table e 1 0 node maintains ag table event block node signature stamp height vector degree vector 1 2 n $ 1 2 n $ 2 root hash list 3 main chain hash list atropos 3 opera chain figure 4 example node structure figure 4 shows example node structure component node gure signaturea stores hash value event block value height vector number event blocks created nodes respectively value hi number event blocks created ith node value degree vector number edges event blocks created nodes event block 17 root hash list data structure storing hash values root main chain data structure storing hash values atropos blocks main chain nd event blocks complete consensus root clotho atropos selection algorithm introduced section 4 3 5 event block creation lachesis protocol node create event block event block refers event blocks reference means event block stores hash values event blocks lachesis protocol event block refers k neighbor event blocks conditions follows 1 reference event blocks event blocks 2 reference self parent 3 event block refers k neighbor nodes 3 6 topological ordering events lamport timestamps node physical clock needs physical time create event block consensus lachesis protocols relies logical clock node purpose use lamport timestamps 11 determine time ordering event blocks asynchronous dis tributed system lamport timestamps algorithm follows 1 node increments count value creating event block 2 sending message include count value receiver con sider sender s message received increments count value 3 current counter equal received count value node count value recipient updated 4 current counter greater received count value node current count value updated use lamport s algorithm enforce topological ordering event blocks uses atropos selection algorithm event block created based logical time sequence tween event blocks immediately determined lamport timestamps algorithm gives partial order events time dering process byzantine fault tolerance 18 f1 f2 f3 f4 1 1 1 1 1 2 2 3 4 3 5 5 6 7 8 7 6 7 8 9 9 10 10 10 figure 5 example lamport timestamps 3 7 topological consensus ordering sequential order event block important aspect byzan tine fault tolerance order determine pre post sequence event blocks use atropos consensus time lamport timestamp algo rithm hash value event block node creates event blocks logical times tamp based lamport timestamp means partial ordering relevant event blocks clotho consensus time atropos consensus time computed based logical time nominated nodes time 2n 3 agreement lca event block based following rules reach agreement 1 atropos di erent times frame event block smaller consensus time higher priority 2 atropos having consensus time frame determine order based logical time lamport timestamp 19 1 1 1 1 1 3 3 5 5 4 2 2 1 consensus time 3 3 prior ordering 2 consensus time lamport time prior ordering 3 consensus time lamport time prior ordering hash value consensus time 3 1 consensus time 1 lamport time 1 2 consensus time 2 lamport time 2 hash value 2 assume atropos 3 3 2 2 2 2 2 topological consensus ordering 1 smaller consensus time atropos prior ordering 2 consensus time smaller lamport timestamp prior ordering 3 consensus time lamport timestamp smaller hash value prior ordering figure 6 example topological consensus ordering 3 atropos having consensus time local logical time smaller hash value given priority hash function figure 6 depicts example topological consensus ordering figure 7 shows opera chain nal consensus order determined based 3 rules number represented event block logical time based lamport timestamp 20 1 1 1 1 1 2 2 3 4 3 5 5 6 7 6 7 7 8 8 9 10 figure 7 example time ordering event blocks opera chain final topological consensus order containing event blocks based agreement apropos based atropos di erent colors depending range 3 8 peer selection algorithm order create event block node needs select k nodes lachesis protocols depend peer nodes selected simple approach use random selection pool n nodes approach de ne criteria cost function select peers node distributed system node select nodes low com munication costs low network latency high bandwidth high successful trans action throughputs 4 lachesis consensus protocol l0 section presents new lachesis consensus protocol l0 speci c example lachesis class describe main ideas algorithms protocol 21 4 1 root selection nodes create event blocks event block root satisfying speci c conditions event blocks roots rst created event blocks roots leaf event blocks form rst root set rs1 total n nodes nodes create event blocks cardinality rst root set jrs1j n second event block e reach 2n 3 roots e called root event e belong rs1 root set rs2 excluding rst root set range cardinality root set rsk 2n 3 jrskj n event blocks including rsk rsk 1 frame fk roots rsk 1 belong frame fk included frame fk 1 root belonging rsk 2 occurs introduce use ag table quickly determine new event block root node maintains ag table event block event block newly created assigned k hashes k parent event blocks apply operation ag tables parent event blocks figure 8 shows example use ag tables determine root example r1 recently created event block apply operation ag tables r1 s k parent event blocks result ag table r1 r1 s ag table 2n 3 set bits r1 root example number set bits 4 greater 2n 3 n 5 r1 root root selection algorithm follows 1 rst event blocks considered root 2 new event block added opera chain check event block root applying operation ag tables connected new event block sum ag table new event block 2n 3 new event block root 3 new root appears opera chain nodes update root hash list new event blocks root nodes share new event block add hash value event block root hash list 4 new root set created cardinality previous root set rsp 2n 3 new event block reach 2n 3 root rsp 22 r0 r0 r0 r0 r0 r1 flag table information 1 1 1 0 0 flag table information 0 1 1 1 0 flag table information flag table information 1 1 1 1 0 0 0 0 1 0 r0 r0 r0 r0 r0 1 2 3 1 2 3 root set rs r0 r0 r0 r0 r0 r0 r0 r0 r0 r0 r0 r0 r0 r0 r0 figure 8 example flag table calculation 5 new root set rsk 1 created event blocks previous root set rsk rsk 1 belong frame fk 4 2 clotho selection clotho root satis es clotho creation conditions clotho creation conditions 2n 3 nodes know root root knows information figure 9 shows example clotho circles label ri c represents root clotho event block sets root exists root recent clotho set roots rst root set clotho clotho selection algorithm checks root event blocks root hash list satisfy clotho condition root satis es clotho condition root clotho makes candidate time atropos root concluded clotho atropos consensus time selection algorithm triggered root r denote frame r root r th frame example frame 1 r rst root belong frame f1 23 f1 f2 c r0 r0 f3 f4 r0 r0 r1 r1 r1 r1 r1 r2 r2 r2 r3 r3 r2 r3 r2 r3 figure 9 example clotho algorithm 2 shows pseudo code clotho selection algorithm takes root r input line 4 5 set c clotho c yes nil 0 respectively line 6 8 checks root c0 frame 3 r shares c current frame line 9 10 number roots frame 2 r shares c 2n 3 root c set clotho time complexity algorithm 3 o n2 n number nodes 4 3 atropos selection atropos selection algorithm process candidate time generated clotho selection shared nodes root selects candidate time repeatedly nodes candidate time clotho clotho nominated node computes candidate time clotho thirds nodes compute value candidate time time value recorded node reselects candidate time candidate time node collects reselection process node reaches time consensus didate time clotho opera chain grows candidate time reaching consensus called atropos consensus time atropos consensus 24 algorithm 2 clotho selection 1 procedure clotho selection 2 input root r 3 c 2 frame 3 r 4 c clotho nil 5 c yes 0 6 c0 2 frame 2 r 7 c0 share c 8 c yes c yes 1 9 c yes 2n 3 10 c clotho yes time computed clotho nominated atropos node stores hash value atropos atropos consensus time main chain main chain time order event blocks proof atropos consensus time selection shown section 7 1 25 algorithm 3 atropos consensus time selection 1 procedure atropos consensus time selection 2 input c clotho frame fi 3 c consensus time nil 4 m index frame fm 5 d 3 m 6 r root set rsi d frame fi d 7 r 2 r 8 d 3 9 r con rms c clotho 10 r time c r lamport time 11 d 3 12 s set root fj 1 r share 13 t reselection s c 14 k number root having t s 15 d mod h 0 16 k 2n 3 17 c consensus time t 18 r time c t 19 20 r time c t 21 22 r time c minimum value s algorithm 3 4 pseudo code atropos consensus time selection consensus time reselection algorithm 3 line 5 d denotes deference relationship root set c r line 7 means r elements root set frame fi 3 frame fi includes c line 10 root frame fj selects lamport timestamp candidate time c con rm root c cltoho line 12 13 14 s t k save set root r share c result reselection function number root s having t line 15 checking di erence h j h constant value minimum selection frame line 16 20 checking thirds root frame fj 1 nominate candidate time thirds root frame fj 1 nominate candidate time root c assigned consensus time t line 22 26 minimum selection frame minimum selection frame minimum value candidate time selected reach byzantine agreement algorithm 4 operates middle algorithm 3 algorithm 4 input root set r output reselected candidate time line 4 5 computes frequencies candidate time roots r line 6 11 candidate time smallest time nomitated time complexity algorithm 4 o n n number nodes algorithm 3 includes algorithm 4 time complexity algorithm 3 o n2 n number nodes algorithm 4 consensus time reselection 1 function reselection 2 input root set r clotho c 3 output candidate time t 4 set ti r time c r r 5 d set tuples ti ci computed ci count ti 6 max count max ci 7 t infinite 8 tuple ti ci 2 d 9 max count ci ti t 10 t ti 11 return t atropos consensus time selection algorithm nodes reach con sensus agreement candidate time clotho additional com munication e exchanging candidate time node communicates lachesis protocol opera chain nodes grows shape allows node know candidate time nodes based opera chain reach consensus agreement proof agreement based opera chain agreement action shown section 7 1 4 4 peer selection algorithm cost function de ne versions cost function cf version focused updated information share discussed versions focused root creation consensus facilitation discussed following paper 27 leaf events b c d e node signature stamp height vector degree vector b c d e 1 1 1 1 1 $% b c d e 0 0 0 0 0 cost function 0 2 leaf events b c d e node signature stamp height vector degree vector b c d e 1 1 1 1 1 $% b c d e 0 0 0 0 0 cost function 0 2 34 b 0 34 c 0 34 d 0 34 e 0 step 1 step 2 figure 10 example cost function 1 de ne cost function cf preventing creation lazy nodes lazy node node lower work portion opera chain node creates event block node selects nodes low values outputs cost function refers event blocks reference nodes equation 1 cf follows cf h 1 h denote values degree vector height vector spectively number nodes lowest cf k nodes selected random reason selecting high h expect high possibility create root high h indi cates communication frequency node opportunities low h nodes high cf case h generated fewer event blocks nodes low cf judge kind nodes lazy detect node lazy based cost function change lazy nodes participants remove figure 10 shows example node selection based cost func tion creation leaf events nodes example ve nodes node created leaf events nodes know leaf events node creates event block v1 calculates cost functions step 2 figure 10 shows results cost functions based height 28 leaf events b c d e node signature stamp height vector degree vector b c d e 3 2 1 1 1 $% b c d e 0 1 1 1 1 cost function 0 2 3 4 5 6 78 b 0 5 78 c 1 78 d 1 78 e 1 figure 11 example cost function 2 degree vectors node initial step value vectors nodes leaf events node randomly selects k nodes connects v1 leaf events selected nodes example set k 3 assume node selects node b c figure 11 shows example node selection steps simulation figure 10 figure 11 recent event block v5 created node node calculates cost function selects nodes lowest results cost function example node b 0 5 result nodes values node rst selects node b randomly selects nodes nodes c d e height node d current opera chain example 2 leaf event event block v4 hand height node d node structure 1 node aware presence event block v4 means path event blocks created node event block v4 node 1 height node d algorithm 5 shows selecting algorithm selecting reference nodes algorithm operates node select communication partner nodes line 4 5 set min cost sref initial state line 7 calculates cost function cf node line 8 9 10 nd 29 minimum value cost function set min cost sref cf id node respectively line 11 12 append id node sref min cost equals cf finally line 13 selects randomly k node ids sref communication partners time complexity algorithm 2 o n n number nodes algorithm 5 k neighbor node selection 1 procedure k node selection 2 input height vector h degree vector 3 output reference node ref 4 min cost inf 5 sref 6 k 2 node set 7 cf ik hk 8 min cost cf 9 min cost cf 10 sref k 11 min cost equal cf 12 sref sref k 13 ref random select sref reference node selected node communicates shares information event blocks known node creates event block referring event block reference node lachesis protocol works communicates asynchronously allows node create event block asynchronously node creates event block communication nodes allow simultaneous communication node figure 12 shows example node selection lachesis protocol example ve nodes b c d e node generates rst event blocks called leaf events nodes share leaf events rst step node generates new event block v1 blue node calculates cost function connect nodes initial situation nodes event block called leaf event height vector degree vector node values words heights node 1 degrees 0 reason node randomly select nodes connect v1 30 leaf events b c d e leaf events b c d e step 1 step 2 leaf events b c d e leaf events b c d e step 3 step 4 figure 12 example node selection event blocks nodes step 2 shows situation connections example node select node b c connect v1 event block v1 connected event blocks node b c node knows situation step 2 example node b generates new event block v2 green calculates cost function b randomly select nodes d b information leaf events node b requests d connect eb nodes d send information event blocks node b response event block node v1 node d leaf event event block v2 connected v1 leaf event node d step 4 shows connections 5 discussions section presents discussions lachesis protocol 5 1 lamport timestamps section discusses topological order event blocks dag based lachesis protocols lamport timestamps 11 lachesis protocols relies lamport timestamps de ne topo logical ordering event blocks opera chain happened relation denoted gives partial ordering events distributed system nodes given n nodes represented n processes p p0 p1 pn 1 31 pair event blocks b b0 relation satis es 1 b b0 events process pi b comes b0 b b0 2 b send m process b0 receive m process b b0 3 b b0 b0 b00 b b00 distinct events b b0 said concurrent b 9 b0 b0 9 b arbitrary total ordering processes relation de ned follows b event process pi b0 event process pj b b0 ci cj b ii c b cj b0 pi pj de nes total ordering clock condition implies b b use total ordering lachesis algorithms lamport timestamps rely physical locks determine partial ordering events 5 2 semantics lachesis protocols section discusses possible usage concurrent common knowl edge described section 2 2 understand dag based consensus protocols let g v e denote directed acyclic graph dag v set vertices e set edges dag directed graph cycle dag path source destination vertex path sequence vertices v1 v2 v k 1 vk uses edge asynchronous system consists following sets 1 set p f1 ng process identi ers n total number processes pi system 2 set c f j s t j 2 pg channels j c indicates process send messages process j 3 set hi possible local histories process p 4 set asynchronous runs asynchronous run vector local histories denoted hh1 h2 h3 hni process single run histories indexed process identi ers 5 set m messages message triple hi j bi 2 p sender message j 2 message recipient b message body lachesis protocol node selects k nodes peers certain gossip protocol nodes constrained gossip k peers 32 case set channels c modelled follows node selects node j peer j 2 c general express history node lachesis protocol manner cck paper 20 proof consensus formalized consistent cuts 6 conclusion order realize distributed ledger technology proposed new family asynchronous dag based consensus protocol l introduce opera chain main chain faster consensus lamport timestamps topological ordering event blocks opera chain main chain intuitive reliable distributed system introduce ag table block improve root detection presented speci c lachesis consensus protocol called l0 example l l0 protocol uses new ag table block shortcut check reachability event block root opera chain path search proof pbft consensus terms e ectiveness ag table l0 protocol e ective consensus compared path searching approaches ensure distribution participating nodes lachesis protocol de nes new cost function algorithm e ciently quickly selects peers propose new algorithms root selection clotho block selection based ag table atropos selection weight time consensus ordering based l0 protocol new consensus algorithm opera chain protect malicious attacks forks double spending parasite chains network control protections guarantee safety opera chain verify existence atropos opera chain concludes opera chain reaches consensus guarantees liveliness finally time ordering ensures guarantee weight value ag table based properties lca provides fair transparent e ective consensus algorithm 6 1 future work number directions future work lachesis protocols investigating fast node synchro nization algorithm k neighbor broadcasts opera chain k peer selection possible achieve faster gossip broadcast 33 interested comparing performance di erent gossip strate gies randomized gossip broadcast gossip collection tree protocol distributed averaging wireless sensor networks investigating semantics dag based protocols gen eral lachesis protocols particular aim formal proof pbft concurrent common knowledge consistent cuts 34 7 appendix 7 1 proof lachesis consensus algorithm section provide proof liveness safety opera chain byzantine fault tolerance represent byzantine fault tolerance assume thirds participants reliable nodes based assumption provide de nitions lemmas theorems eventually validate byzantine fault tolerance 7 1 1 preliminaries let g v e denote directed acyclic graph dag v set vertices e set edges dag directed graph cycle dag path source destination vertex path sequence p vertices v1 v2 v k 1 vk uses edge suppose current vertex vc current event block ec respectively vertex vp parent vc path vc vp length path 1 vertex va ancestor vc path vc va length path equal 1 7 1 2 proof byzantine fault tolerance lachesis consensus algorithm de nition 7 1 node machine participates opera chain creates event blocks total number nodes n de nition 7 2 event block opera chain vertex event block de nition 7 3 self parent event block es self parent event block ec es parent ec event blocks signatures de nition 7 4 self ancestor event block ea self ancestor event block ec ea ancestor ec event blocks signatures de nition 7 5 happened event block ex happened event block ey path ex ey de nition 7 6 root rst created event blocks leaf events root event block e reach 2n 3 roots root 35 de nition 7 7 root set rst event blocks leaf events elements root set r1 jr1j n root set rk set roots ri 2 rk reach 2n 3 roots rk k 1 de nition 7 8 frame frame f natural number separates root sets de nition 7 9 clotho root rk frame fa 3 nominate root ra clotho 2n 3 roots frame fa 1 happened ra rk happened roots frame fa 1 de nition 7 10 atropos consensus time clotho validated clotho atropos proposition 7 1 2n 3 roots frame fi happened 2n 3 roots frame fi 1 proof number roots root set 2n 3 root frame fi 1 happened 2n 3 roots frame fi cardinalities root sets frames fi fi 1 n 2n 3 respectively number paths root set frame fi 1 root set frame fi 2n 3 2 average maximum number paths root set frame fi 1 root frame fi 4n 9 2n 3 respectively 2n 3 roots frame fi happened n 3 root frame fi 1 proposition 7 2 root frame fi happened n 3 roots frame fi 1 root happened roots frame fi 2 proof based de nition root root reach 2n 3 roots previous frame means root frame fi 2 number paths 2n 3 roots frame fi 1 root r frame fi happened n 3 roots frame fi 1 roots frame fi 2 path root r lemma 7 3 sharing root ra frame fa 3 created root frame fa 3 knows 2n 3 roots frame fa known 2n 3 nodes 36 proof based propositions 7 1 7 2 root frame fa 3 knows 2n 3 roots frame fa known 2n 3 nodes lemma 7 4 fork pair event blocks x y fork roots happened fork opera chain know fork clotho proof suppose node creates event blocks x y event blocks fork create clotho reach event block pair event blocks shared 2n 3 nodes exist fork event blocks opera chain structurally detect fork roots clotho theorem 7 5 node grows shape opera chain proof suppose node b di erent shape structure nodes b event blocks x y opera opera b path x y opera equal opera b event blocks node di erent paths consider di erence fork attacks based lemma 7 4 attacker forks event block opera chain detect remove clotho generated contradicts assumptions reason nodes consistent opera chain lemma 7 6 root set r nodes nominate root clotho proof based theorem 7 5 node nominates root clotho ag table nodes opera chain shape values ag table equal opera chain nodes nominate root clotho opera chain nodes shape lemma 7 7 reselection algorithm clotho root opera chain selects consensus time candidate proof based theorem 7 5 nodes opera chain partial shape root opera chain selects consensus time candidate reselection algorithm 37 theorem 7 8 lachesis consensus algorithm guarantees reach agreement consensus time proof root set r frame fi time consensus algorithm checks 2n 3 roots frame fi 1 selects value node selects values collected root set previous frame time consensus algorithm reselection process based reselection process time consensus algorithm reach agreement possibility consensus time candidate reach agreement 7 solve problem time consensus algo rithm includes minimal selection frame h frame minimal value selection algorithm root selects minimum value values collected previous root set consensus time reaches consensus time consensus algorithm theorem 7 9 number reliable nodes 2n 3 event blocks created reliable nodes assigned consensus order proof opera chain reliable nodes try create event blocks communicating nodes continuously reliable nodes share event block x based proposition 7 1 root y frame fi happened event block x 2n 3 roots frame fi 1 happened root y root y nominated clotho atropos event block x root y assigned consensus time t event block assigning consensus time means validated event block shared 2n 3 nodes malicious node try attack event blocks assigned consensus time event block x consensus time t occur discover new event blocks earlier consensus time t conditions assigned consensus time earlier t new event blocks root r frame fi able share new event blocks second 2n 3 roots frame fi 1 able share r rst condition satis ed malicious nodes e g parasite chain second condition satis ed 2n 3 roots frame fi 1 created changed event block validated new event blocks participate earlier consensus time opera chain 38 7 2 response attacks like decentralized blockchain technologies opera chain likely subject attacks attackers aim gain nancial pro t damage system describe possible attack scenarios opera chain intends preventive measures 7 2 1 transaction flooding malicious participant run large number valid transactions account control purpose overloading network order prevent case chain intends impose minimal transaction fee transaction fee malicious user continue perform attacks participants participate nodes rewarded contribute ecosystem running transactions continuously rewarded rewards expected adequate running transactions appropriate purposes require tremendous cost perform abnormal attacks di cult malicious attacker create transaction ooding 7 2 2 parasite chain attack dag based protocol parasite chain malicious purpose attempting connection making look like legitimate event block main chain created veri cation event block performed veri cation process event block connected main chain deemed invalid ignored case double spending suppose nodes malicious malicious nodes create parasite chain root de nition roots nominated 2n 3 node awareness parasite chain shared malicious nodes participating nodes parasite chain unable generate roots shared consensus time 7 2 3 double spending double spend attack malicious entity attempts spend funds twice entity 10 tokens send 10 tokens b node na 10 tokens c node nz node na node nz agree transaction valid funds send b according na c according nz 39 consensus mechanism multiple distributed parties reach agreement order state sequence events let s consider following 3 transactions txa starting balance 10 transfers 10 b txb b starting balance 0 transfers 10 c txc c starting balance 0 transfers 10 d consider node na received order txa txb txc state node na 0 b 0 c 0 d 10 consider node nb receives order txc txb txa state node nb 0 b 10 c 0 d 0 consensus ordering gives sequence events pair event blocks x y double spending transaction chain structurally detect double spend delay action event blocks event blocks assign time ordering suppose pair event blocks x y frame f1 nodes detect event blocks frame f 2 root de nition root happened 2n 3 previous roots reason roots f 1 selected happened roots thirds roots f means 2n 3 roots f 1 share roots include pair respectively root de nition previous explanation roots f 2 share pairs nodes detect double spending event blocks f 2 earlier 7 2 4 long range attack blockchains adversary create chain chain longer original network accept longer chain mech anism exists identify chain work stake involved creation 2n 3 participating nodes required create new chain accom plish long range attack rst need create 2n 3 participating malicious nodes create new chain 7 2 5 bribery attack adversary bribe nodes validate con icting transactions 2n 3 participating nodes required require adversary bribe 1n 3 nodes begin bribery attack 40 7 2 6 denial service lca leaderless system requiring 2n 3 participation adversary deny 1n 3 participants able successfully mount ddos attack 7 2 7 sybil participating node stake minimum ftm par ticipate network able stake 2n 3 total stake pro hibitively expensive 41 8 reference 1 j aspnes randomized protocols asynchronous consensus dis tributed computing 16 2 3 165 175 2003 2 l baird hashgraph consensus fair fast byzantine fault tolerance technical report 2016 3 m castro b liskov practical byzantine fault tolerance proceed ings symposium operating systems design imple mentation osdi 99 pages 173 186 berkeley usa 1999 usenix association 4 j chen s micali algorand arxiv preprint arxiv 1607 01341 2016 5 churyumov byteball decentralized system storage trans fer value 2016 6 g danezis d hrycyszyn blockmania block dags consen sus 2018 7 m j fischer n lynch m paterson impossibility distributed consensus faulty process j acm 32 2 374 382 1985 8 m j fischer n lynch m s paterson impossibility distributed consensus faulty process journal acm jacm 32 2 374 382 1985 9 y gilad r hemo s micali g vlachos n zeldovich algorand scaling byzantine agreements cryptocurrencies proceedings 26th symposium operating systems principles pages 51 68 acm 2017 10 r kotla l alvisi m dahlin clement e wong zyzzyva speculative byzantine fault tolerance acm sigops operating systems review 41 6 45 58 2007 11 l lamport time clocks ordering events distributed system communications acm 21 7 558 565 1978 42 12 l lamport et al paxos simple acm sigact news 32 4 18 25 2001 13 l lamport r shostak m pease byzantine generals problem acm trans program lang syst 4 3 382 401 july 1982 14 d larimer delegated proof stake dpos 2014 15 c lemahieu raiblocks feeless distributed cryptocurrency network 2017 16 s d lerner dagcoin 2015 17 c li p li w xu f long c c yao scaling nakamoto consensus thousands transactions second arxiv preprint arxiv 1805 03870 2018 18 miller y xia k croman e shi d song honey badger bft protocols proceedings 2016 acm sigsac conference computer communications security pages 31 42 acm 2016 19 s nakamoto bitcoin peer peer electronic cash system 2008 20 p panangaden k taylor concurrent common knowledge de ning agreement asynchronous systems distributed computing 6 2 73 93 1992 21 f h q m s s pierre chevalier bartomiej kamin ski protocol asynchronous reliable secure e cient consensus parsec 2018 22 s popov tangle 2017 23 y sompolinsky y lewenberg zohar spectre fast scalable cryptocurrency protocol iacr cryptology eprint archive 2016 1159 2016 24 y sompolinsky zohar phantom ghostdag scalable blockdag protocols 2008 25 s n sunny king ppcoin peer peer crypto currency proof stake 2012 26 m swan blockchain blueprint new economy o reilly media 2015 43