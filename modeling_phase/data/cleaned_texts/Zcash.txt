zerocash decentralized anonymous payments bitcoin extended version eli ben sasson alessandro chiesa christina garman matthew green ian miers eran tromer madars virza 18 2014 abstract bitcoin rst digital currency widespread adoption payments conducted pseudonyms bitcoin o er strong privacy guarantees payment transactions recorded public decentralized ledger information deduced zerocoin miers et al ieee s p 2013 tackles privacy issues unlinking transactions payment s origin reveals payment destinations amounts limited functionality paper construct edged ledger based digital currency strong privacy guarantees results leverage recent advances zero knowledge succinct non interactive arguments knowledge zk snarks formulate construct decentralized anonymous payment schemes dap schemes dap scheme lets users pay directly privately corresponding transaction hides payment s origin destination provide formal de nitions proofs construction s security build zerocash practical instantiation dap scheme construction zerocash transactions 1 kb 6 ms verify orders magnitude e cient anonymous zerocoin competitive plain bitcoin keywords bitcoin decentralized electronic cash zero knowledge proofs technion eli cs technion ac il ymit falexch madarsg mit edu zjohns hopkins university fcgarman imiers mgreeng cs jhu edu x tel aviv university tromer cs tau ac il 1 contents 1 introduction 3 1 1 zk snarks 4 1 2 centralized anonymous payment systems 5 1 3 decentralized anonymous payment schemes 5 1 4 zerocash 9 1 5 paper organization 10 2 background zk snarks 10 2 1 informalde nition 10 2 2 comparisonwithnizks 11 2 3 known constructionsandsecurity 12 2 4 zk snarkimplementations 12 3 de nition decentralized anonymous payment scheme 13 3 1 datastructures 13 3 2 algorithms 14 3 3 completeness 16 3 4 security 16 4 construction decentralized anonymous payment scheme 18 4 1 cryptographicbuilding blocks 18 4 2 zk snarksforpouring coins 19 4 3 algorithmconstructions 20 4 4 completenessandsecurity 20 5 zerocash 20 5 1 instantiation ofbuildingblocks 22 5 2 arithmeticcircuit forpouring coins 23 6 integration existing ledger based currencies 26 6 1 integration replacingthe basecurrency 26 6 2 integration hybrid currency 26 6 3 extendingthebitcoinprotocol tosupport thecombined semantics 28 6 4 additionalanonymity considerations 28 7 experiments 28 7 1 performance ofzk snarksforpouring coins 29 7 2 performance ofzerocash algorithms 29 7 3 large scalenetwork simulation 30 8 optimizations extensions 33 8 1 everlasting anonymity 33 8 2 fast block propagation 34 8 3 improved storagerequirements 34 9 concurrent work 36 10 conclusion 36 acknowledgments 37 overview bitcoin zerocoin 38 1 bitcoin 38 2 zerocoin 38 b completeness dap schemes 39 c security dap schemes 40 c 1 ledgerindistinguishability 41 c 2 transaction non malleability 42 c 3 balance 43 d proof theorem 4 1 44 d 1 proof ofledgerindistinguishability 44 d 2 proof oftransactionnon malleability 48 d 3 proof ofbalance 51 references 54 2 1 introduction bitcoin rst digital currency achieve widespread adoption currency owes rise fact unlike traditional e cash schemes cha82 chl05 st99 requires trusted parties instead appointing central bank bitcoin uses distributed ledger known block chain store transactions carried users block chain massively replicated mutually distrustful peers information contains public users employ identities pseudonyms enhance privacy increasing body research shows de anonymize bitcoin information block chain rm11 bbsu12 rs12 mpj 13 structure transaction graph value dates transactions result bitcoin fails o er modicum privacy provided traditional payment systems let robust privacy anonymous e cash schemes bitcoin anonymous su cient motivation obfuscate transaction history help mixes known laundries tumblers mix allows users entrust set coins pool operated central party interval retrieve di erent coins total value pool mixes su er limitations delay reclaim coins large allow coins mixed ii mix operator trace coins iii mix operator steal coins 1 users hide risks acceptable typical legitimate users 1 wish spending habits private peers 2 risk averse wish expend continual e ort protecting privacy 3 su ciently aware privacy compromised protect privacy users need instant risk free importantly automatic guarantee data revealing spending habits account balances publicly accessible neighbors co workers merchants business anonymous transactions ensure market value coin independent history ensuring legitimate users coins remain fungible 2 zerocoin decentralized mix miers et al mggr13 proposed zerocoin extends bitcoin provide strong anonymity guarantees like e cash protocols e g chl05 zerocoin employs zero knowledge proofs prevent transaction graph analyses unlike earlier practical e cash protocols zerocoin rely digital signatures validate coins require central bank prevent double spending instead zerocoin authenticates coins proving zero knowledge belong public list valid coins maintained block chain edged anonymous currency zerocoin decentralized mix users periodically wash bitcoins zerocoin protocol routine day day transactions conducted bitcoin reasons review rst reason performance redeeming zerocoins requires double discrete logarithm proofs knowledge size exceeds 45 kb require 450 ms verify 128 bit security level 3 proofs broadcast network veri ed node permanently stored ledger entailed costs higher orders magnitude bitcoin seriously tax bitcoin network operating normal scale 1coinjoin max13 alternative proposal replaces central party mix multi signature transactions involve collaborating bitcoin users coinjoin mix small volumes coins users currently online prone denial service attacks parties requires e ort nd mixing partners 2while methods detail paper accomplish techniques open door privacy preserving accountability oversight section 10 3these published numbers mggr13 actually use mix parameters 128 bit 80 bit security di erent components construction cost higher parameters instantiated 128 bit security 3 second reason functionality zerocoin constitutes basic e cash scheme lacks critical features required edged anonymous payments zerocoin uses coins xed denomination support payments exact values provide means change following transaction e divide coins second zerocoin mechanism user pay directly zerocoins zerocoin provides anonymity unlinking payment transaction origin address hide metadata transactions occurring network contribution addressing challenge work o ers main contributions 1 introduce notion decentralized anonymous payment scheme formally captures functionality security guarantees edged decentralized electronic currency strong anonymity guarantees provide construction primitive prove security speci c cryptographic assumptions construction leverages recent advances area zero knowledge proofs speci cally uses zero knowledge succinct non interactive arguments knowledge zk snarks gro10 lip12 bci 13 ggpr13 pghr13 bcg 13 lip13 bctv14 2 implement primitive system zerocash system 128 bits security reduces size transactions spending coin 1 kb improvement 97 7% reduces spend transaction veri cation time 6 ms improvement 98 6% allows anonymous transactions variable amounts hides transaction amounts values coins held users allows payments directly user s xed address user interaction validate system measured performance established feasibility conducting experiments test network 1000 nodes approximately 1 unique ips bitcoin 16 network 1 nodes reachable given time dw13 inspires con dence 3 zerocash deployed fork bitcoin operate scale substantially improved functionality performance zerocash makes possible entirely replace traditional bitcoin payments anonymous alternatives concurrent work idea zk snarks bitcoin setting rst presented authors bitcoin 2013 ben13 concurrent work danezis et al dfkp13 suggest zk snarks reduce proof size veri cation time zerocoin section 9 comparison 1 1 zk snarks zk snark e cient variant zero knowledge proof knowledge gmr89 rst informally describe example suppose alice wishes prove bob statement alice 30 bitcoins simple method alice point 30 coins block chain sign message hello world secret key controls coin alas method leaks knowledge bob identifying coins alice s zero knowledge proof knowledge allows alice achieve goal revealing information bob fact knows secret keys control 30 coins crucially proofs obtained statement veri ed true use e cient computation involving auxiliary inputs trapdoors passwords statements called np statements sketch technical terms de nition zk snark section 2 details zk snark non interactive zero knowledge proof knowledge succinct e proofs short easy verify precisely let l np language let c nondeterministic decision circuit l given instance size n zk snark 4 prove verify membership l instances size n follows taking c input trusted party conducts time setup phase results public keys proving key pk veri cation key vk proving key pk enables untrusted prover produce proof p attesting fact x 2l instance x size n choice non interactive proof p zero knowledge proof knowledge use veri cation key vk verify proof particular zk snark proofs publicly veri able verify having interact prover generated succinctness requires given security level p constant size veri ed time linear jx linear jcj 1 2 centralized anonymous payment systems describing new decentralized payment system context recalling pre bitcoin payment schemes relied bank acting central trusted party anonymous e cash chaum cha82 rst obtained anonymous e cash chaum s scheme minting coin involves user alice bank mint coin given value v alice rst selects random secret serial number sn unknown bank bank deducting v alice s balance signs sn blind signature alice wants transfer coin bob reveals sn proves sn signed bank transfer bob bank deduce alice s identity revealed information double spending prevented bank honor coin previously seen serial number unforgeable e cash problem chaum s scheme coins forged bank s secret key compromised sander ta shma st99 addressed follows bank maintains public merkle tree coin commitments users periodically retrieve root rt particular bank maintains secrets alice requests coin unit value picks random serial number sn auxiliary string r sends cm crh snkr bank crh collision resistant hash bank deducts appropriate alice s balance records cm leaf merkle tree pay bob alice sends sn zero knowledge proof knowledge p following np statement exists r crh snkr leaf merkle tree root rt words alice convince bob sn serial number contained coin commitment merkle tree zero knowledge property prevents bob learning information coin commitment alice s protecting alice s identity later bob cash alice s coin showing sn p bank 4 moving fungible anonymous decentralized system paper like st99 hash coin s serial number use merkle trees compactly represent set minted coins unlike st99 ensure privacy coin s value support transactions split merge coins achieving implementing new kind fully fungible divisible payment scheme bitcoin stark contrast previous e cash schemes rely trusted bank require new set de nitions protocols designed protect alice s anonymity preventing falsely increasing balance veil boosted privacy informal description payment scheme follows 1 3 decentralized anonymous payment schemes construct decentralized anonymous payment dap scheme decentralized e cash scheme allows direct anonymous payments section 3 formal de nition 4we omit details bank identify alice event double spends coin 5 outline construction incremental steps construction details section 4 construction functions ledger based base currency bitcoin given time unique valid snapshot currency s ledger available users ledger sequence transactions append transactions include underlying currency s transactions new transactions introduced construction concreteness focus discussion bitcoin later de nitions constructions stated abstractly assume familiarity bitcoin nak09 zerocoin mggr13 reviewed appendix step 1 user anonymity xed value coins rst describe simpli ed construction coins value e g 1 btc construction similar zerocoin protocol shows hide payment s origin terms tools use zk snarks recalled commitment scheme let comm denote statistically hiding non interactive commitment scheme e given randomness r message m commitment c commr m subsequently c opened revealing r m verify commr m equals c simpli ed construction new coin c minted follows user u samples random serial number sn trapdoor r computes coin commitment cm commr sn sets c r sn cm corresponding mint transaction txmint containing cm sn r sent ledger txmint appended ledger u paid 1 btc backing escrow pool e g 1 btc paid plaintext information encoded txmint mint transactions certi cates deposit deriving value backing pool subsequently letting cmlist denote list coin commitments ledger u spend c posting spend transaction txspend contains coin s serial number sn ii zk snark proof p np statement know r commr sn appears list cmlist coin commitments assuming sn appear ledger past spend transaction u redeem deposited 1 btc u transfer mint new coin sn appear ledger considered double spending transaction discarded user anonymity achieved proof p zero knowledge sn revealed information r nding numerous commitments cmlist corresponds particular spend transaction txspend equivalent inverting f x commx sn assumed infeasible origin payment anonymous step 2 compressing list coin commitments np statement cmlist speci ed explicitly list coin commitments naive representation severely limits scalability time space complexity protocol algorithms e g proof veri cation algorithm grow linearly cmlist coin commitments corresponding spent coins dropped cmlist reduce costs identi ed zero knowledge property provides anonymity st99 rely collision resistant function crh avoid explicit representation cmlist maintain e ciently updatable append crh based merkle tree tree cmlist growing list cmlist let rt denote root tree cmlist known rt updated account insertion new leaves time space proportional tree depth time space complexity reduced linear size cmlist logarithmic mind modify np statement following know r commr sn appears leaf crh based merkle tree root rt compared naive data structure cmlist modi cation increases exponentially size cmlist given zk snark implementation support concretely merkle trees depth 64 zerocash supports 264 coins step 3 extending coins direct anonymous payments far coin commitment 6 cm coin c commitment coin s serial number sn creates problem transferring c user suppose user ua created c ua sends c user ub ua knows sn spending c ub non anonymous ua sees c spent recognizing sn risky ua spend c rst ub immediately spend c mint new coin c0 protect second ua fact wants transfer ub e g 100 btc unwieldy requires 100 transfers non anonymous transfer leaked transfers amounts multiples 1 btc xed value coin supported simpli ed construction described inadequate payment scheme address modifying derivation coin commitment pseudorandom functions target payments derive serial numbers follows use pseudorandom functions derived single seed x denoted prfaddr prfsn xx prfpk assume prfsn collision resistant x provide targets payments use addresses user u generates address key pair apk ask address public key address private key respectively coins u contain value apk spent knowledge ask key pair apk ask sampled selecting random seed ask setting apk prfaddr 0 user generate use number ask address key pairs redesign minting allow greater functionality mint coin c desired value v user u rst samples secret value determines coin s serial number sn prfsn u commits tuple apk v phases u computes ask k commr apkk random r b u computes cm comms vkk random s minting results coin c apk v r s cm mint transaction txmint v k s cm crucially nested commitment verify cm txmint coin commitment coin value v checking comms vkk equals cm discern owner learning address key apk serial number derived hidden k txmint accepted ledger u deposits correct case v btc coins spent pour operation takes set input coins consumed pours value set fresh output coins total value output coins equals old old total value input coins suppose u address key pair apk wishes consume sk old old old old new new coin c apk vold old r s cmold produce new coins c c total 12 new new old new new value v v v respectively targeted address public keys addresses 12 pk 1 pk 2 new new apk 2 belong u user user u 2f1 2g proceeds pk 1 newk new follows u samples serial number randomness new ii u computes knew commrnew ii pk new new newkknew new random r iii u computes cm commsnew v random s iii new new new new new new new new new yields coins c apk 1 v new r s cm c apk 2 v new 1 11111 2 22 new new new r s cm u produces zk snark proof pour following np statement 22 2 pour old new new given merkle tree root rt serial number sn coin commitments cm1 cm2 old new new old know coins c c c address secret key 12 sk old old coins formed cold holds kold commrold apk k old cm new new comm oldkkold similarly c c sold v 12 old prfaddr address secret key matches public key old 0 pk sk old old serial number computed correctly sn prfsn old sk old coin commitment cm appears leaf merkle tree root rt new new old values add v v v 12 7 old new new resulting pour transaction txpour rt sn cm1 cm2 pour appended ledger transaction rejected serial number sn appears previous transaction new suppose u know address secret key ask 1 associated new new new public key u spend c provide ask 1 witness pk 1 1 new new subsequent pour operation furthermore user knows spend c sk 11 user u track knows information revealed serial number new new sn prfsn new 1 1 sk 1 observe txpour reveals information value consumed coin divided new fresh coins coin commitment corresponds consumed coin address public keys new fresh coins targeted payment conducted anonymity generally user pour nold 0 coins nnew 0 coins simplicity consider nnew case nold 2 loss generality nold 2 user mint coin value 0 provide ull input nnew 2 user create discard 2 nnew new coin value 0 nold 2 user compose log nold log nnew 2 input 2 output pours new step 4 sending coins suppose address public key u1 order allow u1 pk 1 new actually spend new coin c1 produced u send secret values new c1 u1 way u send u1 private message requisite private communication channel necessitates additional infrastructure assumptions avoid band channel instead build capability directly construction leveraging ledger follows modify structure address key pair user key pair addrpk addrsk addrpk addrsk ask skenc values apk ask generated apk pkenc addition pk skenc key pair key private encryption scheme bbdp01 enc new new new u computes ciphertext c1 encryption plaintext v new r s 1 111 pknew sk 1 includes c1 u1 s address public key addrnew pour enc 1 transaction txpour user u1 nd decrypt message sknew enc 1 scanning pour transactions public ledger note adding c1 txpour leaks paid amounts target addresses key private property encryption scheme new user u c2 includes corresponding ciphertext c2 txpour step 5 public outputs construction far allows users mint merge split coins user redeem coins e convert base currency bitcoin modify pour operation include public output spending coin user u speci es nonnegative vpub transaction string info 2f0 1g balance equation new new np statement pour changed accordingly v v vold input 12 vpub old value v vpub publicly declared target speci ed string info string info specify destination redeemed funds e g bitcoin wallet public key 5 vpub info included resulting pour transaction txpour public output optional user u set vpub 0 step 6 non malleability prevent malleability attacks pour transaction txpour e g embezzlement targeting public output pour modifying info modify np statement pour use digital signatures speci cally pour operation user u samples key pair pksig sksig time signature scheme ii computes hsig crh pksig pk pk iii computes values h1 prf hsig h2 prf hsig act macs old old aa sk 1 sk 2 5these public outputs considered input bitcoin style transaction string info contains bitcoin output scripts mechanism allows support bitcoin s public transaction fees 8 tie hsig address secret keys iv modi es pour include values hsig h1 h2 prove computed correctly v uses sksig sign value associated pour operation obtaining signature included pksig txpour old secret high probability hsig changes pour transaction sk values h1 h2 unpredictable signature np statement values binds argued detail appendix c appendix d ends outline construction summarized figure 1 conclude noting zk snark construction requires time trusted setup public parameters soundness proofs depends trust anonymity continues hold setup corrupted malicious party c coin commitmentrt merke tree cm1 cm2 cmcrhcrhcrhcrhcrhcrhcrhcm1cm2cm3cm4cm5cm6cm7cm8crhcrhcrhcommv prfsnprfaddrs commr sn d serial numberrt merkle tree rootcm coin commitmentsn serial numberv coin valuer s commitment rand serial number rand apk pkenc address public key ask skenc address secret keyc apk pkenc v r s cm b coin figure 1 illustration crh based merkle tree list cmlist coin commitments b coin c c illustration structure coin commitment cm d illustration structure coin serial number sn 1 4 zerocash outline zerocash concrete implementation 128 bits security dap scheme construction section 5 details zerocash entails carefully instantiating cryptographic ingredients construction ensure zk snark heaviest component e cient practice construction zk snark prove verify speci c np statement pour zk snarks asymptotically e cient concrete e ciency depends arithmetic circuit c decide np statement seek instantiations design relatively small arithmetic circuit cpour verifying np statement pour approach instantiate necessary cryptographic ingredients commitment schemes pseudorandom functions collision resistant hashing based sha256 rst design hand optimized circuit verifying sha256 computations precisely compression function su ces purposes 6 use circuit construct cpour veri es necessary checks satisfying np statement cpour judicious parameter choices state art implementation zk snark arithmetic circuits bctv14 section 2 4 results zk snark prover 6alternatively opted rely circuit generators pghr13 bcg 13 bctv14 support classes c programs writing c code expressing pour checks discussed later generic approaches expensive hand optimized construction 9 running time minutes zk snark veri er running time milliseconds allows dap scheme implementation practical deployment experiments zerocash integrated bitcoin forks commonly referred altcoins later describe 1 5 paper organization remainder paper organized follows section 2 provides background zk snarks de ne dap schemes section 3 construction thereof section 4 section 5 discusses concrete instantiation zerocash section 6 describes integration zerocash existing ledger based currencies section 7 provides microbenchmarks prototype implementation results based network simulations section 8 describes optimizations discuss concurrent work section 9 summarize contributions future directions section 10 2 background zk snarks main cryptographic primitive paper special kind succinct non interactive argument knowledge snark concretely use publicly veri able preprocessing zeroknowledg e snark zk snark short section provide basic background zk snarks provide informal de nition compare zk snarks familiar notion nizks recall known constructions implementations 2 1 informal de nition informally de ne zk snarks arithmetic circuit satis ability refer reader e g bci 13 formal de nition eld f f arithmetic circuit takes inputs elements f gates output elements f naturally associate circuit function computes model nondeterminism consider circuits input x fn auxiliary input fh called witness circuits consider bilinear gates 7 arithmetic circuit satis ability de ned analogously boolean case follows de nition 2 1 arithmetic circuit satis ability problem f arithmetic circuit c fn fh fl captured relation rc f x fn fh c x 0lg language lc fx fn fh s t c x 0lg given eld f publicly veri able preprocessing zk snark f arithmetic circuit satis ability triple polynomial time algorithms keygen prove verify keygen 1 c pk vk input security parameter presented unary farithmetic circuit c key generator keygen probabilistically samples proving key pk veri cation key vk keys published public parameters number times prove verify membership lc prove pk x input proving key pk x 2rc prover prove outputs non interactive proof p statement x 2lc 7a gate inputs y1 ym f bilinear output h 1 y1 ym h b 1 y1 ym b fm 1 include addition multiplication negation constant gates 10 verify vk x b input veri cation key vk input x proof veri er verify outputs b 1 convinced x 2lc zk snark satis es following properties completeness security parameter f arithmetic circuit c x 2rc honest prover convince veri er b 1 probability 1 negl following experiment pk vk keygen 1 c p prove pk x b verify vk x succinctness honestly generated proof p o 1 bits verify vk x runs time o jxj o hides xed polynomial factor proof knowledge soundness veri er accepts proof output bounded prover prover knows witness given instance particular soundness holds bounded provers poly size adversary poly size extractor e verify vk x 1 x 6 rc probability negl following experiment pk vk keygen 1 c x pk vk e pk vk perfect zero knowledge honestly generated proof perfect zero knowledge 8 polynomial time simulator sim stateful distinguishers d following probabilities equal 23 pk vk keygen 1 c pk vk trap sim 1 c x 2rc x 2rc pr x d pk vk pr x d pk vk d 1 d 1 p prove pk x p sim trap x probability d 1 honest proof probability d 1 simulated proof remark proof knowledge zero knowledge essential use zk snarks paper consider circuits c verify assertions cryptographic primitives knowledge sha256 pre image binding commitment su ce merely know given input x witness x 2lc exists instead proof knowledge ensures witness e ciently found extracting prover veri er accepts proof zero knowledge ensures proof leaks information witness fact x 2lc remark security proofs appendix d deal provers producing vector inputs x vector corresponding proofs cases convenient use extractor extract vector witnesses containing valid witness valid proof multi instance extraction follows single instance described bcct12 bcct13 keygen prove verify zk snark poly size prover adversary exists poly size extractor e 2 pk vk keygen 1 c verify vk xi 1 pr s t 2rc x pk vk negl xi ai e pk vk 2 2 comparison nizks zk snarks related familiar cryptographic primitive non interactive zero knowledge proofs knowledge nizks zk snarks nizks require time trusted setup public 8while zk snark descriptions literature mention statistical zero knowledge zk snark constructions perfect zero knowledge allowing negligible error probability completeness 11 parameters proving veri cation keys zk snarks common reference string nizks provide guarantees completeness proof knowledge zero knowledge di erence lies e ciency guarantees nizk proof length veri cation time depend np language proved instance language circuit satis ability proof length veri cation time gos06b gos06a linear circuit size conversely zk snark proof length depends security parameter veri cation time depends instance size security parameter circuit witness size zk snarks thought succinct nizks having short proofs fast veri cation times succinctness comes caveat known zk snark constructions rely stronger assumptions nizks 2 3 known constructions security zk snark constructions literature gro10 lip12 bci 13 ggpr13 pghr13 bcg 13 lip13 bctv14 interested zk snarks arithmetic circuit satis ability e cient ones language based quadratic arithmetic programs ggpr13 bci 13 pghr13 bcg 13 bctv14 constructions provide linear time keygen quasilinear time prove linear time verify security zk snarks based knowledge exponent assumptions variants di e hellman assumptions bilinear groups gro10 bb04 gen04 knowledge exponent assumptions fairly strong evidence assumptions inherent constructing zk snarks gw11 bcct12 remark fully succinct zk snarks key generator keygen takes circuit c input keygen s running time linear size circuit c require keygen c input output keys work polynomial size circuits c case keygen s running time independent c zk snark satisfying stronger property fully succinct theoretical constructions fully succinct zk snarks known based cryptographic assumptions mic00 val08 bcct13 despite achieving essentially optimal asymptotics bfls91 bgh 05 bcgt13b bcgt13a bcct13 implementations reported literature date 2 4 zk snark implementations published implementations zk snarks parno et al pghr13 present implementation zk snarks programs having data dependencies 9 ii ben sasson et al bcg 13 present implementation zk snarks arbitrary programs data dependencies iii ben sasson et al bctv14 present implementation zk snarks supports programs modify code e g runtime code generation implementation reduces costs programs larger size allows universal key pairs works achieves zk snarks arithmetic circuit satis ability stepping stone respective higher level e orts paper interested zk snark arithmetic circuit satis ability rely implementation bctv14 zk snark 10 implementation bctv14 based protocol parno et al pghr13 refer interested reader pghr13 details protocol 9they support programs array indices restricted known compile time constants similarly loop iteration counts upper bounds known compile time 10in bctv14 optimization veri er s runtime requires preprocessing veri cation key vk simplicity use optimization 12 intuition proof security bctv14 implementation performance terms concrete parameters implementation bctv14 provides 128 bits security eld f 256 bit prime order p 3 de nition decentralized anonymous payment scheme introduce notion decentralized anonymous payment scheme dap scheme extending notion decentralized e cash mggr13 later section 4 provide construction 3 1 data structures begin describing giving intuition data structures dap scheme algorithms use produce data structures introduced section 3 2 basecoin ledger protocol applied ledger based base currency bitcoin generality refer base currency basecoin given time t users access lt ledger time t sequence transactions ledger append e t t 0 implies lt pre x lt 0 11 transactions ledger include basecoin transactions new transaction types described public parameters list public parameters pp available users system generated trusted party start time system s algorithms addresses user generates address key pair addrpk addrsk public key addrpk published enables direct payments user secret key addrsk receive payments sent addrpk user generate number address key pairs coins coin data object c associate following coin commitment denoted cm c string appears ledger c minted coin value denoted v c denomination c measured basecoins integer 0 maximum value vmax system parameter coin serial number denoted sn c unique string associated c prevent double spending coin address denoted addrpk c address public key representing owns c quantities associated coin c e g trapdoors implementation details new transactions basecoin transactions new types transactions mint transactions mint transaction txmint tuple cm v cm coin commitment v coin value denotes implementation dependent information transaction txmint records coin c coin commitment cm value v minted old old new new pour transactions pour transaction txpour tuple rt sn sn cm cm vpub info 121 2 old old new new rt root merkle tree sn sn coin serial numbers cm cm 12 12 coin commitments vpub coin value info arbitrary string denotes implementation dependent information transaction txpour records pouring old old old old input consumed coins c c respective serial numbers sn sn 12 12 new new new new new output coins c c respective coin commitments cm cm public 12 12 output vpub zero furthermore txpour records information string info containing information recipient vpub basecoins transaction root merkle tree coin commitments rt 11in reality basecoin ledger bitcoin perfect incur temporary inconsistencies respect construction good underlying ledger discuss e ects anonymity mitigations section 6 4 13 commitments minted coins serial numbers spent coins given time t cmlistt denotes list coin commitments appearing mint pour transactions lt snlistt denotes list serial numbers appearing pour transactions lt lists deduced lt convenient think separate practice separately maintained e ciency reasons cf section 8 3 merkle tree commitments given time t treet denotes merkle tree cmlistt rtt root function patht cm gives authentication path coin commitment cm appearing cmlistt root treet 12 convenience assume lt stores rtt 0 t 0 t e stores past merkle tree roots 3 2 algorithms dap scheme tuple polynomial time algorithms setup createaddress mint pour verifytransaction receive following syntax semantics system setup algorithm setup generates list public parameters setup inputs security parameter outputs public parameters pp algorithm setup executed trusted party resulting public parameters pp published available parties e g embedding protocol s implementation setup trusted party needed global secrets trapdoors kept creating payment addresses algorithm createaddress generates new address key pair createaddress inputs public parameters pp outputs address key pair addrpk addrsk user generates address key pair addrpk addrsk order receive coins public key addrpk published secret key addrsk redeem coins sent addrpk user generate number address key pairs require interaction minting coins algorithm mint generates coin given value mint transaction mint inputs public parameters pp coin value v 2f0 1 vmaxg destination address public key addrpk outputs coin c mint transaction txmint system parameter vmax caps value single coin output coin c value v coin address addrpk output mint transaction txmint equals cm v cm coin commitment c 12while refer mekle trees simplicity straightforward extend de nition allow data structures representing sets fast insertion e cient proofs membership 14 pouring coins pour algorithm transfers value input coins new output coins marking input coins consumed fraction input value publicly revealed pouring allows users subdivide coins smaller denominations merge coins transfer ownership anonymous coins public payments 13 pour inputs public parameters pp merkle root rt old old old coins c1 c2 old addresses secret keys addroldsk 1 addrold sk 2 authentication path path1 commitment cm cold root rt 1 authentication path path2 commitment cm cold root rt 2 new new new values v1 v2 new addresses public keys addrnew pk 2 pk 1 addrnew public value vpub transaction string info new new outputs new coins c c pour transaction txpour 12 old old pour algorithm takes input distinct input coins c1 c2 corresponding address secret keys addroldsk 1 addrold required redeem input coins ensure sk 2 old old c1 c2 previously minted pour algorithm takes input merkle root rt allegedly equal root merkle tree coin commitments far old old authentication paths path1 path2 coin commitments cm c1 cm c2 input values new new new new v v specify values new anonymous coins c c generated input 12 12 new new address public keys addrnewpk 1 addrpknew 2 specify recipients c c value vpub speci es 12 publicly spent e g redeem coins pay transaction fees sum output new new values v v vpub equal sum values input coins 12 exceed vmax finally pour algorithm receives arbitrary string info bound output pour transaction txpour new new pour algorithm outputs new coins c1 c2 pour transaction txpour old old new new new new transaction txpour equals rt sn sn cm cm vpub info cm cm 1212 12 coin commitments output coins denotes implementation dependent information crucially txpour reveals value public value vpub zero reveal payment addresses values old new coins verifying transactions algorithm verifytransaction checks validity transaction verifytransaction inputs public parameters pp mint pour transaction tx current ledger l outputs bit b equals 1 iff transaction valid mint pour transactions veri ed considered formed practice transactions veri ed nodes distributed system maintaining ledger 13we consider pours 2 inputs 2 outputs simplicity discussed section 1 3 loss generality 15 users rely transactions receiving coins algorithm receive scans ledger retrieves unspent coins paid particular user address receive inputs recipient address key pair addrpk addrsk current ledger l outputs set unspent received coins user address key pair addrpk addrsk wishes receive payments sent addrpk uses receive algorithm scan ledger payment addrpk appearing ledger receive outputs corresponding coins serial numbers appear ledger l coins received way spent like minted coins pour algorithm require receive detect coins paid addrpk pour algorithm detect coins minted user describe completeness section 3 3 security section 3 4 3 3 completeness completeness dap scheme requires unspent coins spent precisely consider ledger sampler s outputting ledger l c1 c2 coins coin commitments appear valid transactions l serial numbers appear l c1 c2 spent pour running pour results pour transaction txpour verifytransaction accepts new coins received intended recipients receive txpour correctly records intended vpub transaction string info property formalized incompleteness experiment incomp de nition 3 1 dap scheme setup createaddress mint pour verifytransaction receive complete polynomial size ledger sampler s wins incomp negligible probability appendix b details 3 4 security security dap scheme characterized properties ledger indistinguishability transaction non malleability balance de nition 3 2 dap scheme setup createaddress mint pour verifytransaction receive secure satis es ledger indistinguishability transaction non malleability balance provide informal overview property defer formal de nitions appendix c property formalized game adversary challenger c game behavior honest parties realized dap scheme oracle odap maintains ledger l provides interface executing createaddress mint pour receive algorithms honest parties elicit behavior honest parties passes query c sanity checks proxies query odap query requests honest party perform action speci es identities previous transactions input values learns resulting transaction secrets trapdoors involved producing transaction oracle odap provides insert query allows directly add aribtrary transactions ledger l 16 ledger indistinguishability property captures requirement ledger reveals new information adversary publicly revealed information values minted coins public values information strings total number transactions etc adversary adaptively induce honest parties perform dap operations choice bounded adversary distinguish ledgers l0 l1 constructed queries dap scheme oracles queries oracles publicly consistent matching type identical terms publicly revealed information information related addresses controlled ledger indistinguishability formalized experiment l ind proceeds follows challenger samples random bit b initializes dap scheme oracles odap 0 odap maintaining ledgers l0 l1 challenger allows issue queries 1 odap odap 01 controlling behavior honest parties l0 l1 challenger provides adversary view ledgers randomized order lleft lb lright l1 b adversary s goal distinguish view sees corresponds lleft lright l0 l1 e b 0 lleft lright l1 l0 e b 1 round experiment adversary issues queries pairs q q0 matching query type query type createaddress address generated oracles mint pour receive q forwarded l0 q0 l1 insert queries query q forwarded lleft q0 forwarded lright adversary s queries restricted sense maintain public consistency ledgers example public values pour queries minted amounts mint queries conclusion experiment outputs guess b0 wins b b0 ledger indistinguishability requires wins l ind probability negligibly greater 1 2 transaction non malleability property requires bounded adversary alter data stored valid pour transaction txpour transaction non malleability prevents malicious attackers modifying transactions added ledger e g targeting basecoin public output pour transaction transaction non malleability formalized experiment tr nm adaptively interacts dap scheme oracle odap outputs pour transaction tx letting t denote set pour transactions returned odap l denote nal ledger wins game exists tx 2t tx 6 tx ii tx reveals serial number contained tx iii tx tx valid respect ledger l0 containing transactions preceding tx l words wins game tx manages modify previous pour transaction spend coin di erent way transaction non malleability requires wins tr nm negligible probability note course produce valid pour transactions unrelated t condition tx reveals serial number previously spent coin captures non malleability balance property requires bounded adversary money minted received payments balance formalized experiment bal adaptively interacts dap scheme oracle odap outputs set coins scoin letting addr set addresses returned createaddress queries e addresses honest users wins game total value spend spent coins basecoin public outputs greater value minted received wins vunspent vbasecoin va addr vmint vaddr vunspent total value unspent coins scoin ii vbasecoin total value public outputs placed ledger iii vmint total value s mint transactions iv vaddr total value payments received addresses addr v va addr total value 17 payments sent addresses addr balance requires wins bal negligible probability 4 construction decentralized anonymous payment scheme construct dap scheme introduced section 3 zk snarks building blocks later section 5 concrete instantiation construction 4 1 cryptographic building blocks rst introduce notation standard cryptographic building blocks use assume familiarity de nitions building blocks details e g kl07 denotes security parameter collision resistant hashing use collision resistant hash function crh f0 1g f0 1go pseudorandom functions use pseudorandom function family prf fprfx f0 1g f0 1go gx x denotes seed prfx derive overlapping pseudorandom functions chosen arbitrarily prfaddr z prfx 00kz prfsn z prfx 01kz prfpk z x xx prfx 10kz furthermore assume prfsn collision resistant sense 0 infeasible nd x z 6 x z0 prfsn z prfsn 0 z0 xx statistically hiding commitments use commitment scheme comm binding property holds computationally hiding property holds statistically denoted fcommx f0 1g f0 1go gx x denotes commitment trapdoor reveal commitment cm value z su ces provide z trapdoor x check cm commx z time strongly unforgeable digital signatures use digital signature scheme sig gsig ksig ssig vsig works follows gsig 1 ppsig given security parameter presented unary gsig samples public parameters ppsig encryption scheme ksig ppsig pksig sksig given public parameters ppsig ksig samples public key secret key single user ssig sksig m given secret key sksig message m ssig signs m obtain signature vsig pksig m b given public key pksig message m signature vsig outputs b 1 signature s valid message m outputs b 0 signature scheme sig satis es security property time strong unforgeability chosen message attacks suf 1cma security key private public key encryption use public key encryption scheme enc genc kenc eenc denc works follows genc 1 ppenc given security parameter presented unary genc samples public parameters pp encryption scheme enc kenc ppenc pkenc skenc given public parameters ppenc kenc samples public key secret key single user eenc pk m c given public key pk message m eenc encrypts m obtain enc enc ciphertext c denc skenc c m given secret key skenc ciphertext c denc decrypts c produce message m decryption fails encryption scheme enc satis es security properties ciphertext indistinguishability chosen ciphertext attack ind cca security ii key indistinguishability chosen ciphertext 18 attack ik cca security rst property standard second known informally ik cca requires ciphertexts linked public key encrypt ciphertexts encrypted public key de nitions refer reader bbdp01 4 2 zk snarks pouring coins outlined section 1 3 construction invokes zk snark speci c np statement pour de ne rst recall context motivating pour user u pours old coins old old new new c c new coins c c corresponding pour transaction 12 12 old old new new rt sn sn cm cm vpub info txpour 121 2 generated construction need provide evidence conditions respected pour operation concretely txpour demonstrate u owns old old old old c c ii coin commitments c c appear ledger iii revealed 12 12 old old old old new new serial numbers sn sn c c iv revealed coin commitments cm cm 1212 12 new new c1 c2 v balance preserved construction achieves including zk snark proof pour statement pour checks invariants needed non malleability statement pour concretely np statement pour de ned follows old old new new instances form x rt sn sn cm cm vpub hsig h1 h2 instance x 121 2 speci es root rt crh based merkle tree list commitments far serial numbers consumed coins coin commitments new coins public value elds hsig h1 h2 non malleability old old new new witnesses form path1 path2 c1 c2 sk 1 addroldsk 2 c12 addrold c 2f1 2g old old old old old c addrold old r s cm pk v iiii new new new new new new c addrnew new r s cm cm x pk v iiii old pk pkold addrold pk enc new pk pknew addrnew pk enc old sk skold addroldsk enc witness speci es authentication paths new coin commitments entirety coin information old new coins address secret keys old coins given pour instance x witness valid x following holds 1 2f1 2g old old coin commitment cmi ci appears ledger e pathi valid authentication path leaf cmold respect root rt crh based merkle tree old old old prfaddr b address secret key matches address public key c e old 0 sk pk sk old old old old c serial number sn c computed correctly e sn prfsn old ii iai sk old old old k old old d coin c formed e cm comm old comm old kv isr pk ii ii new new newk new new e coin c formed e cm commsnew commrnew kv ii ii pk ii old pk f address secret key ties hsig hi e hi prf sk old ikhsig sk 19 new new old old old old old old 2 balance preserved v v v v v v 0 v v 12 vpub 1212 12 vmax recall paper zk snarks relative language arithmetic circuit satis ability section 2 express checks pour arithmetic circuit denoted cpour particular depth dtree merkle tree needs hardcoded cpour parameter construction maximum number supported coins 2dtree 4 3 algorithm constructions proceed describe construction dap scheme setup createaddress mint pour verifytransaction receive intuition given section 1 3 figure 2 gives pseudocode algorithms terms building blocks introduced section 4 1 section 4 2 construction hardcode quantities maximum value coin vmax depth merkle tree dtree 4 4 completeness security main theorem states construction dap scheme theorem 4 1 tuple setup createaddress mint pour verifytransaction receive de ned section 4 3 complete cf de nition 3 1 secure cf de nition 3 2 dap scheme provide proof theorem 4 1 appendix d note construction modi ed yield statistical e everlasting anonymity discussion section 8 1 remark trusted setup security relies trusted party running setup generate public parameters trust needed transaction non malleability balance properties ledger indistinguishability powerful espionage agency corrupt setup anonymity maintained wishes mitigate trust requirements step conduct computation setup secure multiparty computation techniques leave future work remark use pp according de nition dap scheme section 3 public parameters pp given input algorithms presented construction figure 2 construction public parameters pp equal tuple pkpour vkpour pp ppsig algorithm needs component pp concretely enc createaddress needs ppenc mint security parameter pour pkpour ppsig verifytransaction vkpour receive particular rely zk snarks prove verify pour pkpour constant large size required pour components pp small constant size remark checking received coins ledger algorithm receive tests serial number received coin appears ledger order output coins user received spent users case unable spend coins addressed user 5 zerocash describe concrete instantiation dap scheme instantiation forms basis zerocash later section 6 discuss zerocash integrated existing ledger based currencies 20 setup pour inputs security parameter inputs outputs public parameters pp public parameters pp merkle root rt 1 construct cpour pour security old old old coins c1 c2 2 compute pkpour vkpour keygen 1 cpour old addresses secret keys addroldsk 1 addroldsk 2 3 compute ppenc genc 1 path path1 commitment cm c1 root rt 4 compute ppsig gsig 1 old path path2 commitment cm c old root rt 5 set pp pkpour vkpour pp 2 enc ppsig new new new values v1 v2 6 output pp new addresses public keys addrnew pk 2 pk 1 addrnew public value vpub createaddress transaction string info inputs public parameters pp new new outputs new coins c1 c2 pour transaction txpour outputs address key pair addrpk addrsk 1 2f1 2g 1 compute pkenc skenc kenc ppenc old old old old old old parse c pk v r s cm addrold iiii 2 randomly sample prfaddr seed ask skold skold prfaddr sk enc b parse addrold 3 compute apk ask 0 old old c compute sni prfsn aold 4 set addrpk apk pkenc sk pk pknew pk enc 5 set addrsk ask skenc d parse addrnew new e randomly sample prfsn seed new new new 6 output addrpk addrsk f randomly sample comm trapdoors r s ii pk ik new g compute knew commrnew new mint new newkknew h compute cm commsnew v ii inputs new new new new new new set c pk v r s cm addrnew iiii public parameters pp new new new j set ci eenc pknew new r s enc viiii coin value v 2f0 1 vmax 2 generate pksig sksig ksig ppsig destination address public key addrpk 3 compute hsig crh pksig outputs coin c mint transaction txmint 4 compute h1 prfpk 1khsig h2 prfpk 2khsig old old 1 parse addrpk apk pkenc ask 1 ask 2 old old new new 5 set x rt sn sn cm cm vpub hsig h1 h2 2 randomly sample prfsn seed 121 2 old old new new 1 addrold sk 2 c c2 3 randomly sample comm trapdoors r s 6 set path1 path2 c c2 sk 1 addrold 1 7 compute pour prove pkpour x 4 compute k commr apkk 8 set m x pour info c1 c2 5 compute cm comms vkk 9 compute s ssig sksig m old old new new 6 set c addrpk v r s cm 7 set txmint cm v k s 10 set txpour rt sn1 sn2 cm1 cm2 vpub info 8 output c txmint pksig h1 h2 pour c1 c2 new new 11 output c1 c2 txpour verifytransaction receive inputs inputs public parameters pp public parameters pp mint pour transaction tx recipient address key pair addrpk addrsk outputs bit b equals 1 iff transaction valid current ledger l current ledger l outputs set received coins 1 given mint transaction tx txmint 1 parse addrpk apk pk parse txmint cm v k s enc b set cm 0 comms vkk 2 parse addrsk ask skenc c output b 1 cm cm 0 output b 0 3 pour transaction txpour ledger old old new new 2 given pour transaction tx txpour parse txpour rt sn1 sn2 cm1 cm2 vpub info old old new new parse txpour rt sn1 sn2 cm1 cm2 vpub info pksig h1 h2 pour c1 c2 pksig h1 h2 pour c1 c2 b 2f1 2g old old old old b sn sn appears l sn sn output b 0 compute vi ri si denc skenc ci 12 12 c merkle root rt appear l output b 0 ii denc s output verify d compute hsig crh pksig cm new equals commsi vikcommri apkk old old new new e set x rt sn1 sn2 cm1 cm2 vpub hsig h1 h2 sni prfa sn sk appear l f set m x pour info c1 c2 iii checks succeed output new g compute b vsig pksig m ci addrpk vi ri si cmi h compute b0 verify vkpour x pour output b b0 figure 2 construction dap scheme zk snarks ingredients 21 5 1 instantiation building blocks instantiate dap scheme construction section 4 figure 2 aiming level security 128 bits requires concrete choices described crh prf comm sha256 let h sha256 compression function maps 512 bit input 256 bit output rely h hash su ces xed size single block inputs simpli es construction cpour section 5 2 instantiate crh prf comm h suitable assumptions h instantiate collision resistant function crh h z z 2f0 1g512 function compresses construct binary merkle trees 14 instantiate pseudorandom function prfx z h xkz x 2f0 1g256 seed z 2f0 1g256 input 15 derived functions prfaddr z h xk00kz prfsn z h xk01kz prfpk z h xk10kz x xx x 2f0 1g256 z 2f0 1g254 commitment scheme comm use following pattern k commr apkk cm comms vkk instantiation prf apk 256 bits set 256 bits r 256 128 384 bits compute k commr apkk h rk h apkk 128 128 denotes truncating 256 bit string 128 bits dropping leastsigni cant bits implementation heuristically string z 2f0 1g128 distribution induced h rkz is2 128 close uniform forms basis statistically hiding property computing cm set coin values 64 bit integers particular vmax 264 1 implementation compute h kk0192kv cm comms vkk noticeably ignoring commitment randomness s reason know k output statistically hiding commitment serve randomness commitment scheme instantiating np statement pour choices imply concrete instantiation np statement pour section 4 2 speci cally implementation pour checks following holds 2f1 2g old pathi authentication path leaf cm respect root rt crh based merkle tree old old k0256 h pk sk old old k01k old sn h sk 254 old old old k old old cm h h r k h apk 128 k0192kv iii 14a single exception compute hsig according hash sha256 compression function need computation veri ed cpour 15this assumption reminiscent previous works analyzing security hash based constructions e g bel06 work assume portion compression function seed pseudorandom function chaining variable bel06 22 new new newk new new cm h h r k h 128 k0192kv ii pk ii old hi h k10kbik hsig 253 b1 0 b2 1 sk new new old old old old old old 264 pour checks v v v v v v 0 v v 12 vpub 1212 12 finally mentioned order cpour de ned need x merkle tree depth dtree implementation x dtree 64 support 264 coins instantiating sig signature scheme sig use ecdsa retain consistency compatibility existing bitcoind source code standard ecdsa malleable r s r s verify valid signatures use non malleable variant s restricted lower half eld elements aware formal suf 1cma proof variant use consistent proposals resolve bitcoin transaction malleability wui14 16 instantiating enc encryption scheme enc use key private elliptic curve integrated encryption scheme ecies cer00 standardized key private encryption schemes available implementations 5 2 arithmetic circuit pouring coins dap scheme construction section 4 figure 2 requires zk snarks relative np statement pour obtained invoking zk snark arithmetic circuit satis ability section 2 4 arithmetic circuit cpour veri es np statement pour instantiation rely implementation bctv14 basic zk snark section 2 4 apply circuit cpour construction described 5 2 1 arithmetic circuit verifying sha256 s compression function vast majority veri cation work pour verifying computations h compression function sha256 section 5 1 begin discussing construction arithmetic circuit ch verifying sha256 computations later section 5 2 2 discuss construction cpour given circuit ch wish construct arithmetic circuit ch 256 bit digest h 512 bit input z h z 2rch h h z naturally goal minimize size ch high level strategy construct ch piece piece closely following sha256 o cial speci cation nat12 subcomputation sha256 use nondeterminism eld operations verify subcomputation gates possible overview sha256 s compression function primitive unit sha256 32 bit word subcomputations simple word operations bitwise operations xor shift right rotate right addition modulo 232 compression function internally state 8 words initialized xed value transformed 64 successive rounds following 64 word message schedule deduced input z 256 bit output concatenation 8 words nal state representing state nd word operation addition modulo 232 e cient verify operation inputs represented separate wires carrying bit ch maintains 8 word state 256 individual wires 64 word message schedule 64 32 wires addition modulo 32 verify addition modulo 232 use techniques employed previous p31 work pghr13 bcg 13 bctv14 given words b compute 2i ai bi 0 16in practice replace ecdsa variant ec schnorr signature satisfying suf 1cma security proper encoding ec group elements performance similar 23 f characteristic larger 233 wrap eld addition coincides integer addition non deterministic guess 33 bits including carry enforce consistency requiring p32 2i ensure 2f0 1g 0 use 33 gate subcircuit computing 1 0 subcircuit satis able overall verifying addition modulo 232 requires 34 gates approach extends straightforward way summation terms verifying sha256 message schedule rst 16 words wi message schedule 16 words 512 bit input z remaining 48 words computed wt 1 wt 2 wt 7 0 wt 15 wt 16 0 w rotr7 w rotr18 w shr3 w 1 structure di erent rotation shift constants rotation shift amounts constants rotates shifts achieved suitable wiring previously computed bits constant 0 high order bits shr xor 3 bits computed 2 gates 0 1 computed 64 gates compute precisely guess verify addition modulo 232 terms verifying sha256 round function round function modi es 8 word state changing words permuting 8 word result modi ed words sum modulo 232 round speci c constant words kt ii message schedule words wt iii words obtained applying simple functions state words functions bitwise majority maj b c 0 ai bi ci 1 1 bitwise choice ch b c bi ai 1 ci verify correct computation maj 2 gates output bit ch 1 instead copying 6 unchanged state words obtain permuted result permutation implicit circuit s wiring output wires previous sub computations reaching 4 round functions input wires current sub computation performance overall obtain arithmetic circuit ch verifying sha256 s compression function 30 000 arithmetic gates figure 3 breakdown gate counts gate count ch message schedule rounds 1 round 64 finalize 8032 19 584 306 288 total 27 904 figure 3 size circuit ch sha256 s compression function comparison generic approaches constructed circuit ch scratch instead opted generic approaches implement sha256 s compression function higher level language use circuit generator obtain corresponding circuit generic approaches signi cantly expensive application explain starting sha256 implementation polarssl popular cryptographic library pol13 fairly straightforward write c program computing h wrote program gave input circuit generator pghr13 output circuit 58160 gates twice larger hand optimized circuit alternatively compiled c program tinyram architecture supported bcg 13 obtained 5371 instruction assembly code takes 5704 cycles execute tinyram invoke circuit generator bcg 13 given tinyram program time bound tinyram cycle costs 1000 gates resulting circuit 5 7 106 gates e 190 times larger circuit 24 similar computation holds circuit generator bctv14 supports exible architecture overall better constructing ch scratch course surprising sha256 computation circuit computation use complex program ow accesses memory relying machinery developed support richer classes programs pay o 5 2 2 arithmetic circuit pour np statement pour requires verifying membership merkle tree based h additional invocations h integer addition comparison construct circuit cpour pour combining subcircuits verifying remains discuss subcircuits verifying membership merkle tree aforementioned subcircuit ch verifying invocations h integer addition comparison merkle tree membership need construct arithmetic circuit given root rt authentication path path coin commitment cm satis ed path valid authentication path leaf cm respect root rt authentication path path includes layer auxiliary hash value hi bit ri specifying hi left ri 0 right ri 1 child parent node check membership merkle tree verifying invocations h d 64 set kd 1 cm d 1 1 set bi hikki ri 0 kikhi compute ki 1 h bi finally check root k0 matches given root rt integer addition need construct arithmetic circuit given 64 bit integers b c presented binary strings satis ed c b integers relyingp63 2i fact f s characteristic su ciently large checking ci 0 p63 0 2i bi ai f wrap integer comparison need construct arithmetic circuit given 64 bit integers b represented binary satis ed b ts 64 bits e b 264 p63 p63 checking 2i bi ai 0 ci ci 2f0 1g b 264 0 su ces ci binary representation b b 264 choice p63 ci satisfy constraint 0 ci 264 1 overall requires 65 gates 1 gate equality check 64 gates ensuring c0 c63 boolean overall circuit sizes figure 4 size cpour 99% gates devoted verifying invocations h gate count cpour oldensure cm1 merkle tree 1 layer 64 oldensure cm2 merkle tree 1 layer 64 old oldcheck computation sn1 sn2 old oldcheck computation apk 1 pk 2 old old new newcheck computation cm1 cm2 cm1 cm2 check computation h1 h2 new new old oldensure v1 v2 vpub v1 v2 old old 264ensure v1 v2 miscellaneous 1 802 304 28 161 1 802 304 28 161 2 27 904 2 27 904 4 83 712 2 27 904 1 65 2384 total 4 109 330 figure 4 size circuit cpour veri es statement pour 25 6 integration existing ledger based currencies zerocash deployed atop ledger maintained central bank brie y detail integration bitcoin protocol explicitly stated following section referring bitcoin unit account bitcoin plural bitcoins mean underlying protocol software currency system discussion holds little modi cation forks bitcoin known altcoins litecoin introducing new transaction types payment semantics zerocash breaks compatibility bitcoin network zerocash integrated bitcoin actual currency supporting software ag day super majority bitcoin miners simultaneously adopt new software expect advise integration near future suggest zerocash separate altcoin integrating zerocash bitcoin consists adding new transaction type zerocash transactions modifying protocol software invoke zerocash s dap interface create verify transactions possible approaches integration rst approach replaces bitcoins zerocoins making transactions anonymous cost losing additional bitcoin functionality provided e g bitcoin scripting language section 6 1 second approach maintains functionality adding parallel zerocash currency zerocoin converted bitcoin rate section 6 2 options protocol level modi cations later approach discussed section 6 3 readily inferred section 6 4 discuss anonymizing network layer bitcoin anonymity safeguards 6 1 integration replacing base currency approach alter underlying system monetary transactions zerocash e invoking dap interface writing reading associated transactions distributed ledger seen section 3 su ces o er core functionality payments minting merging splitting etc assuring users transactions currency anonymous drawbacks 1 pour transactions incur cost generating zk snark proof 2 bitcoin supports additional features scripting language specifying conditions claiming bitcoins bitcoin features lost 17 3 bitcoin allows exibility spending uncon rmed transactions instead zerocash bitcoin exibility lost transactions con rmed spent imposes minimal delay receiving funds spending 6 2 integration hybrid currency di erent approach extend bitcoin parallel anonymized currency zerocoins existing alongside bitcoins ledger ability convert freely behavior functionality regular bitcoins unaltered particular support functionality scripting approach bitcoin ledger consists bitcoin style transactions containing inputs outputs nak09 input pointer output previous transaction plain bitcoin zerocash pour transaction contributes public value vpub bitcoins transaction outputs destination public address script plain 17however principle pour extended include scripting language interpreter 26 bitcoin zerocash mint transaction consumes input bitcoins produce zerocoins usual invariant bitcoins maintained checked plain view sum bitcoin inputs including pours vpub sum bitcoin outputs including mints v di erence o ered transaction fee accounting zerocoins consumed produced separately implicitly dap scheme life cycle zerocoin follows creating new zerocoins mint transaction consumes v worth bitcoins inputs outputs coin commitment worth v zerocoins v bitcoins e ectively destroyed exchange newly minted zerocoins spending zerocoins zerocoins transferred split merged zerocoins arbitrarily pour transactions instead explicit inputs include zero knowledge proofs inputs exist pour transactions optionally reveal non zero public output vpub left unclaimed transaction fee 18 placed standard bitcoin transaction output e g paying public key consumed mint transaction vpub bitcoins created ex nihilo similarly coinbase transactions produce bitcoin outputs mining reward exchange destroying zerocoins bitcoin outputs included transaction string info included pour transaction transaction non malleability ensures information bound spending multiple zerocoins allow pours span input output coins txpour structures chained transaction marking output coin commitments intermediates having subsequent pours transaction constructed relative ephemeral merkle tree consisting intermediates commitments example transaction accept input coins rst pour operations combining inputs produce intermediate commitment nal pour combining intermediate commitments nal output new coin intermediate results consumed instantly transaction need recorded global merkle tree serial numbers marked spent transaction fees collecting transaction fees usual coinbase transaction added block pays mining reward di erence total inputs bitcoin pours vpub total outputs bitcoin mints v block payment bitcoins newly minted zerocoins mint validation block generation transactions veri ed verifytransaction received node plain bitcoin inputs outputs processed usual zerocash inputs outputs checked verifytransaction entire bitcoin transaction fed info authentication transactions assembled candidate block transaction needs veri ed ensure serial number spent merkle root invalid checks pass set new coin commitments spent serial numbers output included transactions added global sets new merkle root digest serial number list stored new block 19 embedding data simpli es statekeeping allows nodes readily verify correct coin list serial number list receiving candidate block nodes validate block formed correctly respect procedure receiving payments order receive payments address users scan block chain running receive pour transaction alternatively receive coin information 18since transaction fees potentially claimed node network represent sole zerocoin output hidden public view zerocash system 19this stored coinbase transaction certain data currently new eld block header 27 band mechanism e g encrypted email process nearly identical proposed stealth addresses bitcoin worst case scanning block chain requires trial decryption ciphertext c expect scenarios provide explicit noti cation e g interactive purchases communication channel exists payer payee implementations opt drop receive mechanism entirely require band noti cation order avoid storing ciphertexts block chain 6 3 extending bitcoin protocol support combined semantics section describes life cycle zerocoin semantics system remains question transactions acquire necessary semantics implementation approaches possible di erent engineering tradeo s rst approach extend protocol implementation hard coded validation zerocash transactions reading new designated elds transactions running verifytransaction case zk snark e ectively replaces scripting language zerocash transactions second approach extend bitcoin s scripting language adding opcode invokes verifytransaction requisite arguments embeded alongside opcode script transactions exempt requirement reference input zerocash transactions self contained like coinbase transactions able create bitcoins ex nihilo account vpub verifytransaction run standard point bitcoin transaction processing ow evaluating scripts coin commitments spent serial numbers actually added cmlist resp snlist containing block accepted e merely verifying transaction e ects 6 4 additional anonymity considerations zerocash anonymizes transaction ledger network tra c announce transactions retrieve blocks contact merchants leaks identifying information e g ip addresses users need anonymity network safely use zerocash obvious way tor dms04 given zerocash transactions low latency mixnets e g mixminion ddm03 viable way add anonymity unlike tor vulnerable tra c analysis mixnets provide email like functionality added bene t providing band noti cation mechanism replace receive additionally theory users single view block chain powerful attacker potentially fabricate additional block solely targeted user spending coins respect updated merkle tree poison pill block uniquely identify targeted user mitigate attacks users check trusted peers view block chain sensitive transactions spend coins relative blocks ledger creating illusion multiple blocks far harder 7 experiments measure performance zerocash ran experiments benchmarked performance zk snark np statement pour section 7 1 dap scheme algorithms section 7 2 second studied impact higher block veri cation time simulation bitcoin network section 7 3 28 7 1 performance zk snarks pouring coins zk snark np statement pour obtained constructing arithmetic circuit cpour verifying pour invoking generic implementation zk snark arithmetic circuit satis ability bctv14 section 2 4 arithmetic circuit cpour built scratch hand optimized exploit nondeterministic veri cation large eld characteristic section 5 2 figure 5 reports performance characteristics resulting zk snark pour includes settings single thread performance laptop machine single thread multi thread performance desktop machine time measurements average 10 runs standard deviation 2 5% instance single thread code laptop machine obtain key generation takes 7 min 48 s results proving key pkpour 896 mib veri cation key vkpour 749 b performed setup algorithm producing proof pour requires 3 minutes proofs constant size 288 b proof generation subroutine pour algorithm resulting proof included corresponding pour transaction proof pour veri ed 8 5 ms proof veri cation subroutine verifytransaction algorithm given input pour transaction verify intel core i7 2620m 2 70ghz 12gb ram intel core i7 4770 3 40ghz 16gb ram 1 thread 1 thread 4 threads keygen time 7 min 48 s 5 min 11 s 1 min 47 s proving key 896 mib veri cation key 749 b prove time 2 min 55 s 1 min 59 s 46 s proof 288 b verify time 8 5 ms 5 4 ms figure 5 performance zk snark np statement pour n 10 s 2 5% 7 2 performance zerocash algorithms figure 6 report performance characteristics dap scheme algorithms implementation single thread desktop machine verifytransaction separately report cost verifying mint pour transactions case exclude cost scanning l e g check serial number duplicate 20 case receive report cost process given pour transaction l obtain setup takes 5 minutes run running time dominated running time keygen cpour way setup run size resulting public parameters pp dominated size pkpour createaddress takes 326 0 ms run size resulting address key pair bytes 20naturally snlist 264 serial numbers maximum possible implementation scanning expensive expect system like zerocash grow 264 transactions system grow point scanning snlist expensive detail possible mitigations section 8 3 2 29 mint takes 23 s run results coin size 463 b mint transaction size 72 b pour takes 2 minutes run setup expensive algorithm run expected running time dominated running time prove transaction string info results new coins pour transaction size 996 b jinfoj verifytransaction takes 8 3 s verify mint transaction 5 7 ms verify pour transaction s time dominated verify checks zk snark proof pour receive takes 1 6 ms pour transaction note numbers include costs maintaining merkle tree responsibility dap scheme algorithms additional costs large update root crh based merkle tree requires dtree invocations crh ii authentication path consists dtree digests crh implementation crh h sha256 compression function dtree 64 update requires 64 invocations h authentication path requires 64 32 b 2 kib storage remark want rely ledger communicate coins ciphertexts c1 c2 instead rely instead band mechanism e g encrypted email receive algorithm needed aforementioned sizes decrease pieces data needed anymore denoted pieces data figure 6 e g size address key pair reduced 64 b size coin 120 b 7 3 large scale network simulation bitcoin mining typically takes place dedicated gpus asics cpu resources execute dap scheme algorithms minimal consequence network performance potential exception rule verifytransaction algorithm run network nodes course routine transaction validation time takes perform veri cation signi cant impact network performance zerocash implementation bitcoin zerocash transaction veri ed hop forwarded network potentially blocks containing transaction veri ed verifying block consists checking proof work validating contained transactions zerocash transactions longer spread network blocks containing zerocash transactions longer verify concerned rst issue potential impact second issue cause greater concern zerocash transactions spent ledger blocks veri ed hop forwarded network delays block veri cation slow propagation new blocks network causes nodes waste cpu cycles mining date blocks reducing computational power network making easier mount 51% attack dishonest majority miners distributed ledger priori unclear potential issue real concern bitcoin caches transaction veri cations transaction veri ed propagated network need veri ed seen block unknown percentage transactions block actually given node s cache conduct simulation bitcoin network investigate time takes zerocash transactions ledger establish e ects zerocash transactions block veri cation propagation nd zerocash transactions spent reasonably quickly e ects increased block validation time minimal 30 intel core i7 4770 3 40ghz 16gb ram 1 thread setup time 5 min 17 s size pp 896 mib size pkpour 896 mib size vkpour 749 b size ppenc 0 b size ppsig 0 b createaddress time 326 0 ms size addrpk size apk size pkenc 343 b 32 b 311 b size addrsk size ask size skenc 319 b 32 b 287 b mint time 23 s size coin c 463 b size addrpk 343 b size v 8 b size 32 b size r 48 b size s 0 b size cm 32 b size txmint 72 b size cm 32 b size v 8 b size k 32 b size s 0 b pour time 2 min 2 01 s size txpour size rt old oldsize sn sn1 2 new newsize cm cm1 2 size vpub size info size pksig size h1 h2 size pour size c1 c2 size s 996 b jinfoj32 b 2 32 b 2 32 b 8 b jinfoj66 b 2 32 b 288 b 2 173 b 64 b verifytransaction time mint tx 8 3 s time pour tx excludes l scan 5 7 ms receive time pour tx 1 6 ms figure 6 performance zerocash algorithms report sizes pp ppsig 0 b enc parameters hardcoded libraries rely enc sig n 10 s 2 5% variability short timescales mint 3 3 s verifytransaction 1 9 s simulation design zerocash requires breaking changes bitcoin protocol test protocol live bitcoin network dedicated testnet run private testnet e ciency cost reasons like run bitcoin nodes possible hardware raises issues reducing proof work practical levels preserving realistic rate new blocks di cult especially 31 virtualized hardware variable performance second overhead zk snark veri cation prevents running bitcoin nodes virtualized server frequency new blocks modeled poisson process mean block seconds 21 generate blocks stochastically modify bitcoind x block di culty trivial level 22 run poisson process simulation control server trivially mines block randomly selected node preserves distribution blocks computational overhead real proof work poisson process triggering mechanism di erent mean tx introduces new transactions random network nodes di erentiate transactions represent normal bitcoin expenditures versus contain zerocash pour transactions simulated zerocash transactions pay unique bitcoins set value arbitrarily 7 btc transaction s output matches preset value veri cation cache modi ed bitcoin client inserts 10 ms delay simulating runtime verifytransaction 23 transactions processed speci ed bitcoin protocol vary simulated zerocash tra c varying number transactions particular output minimizes code changes estimates generic impact veri cation delays speci c implementation choice methodology recent research dw13 suggests bitcoin network contains 16 000 distinct nodes likely longer participating approximately 3 500 reachable given time node average 32 open connections randomly selected peers november 2013 peak observed transaction rate bitcoin slightly transaction second lee13 simulation use 1000 node network node average 32 peers transactions generated mean tx 1 s duration 1 hour variable percentage zerocash tra c allow faster experiments instead generating block 10 minutes bitcoin create blocks average block 150 s litecoin popular altcoin run simulation di erent tra c mixes indicates percentage zerocash transactions 2f0% 25% 50% 75% 100%g simulation run 200 amazon ec2 general purpose m1 medium instances region 10 10 16 private network instance deploy 5 instances bitcoind 24 results transactions triggered blocking function simulation control node connect random node wait complete sending transaction poisson process modeling transactions generates delays calls exact points node actuals sends transactions actual transaction rate skewed experiments real transaction rate shifts away target second average 1 4 seconds figure 7 plot metrics 2f0% 25% 50% 75% 100%g average de ned data entire run simulation given e include multiple transactions blocks 25 transaction latency interval transaction s creation 21since computational power added bitcoin network faster 2 week di culty adjustment period frequency block generation actually skewed experiments run hour ignore 22these code modi cations rendered moot subsequent inclusion regtest mode bitcoin 0 9 allows precisely type behavior block generation command time experiments feature available stable release future work use feature 23we generous delay 10 ms higher time reported figure 6 leave room machines slower desktop machine 24higher densities nodes vm resulted issues initializing bitcoind instances boot 25because simulated bitcoin nodes ran shared ec2 instances subject variable external load 32 inclusion block block propagation time comes avors 1 average time new block reach node computed times nodes 2 average computed node block block veri cation time average time nodes required verify block veri cation caching e ective expect marked increase block veri cation time propagation time blocks occur average 150 s expect approximately transaction second 150 10 ms 1500 ms delay transactions non cached zerocash transactions instead worst case 80 ms conclude caching e ective results negligible e ect block propagation likely network operations dominate time needed transaction con rmed spendable roughly 190 s slower block generation rates e g bitcoin s block 10 minutes mean users wait block spending received transactions 0 20 40 60 80 100 120 140 160 180 2000%20%40%60%80%100% time secondsezerocash 0 0 5 1 1 5 2 2 5 3 3 5 4 4 50%20%40%60%80%100% time secondselast nodeevery node 0 10 20 30 40 50 60 70 800%20%40%60%80%100% time millisecondsezerocash transaction latency b block propagation time c block veri cation time figure 7 average values metrics study function percentage transactions zerocash transactions note latency unde ned 0 omitted 8 optimizations extensions outline optimizations extensions zerocash everlasting anonymity section 8 1 faster block propagation section 8 2 improved storage requirements section 8 3 8 1 everlasting anonymity transactions persist virtually forever ledger users wish ensure anonymity transactions lasts forever particular primitives eventually broken cryptanalytic breakthrough engineering progress quantum computers explain dap scheme construction described section 4 computationally private modi ed achieve everlasting anonymity old old new new recall pour operation publishes pour transaction txpour rt sn sn cm cm 121 2 pknew new new new vpub info pksig h1 h2 pour c1 c2 ci eenc new r s enc vi iii observe limiting benchmark precision clearly demonstrates mild additional delay cause catastrophic network e ects 33 hsig crh pksig hi prfpk old hsig unbounded adversary iterate x sk prfpk hsig equals hi overwhelming probability x x old old pk prfaddr old case equals learns ask old 0 identi es sender sk ask new new new unbounded decrypt ci learn v new r s try iii new prfaddr new possible x commsnew v kcommrnew 0 k new equals cm overwhelming xii ii new probability x case equals identi es recipient sk attacks prevented follows sender use given address receiving sending coins receiving coin c user u immediately generate new address pour c fresh c0 relative new address u spend coin second user data ciphertext ci communicate coin s information instead use informationally secure band channel modi cations recalling comm statistically hiding pour perfect zero knowledge proof verify pour transaction txpour statistically hiding e leaks information unbounded adversaries 26 8 2 fast block propagation mentioned section 7 3 higher block veri cation time zerocash compared e g bitcoin ect block propagation note simple modi cation mitigates concerns receiving block node validates proof work optionally transactions mint pour forward block right away node executes verifytransaction mint pour transactions accepting use transacting blocks validated node security properties unhampered propagation delays broadcast blocks reduced principle opens possibility denial service attack network spammed invalid blocks pass proof work check contain invalid mint pour transactions attack appears unrealistic given enormous design cost creating blocks passing proof work check 8 3 improved storage requirements ledger l users need maintain lists cmlist list coin commitments snlist list serial numbers spent coins section 3 1 construction cmlist required deduce authentication paths create new pour transactions pour snlist verify pour transactions verifytransaction ledger grows cmlist snlist grow size eventually impose substantial storage requirements derived smaller block chain se explain storage requirements mitigated relying smaller representations cmlist snlist su ce construction 8 3 1 supporting coin commitments execute pour algorithm spend coin c user u needs provide authentication path c s coin commitment rt merkle tree root cmlist following protocol modi cations u need cmlist compute authentication path 26as mint transactions verify statistically hiding modi cations 34 block b transactions store merkle tree path pathb rst coin commitment b root rtb merkle tree cmlist block ledger b zerocash additional block storage cost store information 2 kib note given block b successor block b0 corresponding authentication paths pathb pathb0 easily checked consistency follows let cmlistb cmlistb0 lists coin commitments corresponding ledgers ending block b b0 respectively cmlistb e coin commitments left pathb pre x cmlistb0 pathb0 computed pathb b time o jbjdtree dtree tree depth user u rst receives mints coin c coin commitment included block b u immediately computes pathb predecessor block authentication path time new block added ledger u obtains new path c new block old path c u needs act time new block added update costs o dtree transaction block overall u incurs storage requirement o dtree coin owns need store cmlist anymore 8 3 2 supporting spent serial numbers execute verifytransaction algorithm pour transaction txpour user u needs access snlist order check duplicate serial numbers note bitcoin nodes need maintain list unspent transaction outputs pruned outputs spent dap scheme contrast nodes maintain snlist list grows explain mitigate storage requirement incremental steps step 1 rst step build merkle tree snlist allow easy verify non membership proofs snlist letting leaves merkle tree intervals unspent serial numbers given root rt tree serial number sn claimed unspent authentication path path interval user check path valid rt sn lies root rt path path pour transaction txpour veri ed problem approach generating path updating rt requires knowledge snlist step 2 instead maintaining snlist single merkle tree divide snlist maintaining chronological order sublists serial numbers snlist0 snlist1 build merkle tree intervals induced sublist e apply step 1 sublist modi cation implies corresponding modi cation auxiliary information stored pour transaction allows verifytransaction check producing auxiliary information expensive user coin c maintain list authentication paths pathc 0 pathc 1 sublist path corresponding active sublist needs updated serial number added sublists authentication paths remain unchanged old sublists fact discarded user spends coin simply include paths pour transaction updating paths e cient operation computing initial paths c requires set sublists step 3 enable users avoid initial cost computing paths new coin proceed follows coin c extended contain time stamp tc corresponding c created minted poured coin s commitment modi ed depend timestamp timestamp included clear transaction creates coin user spending c produces zk snark following np statement merkle tree root created updated tc interval authentication path interval 35 serial number c interval depending number merkle trees np statement proofs e cient produce compared naive step 1 solution existing zk snark implementations 9 concurrent work danezis et al dfkp13 suggest zk snarks reduce proof size veri cation time zerocoin work di ers dfkp13 supported functionality scalability dfkp13 s protocol like zerocoin supports xed value coins best viewed decentralized mix instead de ne construct implement edged decentralized electronic currency provides anonymous payments second dfkp13 complexity zk snark generator prover veri er scale superlinearly number coins arithmetic circuit computes explicitly product coins particular number coins mixed anonymity large instead construction respective complexities polylogarithmic polylogarithmic constant number coins approach supports practically unbounded number coins rely pedersen commitments approach yields statistical e everlasting anonymity discussion section 8 1 10 conclusion decentralized currencies ensure user s privacy peers conducting legitimate nancial transactions zerocash provides privacy protection hiding user identities transaction amounts account balances public view criticized hampering accountability regulation oversight zerocash need limited enforcing basic monetary invariants currency system underlying zk snark cryptographic proof machinery exible support wide range policies example let user prove paid taxes transactions revealing transactions amounts taxes paid long policy speci ed e cient nondeterministic computation np statements principle enforced zk snarks added zerocash enable automated privacy preserving veri cation enforcement wide range compliance regulatory policies invasive check directly bypassed corrupt authorities raises research policy engineering questions policies desirable practically realizable research question new functionality realized augmenting capabilities present bitcoin s scripting language zk snarks allow fast veri cation expressive statements 36 acknowledgments thank amazon assistance kind donation ec2 resources gregory maxwell advice bitcoin codebase thank iddo ben tov scipr lab members daniel genkin lior greenblatt shaul k r gil timnat michael riabzev inspiring discussions thank sharon kessler editorial advice work supported amazon com aws education research grant broadcom foundation tel aviv university authentication initiative center science information csoi nsf science technology center grant agreement ccf 0939370 check point institute information security u s defense advanced research projects agency darpa air force research laboratory afrl contract fa8750 11 2 0211 european community s seventh framework programme fp7 2007 2013 grant agreement number 240258 israeli centers research excellence core program center 4 11 israeli ministry science technology o ce naval research contract n00014 11 1 0470 simons foundation simons award graduate students theoretical computer science skolkovo foundation agreement dated 10 26 2011 views expressed authors ect o cial policy position department defense u s government 37 overview bitcoin zerocoin provide overview bitcoin zerocoin protocols details refer reader nakamoto nak09 miers et al mggr13 respectively 1 bitcoin bitcoin nak09 decentralized currency operated collection mutually distrusting peers consists basic components peer peer network broadcasting new transactions ii semantics identifying validating new transactions iii protocol maintaining decentralized ledger known block chain stores history valid transactions far identities bitcoin represented ecdsa public keys user u generates ecdsa key pair vku sku receive payments publishes veri cation key vku hash address fact limit number addresses individual user possess transactions transaction tx represents payment list input transactions list output recipients precisely tx speci ed list fijgj inputs list fojgj outputs output oj speci es value vj denominated satoshi 109 satoshi amounts 1 bitcoin recipient speci cation rj called scriptpubkey speci cation rj given bitcoin script stack based non turing complete language similar forth speci es identity recipient vj satoshi input ij references output previous transaction txj reference speci ed tuple hj kj j hj hash txj kj index specifying output txj referenced j called scriptsig input satisfying scriptpubkey kj th output txj typically scriptpubkey speci es public key sign transaction spending output j contains signature names inputs claimed transaction prevent double spending p total number bitcoins output transaction j vj exceed total value referenced outputs di erence quantities claimed transaction fee unspent inputs transaction fee transactions typically outputs payment s recipient sender change block chain transactions broadcast bitcoin peer peer network considered valid added block chain assemble block chain miners usually necessarily network nodes collect transactions bitcoin network bundle blocks miners compete opportunity append candidate block b block chain searching string s integer speci ed sha256 sha256 bks threshold incentivize block creation miners receive protocol speci ed reward currently 25 btc adding new block receive transaction fees value speci ed transaction s creator proof work protects block tampering ensures meaningful computational resources devoted nding prevents sybil attack sybils share total computational resources e g server virtualized bitcoin assumes provided half computational work held honest nodes block chain secure recent work es13 suggested threshold larger 50% 2 zerocoin zerocoin extends bitcoin creating new transaction types mint spend mint transaction allows user exchange quantity bitcoins right mint new zerocoin zerocoin consists digital commitment cm random serial number sn later point potentially 38 di erent user issue spend transaction containing destination identity serial number sn non interactive zero knowledge proof np statement know secret cm r cm opened sn commitment randomness r ii cm previously minted point past crucially proof zero knowledge link spend transaction particular mint transaction mint transactions far proof veri es correctly serial number spent previously protocol semantics transfer corresponding bitcoins destination address fashion zerocoin functions decentralized mix zerocoin uses pedersen commitments prime eld fp e cm gsnhr random generators g h subgroup f corresponding zero knowledge proofs constructed p rst accumulating strong rsa accumulator cl01 set commitments minted zerocoins proving knowledge corresponding commitment randomness membership set technical reasons proof requires double discrete logarithm ddl fiat shamir proof size jpj security parameter practice size proofs exceeds 45 kb 128 bit security level require 450 ms verify note zerocoin computing witness accumulator requires access entire set commitments far witness incrementally updated insertion technique supports unlimited number coins contrast construction places cap n number coins implementation n 264 needs log n updates issue n new coins updates e ciently batched cf section 8 3 1 b completeness dap schemes dap scheme setup createaddress mint pour verifytransaction receive complete polynomial size ledger sampler s win incompleteness experiment negligible probability section 3 4 informally described property formally de ne de nition b 1 let setup createaddress mint pour verifytransaction receive candidate dap scheme complete poly size ledger sampler s su ciently large advincomp negl s advincomp pr incomp s 1 s s advantage incompleteness experiment s describe incompleteness experiment mentioned given candidate dap scheme ledger sampler s security parameter probabilistic experiment incomp s consists interaction s challenger c terminating binary output c beginning experiment c samples pp setup 1 sends pp s s sends c ledger coins spent parameters pour transaction precisely s old old sends 1 ledger l 2 coins c c sk 1 addrold 3 address secret keys addrold sk 2 4 12 new new values v v pk 1 addrnew pk 2 addrnewsk 2 6 public value 5 new address key pairs addrnew sk 1 addrnew 12 vpub 7 transaction string info c performs checks s s message old old old concretely c rst checks c c valid unspent coins e checks c 12 1 old old old c formed ii coin commitments cm cm appear valid transactions 2 12 old old l iii serial numbers sn sn appear valid transactions l c 12 new new old old checks v v vpub v v e values suggested s preserve balance 12 12 old old v v e maximum value exceeded checks fail c aborts 12 vmax outputs 0 39 c computes rt merkle tree root coin commitments l appearing old valid transactions 2f1 2 g pathi authentication path commitment cm old old root rt c attempts spend c c instructed s 12 new new old old new new c c c sk 1 addrold v pk 1 addrnew txpour pour pp rt c addrold sk 2 path1 path2 v addrnew pk 2 vpub info 1212 12 finally c outputs 1 following conditions hold old old new new new new txpour 6 rt sn sn cm cm vpub info cm cm coin commitments 1212 12 new new c1 c2 txpour valid e verifytransaction pp txpour l outputs 0 new 2f1 2g coin c returned receive pp addrnew sk l0 l0 pk addrnew ledger obtained appending txpour l new new remark need challenger c check turn c c spendable 12 new new follows induction c c spendable di erent sampler s0 12 new new simulates s computes outputs c c provide counterexample 12 de nition c security dap schemes dap scheme setup createaddress mint pour verifytransaction receive secure satis es ledger indistinguishability transaction non malleability balance de nition 3 2 section 3 4 informally described properties formally de ne de nitions employs experiment involving stateful dap oracle odap receives answers queries adversary proxied challenger c performs experiment speci c sanity checks rst describe odap works oracle odap initialized list public parameters pp maintains state internally odap stores l ledger ii addr set address key pairs iii coin set coins l addr coin start oracle odap accepts di erent types queries query causes di erent updates l addr coin outputs describe type query q q createaddress 1 compute addrpk addrsk createaddress pp 2 add address key pair addrpk addrsk addr 3 output address public key addrpk ledger l coin set coin remain unchanged q mint v addrpk 1 compute c txmint mint pp v addrpk 2 add coin c coin 3 add mint transaction txmint l 4 output address set addr remains unchanged new new q pour idxold idxold pk 1 addrold v addrpknew 1 addrnew addrold pk 2 info v pk 2 vpub 12 12 1 compute rt root merkle tree coin commitments l 2 2f1 2g old let cm idxold th coin commitment l ii 40 b let txi mint pour transaction l contains cmold old old c let ci rst coin coin coin commitment cmi old d let addrold sk rst key pair addr addrold s address pk addrold pk c e compute pathi authentication path cmold rt new new old old new new 3 compute c1 c2 txpour pour pp rt c1 c2 addrold sk 2 path1 path2 v1 v2 sk 1 addrold addrnew pk 2 vpub info pk 1 addrnew 4 verify verifytransaction pp txpour l outputs 1 new 5 add coin c coin 1 new 6 add coin c coin 2 7 add pour transaction txpour l 8 output operations fail output l addr coin remain unchanged q receive addrpk 1 look addrpk addrsk addr key pair found abort 2 compute c1 cn receive pp addrpk addrsk l 3 add c1 cn coin 4 output cm1 cmn corresponding coin commitments ledger l address set addr remain unchanged q insert tx 1 verify verifytransaction pp tx l outputs 1 abort 2 add mint pour transaction tx l 3 run receive addresses addrpk addr updates coin coins sent honest parties tx 4 output address set addr remains unchanged remark oracle odap provides ways cause pour transaction added l obtained address public keys addrpk 1 addrpk 2 previous createaddress queries use pour query elicit pour transaction txpour despite knowing address secret keys addrsk 1 addrsk 2 corresponding addrpk 1 addrpk 2 alternatively generated address public keys knows corresponding address secret keys invoke pour head obtain pour transaction txpour add l insert query rst case addresses belong honest users second pour transactions address belongs honest user pour transactions arise mpc computations e g matching donations ledger oracle odap de ned support queries extending de nition straightforward simplicity leave handling queries future work c 1 ledger indistinguishability ledger indistinguishability characterized experiment l ind involves polynomial size adversary attempting break given candidate dap scheme de nition c 1 let setup createaddress mint pour verifytransaction receive candidate dap scheme l ind secure poly size adversary su ciently large advl ind negl 41 advl ind 2 pr l ind 1 1 s advantage l ind experiment describe l ind experiment mentioned given candidate dap scheme adversary security parameter probabilistic experiment l ind consists interaction challenger c terminating binary output c beginning experiment c samples b 2f0 1 random samples pp setup 1 sends pp c initializes pp separate dap oracles odap odap e 01 oracles separate ledgers internal tables experiment proceeds steps step c provides ledgers lleft lright lleft lb current ledger odap lright l1 b odap sends b 1 b c pair queries q q0 type e createaddress mint pour receive insert challenger c acts di erently depending query type follows odap query type insert c forwards q odap q0 allows insert b 1 b transactions directly lleft lright query type c rst ensures q q0 publicly consistent odap forwards q odap q0 letting a0 a1 oracle answers c replies 01 ab a1 b allows elicit behavior honest users note know bit b mapping lleft lright l0 l1 words know elicits behavior l0 l1 l1 l0 end experiment sends c guess b0 2f0 1g b b0 c outputs 1 c outputs 0 public consistency mentioned sends c pairs queries q q0 type publicly consistent property de ne q q0 type createaddress receive publicly consistent special case createaddress require oracles generate address type mint minted value q equal q0 finally type pour following restrictions apply q q0 individually formed coin commitments referenced idxold old old q indices idxold correspond coins c c appear ledger 12 12 old old oracle s coin table coin ii coins c1 c2 unspent e serial numbers appear valid pour transactions corresponding oracle s ledger iii address public old old keys speci ed q match c1 c2 iv balance equation hold e new new old old v v vpub v v 12 12 furthermore q q0 jointly consistent respect public information s view public values q q0 equal ii transaction strings q q0 equal iii 2f1 2g th recipient addresses q addr e belongs new v q q0 equal vice versa q0 iv 2f1 2g th index q references l0 coin commitment contained transaction posted insert query corresponding index q0 reference l1 coin commitment old appears transaction posted insert query v q q0 old old equal vice versa q0 challenger c learns v looking corresponding coin c ii oracle s coin set coin v 2f1 2 th index q reference coin previously spent c 2 transaction non malleability transaction non malleability characterized experiment tr nm involves polynomialsize adversary attempting break given candidate dap scheme 42 de nition c 2 let setup createaddress mint pour verifytransaction receive candidate dap scheme tr nm secure poly size adversary su ciently large advtr nm negl advtr nm pr tr nm 1 s advantage tr nm experiment describe tr nm experiment mentioned given candidate dap scheme adversary security parameter probabilistic experiment tr nm consists interaction challenger c terminating binary output c beginning experiment c samples pp setup 1 sends pp c initializes dap oracle odap pp allows issue queries odap end experiment sends c pour transaction tx c outputs 1 following conditions hold letting t set pour transactions generated odap response pour queries exists tx 2t tx 6 tx ii verifytransaction pp tx l0 1 l0 portion ledger preceding tx 27 iii serial number revealed tx revealed tx c 3 balance balance characterized experiment bal involves polynomial size adversary attempting break given candidate dap scheme de nition c 3 let setup createaddress mint pour verifytransaction receive candidate dap scheme bal secure poly size adversary su ciently large advbal negl advbal pr bal 1 s advantage bal experiment describe bal experiment mentioned given candidate dap scheme adversary security parameter probabilistic experiment bal consists interaction challenger c terminating binary output c beginning experiment c samples pp setup 1 sends pp c pp initializes dap oracle odap allows issue queries odap conclusion experiment sends c set coins scoin recalling addr set addresses returned createaddress queries e addresses honest users c computes following ve quantities vunspent total value spendable coins scoin challenger c check coin c scoin spendable follows mint fresh coin c0 value 0 mint query check corresponding pour query consuming c c0 yields pour transaction txpour valid vmint total value coins minted compute vmint challenger c sums values coins minted mint queries addresses addr ii mint transactions directly placed ledger insert queries vaddr total value payments received addresses addr compute vaddr challenger c looks pour transactions placed ledger pour queries sums values transferred addresses addr 27that l0 longest ledger pre x spend coins spent tx 43 va addr total value payments sent addresses addr compute va addr challenger c rst deduces set s0 coin coins received honest parties sums values coins s0 note c compute s0 selecting coins coin tied address addr arose transactions placed ledger insert queries vbasecoin total value public outputs placed ledger compute vbasecoin challenger c looks pour transactions placed ledger insert sums corresponding vpub values end experiment c outputs 1 vunspent vbasecoin va addr vmint vaddr c outputs 0 remark methods spend public output money owns directly inserting transactions ledger ii asking honest parties create transactions rst method accounted computation vbasecoin second method accounted computation va addr rst pay honest party d proof theorem 4 1 prove theorem 4 1 omit formal proof completeness claim verify dap scheme s completeness follows straightforward way completeness construction s building blocks argue security separate proofs respectively showing construction satis es ledger indistinguishability ii transaction non malleability iii balance d 1 proof ledger indistinguishability describe simulation asim adversary interacts challenger c l ind experiment asim di ers l ind experiment critical way answers sent computed independently bit b s advantage asim 0 remainder proof devoted showing advl ind e s advantage l ind experiment negligibly di erent s advantage asim simulation simulation asim works follows sampling b 2f0 1 random c samples pp setup 1 following modi cation zk snark keys generated pkpour vkpour trap sim 1 cpour obtain zero knowledge trapdoor trap l ind experiment c sends pp initializes separate dap oracles odap o1 dap 0 l ind asim proceeds steps step c provides ledgers lleft lright lleft lb current ledger odap lright l1 b odap b 1 b sends c message q q0 consist publicly consistent queries type challenger c acts di erently depending query type follows answering createaddress queries case q q0 createaddress answer q c behaves l ind following modi cation obtaining addrpk addrsk createaddress pp c replaces apk addrpk random string appropriate length c stores addrsk table returns addrpk c q0 44 answering mint queries case q mint v addrpk q0 mint v addr0 pk answer q c behaves l ind following modi cation mint algorithm computes commitment k commr k random string t appropriate length instead commr apkk apk value speci ed addrpk c q0 old old answering pour queries case q q0 form pour cm cm addrold 12 pk 1 new new new addroldpk 2 info v v pk 1 addrnew addrnew 12 pk 2 vpub answer q c modi es way values computed 1 compute rti accumulating valid coin commitments li 2 set vpub info corresponding input values 3 j 2f1 2g sample uniformly random snold j b addrnew pk j address generated previous query createaddress sample new coin commitment cm random input ii run kenc pp pk skenc j enc enc compute cnew eenc pk r random r suitable length j enc new cnew c calculate cm pour algorithm 28 ii 4 set h1 h2 random strings appropriate length 5 compute remaining values pour algorithm old old new new 6 pour proof computed pour sim trap x x rt sn sn cm cm vpub h1 h2 121 2 c q0 answering receive queries case q receive addrpk q0 receive addr0 pk answer query proceeds l ind experiment answering insert queries case q insert tx q insert tx0 answer query proceeds l ind experiment cases response computed independently bit b outputs guess b0 case pr b b0 1 2 e s advantage asim 0 proof simulation indistinguishable real experiment describe sequence hybrid experiments areal a1 a2 a3 asim challenger c conducts modi cation l ind experiment de ne areal original l ind experiment asim simulation described slight abuse notation given experiment de ne adva absolute value di erence l ind advantage ii l ind advantage areal let qca total number createaddress queries issued qp total number pour queries issued qm total number mint queries issued finally de ne advenc s advantage enc s ind cca ik cca experiments advprf s advantage distinguishing pseudorandom function prf random advcomm s advantage hiding property comm describe hybrid experiments new 28note restrictions experiment value vi identical qleft qright 45 experiment a1 experiment a1 modi es areal simulating zk snarks precisely modify areal c simulates zk snark proof follows beginning experiment instead invoking keygen 1 cpour c invokes sim 1 cpour obtains pkpour vkpour trap subsequent invocation pour algorithm c computes pour sim trap x witnesses instead prove zk snark system perfect zero knowledge distribution simulated pour identical proofs computed areal adva1 0 experiment a2 experiment a2 modi es a1 replacing ciphertexts pour transaction encryptions random strings precisely modify a1 time issues pour query output addresses addrnew pk 2 set addresses pk 1 addrnew cnew previously generated createaddress query ciphertexts cnew generated 12 sknew pknew follows pknew enc kenc pp ii j 2f1 2g cnew enc j r r enc enc j eenc message sampled uniformly plaintext space encryption scheme lemma d 1 jadva2 adva1 j 4 qp advenc experiment a3 experiment a3 modi es a2 replacing prf generated values random strings precisely modify a2 time issues createaddress query value apk returned addrpk substituted random string length old old time issues pour query serial numbers sn sn2 txpour substituted 1 random string length hinfo random string length lemma d 2 jadva3 adva2 j qca advprf experiment asim experiment asim described comparison explain di ers a3 coin commitments replaced commitments random inputs precisely modify a3 time issues mint query coin commitment cm txmint substituted commitment random input time issues pour query j 2f1 2g output address addrnew pk j new set addresses previously generated createaddress query cm substituted j commitment random input lemma d 3 jadvasim adva3 j qm 4 qp advcomm argued responses provided asim independent bit b advasim 0 summing s advantages hybrid experiments bound s advantage areal advl ind 4 qp advenc qca advprf qm 4 qp advcomm negligible concludes proof ledger indistinguishability sketch proofs lemmas lemma d 1 lemma d 2 lemma d 3 lemma d 1 let advenc maximum s advantage ind cca experiment encryption scheme enc s advantage ik cca experiment encryption scheme enc qp pour queries jadva2 adva1 j 4 qp advenc 46 proof sketch de ne adva2 adva1 rst construct solver advantage ik cca ind cca experiments use hybrid h intermediate 2 qp a1 a2 concretely h modi es a1 ciphertext corresponding public key appears set generated createaddress query replaced encryption plaintext new random public key generated kenc algorithm comparison a2 modi es h plaintext replaced random plaintext drawn plaintext space argue s advantage distinguishing h a1 2 qp advenc distinguishing a2 h overall deduce jadva2 adva1 j 4 qp advenc discuss h a1 j 2f1 qcag makes j th query form createaddress query ik cca challenger obtain public keys pk enc 0 pkenc 1 return pk pkenc 0 response time issues pour query results enc th ciphertext ci encrypted pk query ik cca challenger corresponding enc plaintext m receive c eenc pkenc b m b bit chosen ik cca challenger substitute ci c write resulting txpour ledger outputs b0 return guess guess ik cca experiment note b 0 s view interaction distributed identically a1 b 1 s view represents intermediate hybrid key substituted standard hybrid argument 2 qp ciphertexts note random coins experiment solver succeed ik cca experiment advantage assume maximum adversarial 2 qp advantage advenc ik cca experiment encryption scheme advh adva2 2 qp advenc discuss a2 h argument similar time replacing key encrypt replace plaintext random message drawn plaintext space nal distribution a2 omit formal description resulting ind cca solver essentially follows pattern simply note adva2 advh 2 qp advenc lemma d 2 let advprf s advantage distinguishing pseudorandom function prf random function qca createaddress queries jadva3 adva2 j qca advprf proof sketch rst describe hybrid h intermediate a2 a3 values computed rst oracle generated key ask replaced random strings s advantage distinguishing h a2 advprf finally extend argument qca oracle generated keys corresponding happens a3 describe h receiving s rst createaddress query replace public address addrpk apk pk addrpk pk t random string appropriate length enc enc subsequent pour query 2f1 2g addrold addrpk pk 1 output txpour replace snold random string appropriate length 2 output txpour replace h1 h2 random string appropriate length 3 simulate zk snark proof pour new transaction note modi cations ect computation zk snark proof pour pour simulated help trapdoor argue s advantage distinguishing h a2 advprf let ask random secret seed prf generated oracle answering rst createaddress query a2 areal apk prfaddr 0 ask 2f1 2g sni prfsn random previously ask 47 2f1 2g hi prfpk ikhsig overwhelming probability hsig unique ask prfaddr prfsn prfpk constructed prfask speci ed section 4 1 ask ask ask note overwhelming probability calls prfask input identical inputs passed prfaddr prfsn prfpk produce di erent underlying calls prfask ask ask ask second construction exactly prfaddr calls prfsn ask ask de nition unique finally overwhelming probability calls prfpk di erent ask transactions reference distinct digest hsig given transaction calls begin distinct pre x let o oracle implements prfask random function distinguishes h a2 probability construct distinguisher cases o case use o generate values computed prfaddr prfsn prfpk ask ask ask clearly o implements prfask distribution experiment identical a2 instead o implements random function distribution experiment identical h s advantage advprf finally standard hybrid argument extend qca oracle generated addresses s di erential distinguishing advantage qca advprf nal hybrid equal a3 deduce jadva3 adva2 j qca advprf lemma d 3 let advcomm s advantage hiding property comm qm mint queries qp pour queries jadvasim adva3 j qm 4 qp advcomm proof sketch provide short sketch structure argument similar prove lemma d 2 rst mint pour query replace internal commitment k commr apkk random string appropriate length random unique s advantage distinguishing modi ed experiment a2 advcomm similarly modify qm mint queries qp pour queries replacing resulting qm 2 qp internal commitments random strings bound s advantage qm 2 qp advcomm similar vein replace coin commitment rst pour commitment random value s advantage distinguishing modi ed experiment advcomm similarly modify qp pour queries replacing resulting 2 qp coin commitments random strings obtain experiment asim deduce jadvasim adva3 j qm 4 qp advcomm d 2 proof transaction non malleability letting t set pour transactions generated odap response pour queries recall wins tr nm experiment outputs tx exists tx0 2t tx 6 tx0 ii verifytransaction pp tx l0 1 l0 portion ledger preceding tx0 iii serial number revealed tx revealed tx0 pour transaction tx old old new new form rt sn sn cm cm vpub info pksig h1 h2 pour c1 c2 set 121 2 hsig crh pksig let pk0 crh pk0 sig corresponding public key tx0 set h0 sig sig de ne advtr nm let qca fask 1 ask qca set internal address keys created c response s createaddress queries let qp pksig 1 pksig qp set signature public keys created c response s pour queries decompose event wins following disjoint events eventsig wins pk00 pk00 sig 2qp pksig sig 48 eventcol wins event occur pk00 sig 2qp hsig crh pk00 sig eventmac wins events occur hi prfpk ikhsig 2f1 2g 2qca eventkey wins events occur hi 6 prfpk ikhsig 2f1 2g 2qca clearly pr eventsig pr eventcol pr eventkey pr eventmac negligible su ces argue probabilities negligible bounding probability eventsig de ne 1 pr eventsig let s signature tx 00 signature rst pour transaction tx00 2t contains pk00 sig eventsig occurs pksig pksig 00 signatures respect public key 00 tx valid vsig pksig m 1 m tx let m consist elements tx00 00 observe tx 6 tx00 m 6 00 00 use fact forges signature non negligible probability m argue conditioned eventsig tx 6 tx00 overwhelming probability way contradiction wins de nition tx0 2t tx 6 tx0 tx tx0 share serial number tx 6 tx0 ii tx tx00 tx00 tx0 share serial number probability tx0 tx00 share serial number bounded probability p t contains transactions share serial number serial number computed prfsn random p negligible ask conclude tx 6 tx00 negligible probability describe algorithm b uses subroutine wins suf 1cma game sig probability 1 qp receiving veri cation key pk00 sig suf 1cma challenger algorithm b performs following steps 1 b selects random index j f1 qpg 2 b conducts tr nm experiment issues j th pour query b executes pour usual modi es resulting pour transaction tx00 follows substitutes pk00 sig signature public key tx00 ii queries suf 1cma challenger 00 obtain 00 appropriate message m iii substitutes 00 signature tx00 3 outputs tx b looks tx obtain pksig m 4 pksig 6 pksig 00 b aborts b outputs m forgery sig note tx00 distribution untampered pour transaction transactions returned distributed tr nm experiment index j selected random b succeeds experiment probability 1 qp sig suf 1cma 1 negligible bounding probability eventcol de ne 2 pr eventcol eventcol occurs receives transaction tx0 containing public key pk00 sig subsequently outputs transaction tx containing public key pksig pksig 6 pksig 00 ii crh pksig crh pk0 sig particular nds collisions crh probability 2 crh collision resistant 2 negligible bounding probability eventmac de ne 3 pr eventmac rst de ne experiment a1 modi es tr nm experiment follows c samples pp setup 1 sub pkpour vkpour keygen 1 cpour replaced pkpour vkpour trap sim 1 cpour obtain zero knowledge trapdoor trap time issues pour query c replaces zk snark proof resulting pour transaction simulated proof obtained running sim trap x appropriate input x zk snark perfect zero knowledge pr eventmac 3 a1 experiment 49 assume way contradiction 3 non negligible construct attacker b uses subroutine distinguishes prf random function rand non negligible probability algorithm b access o prf o rand interfaces c experiment a1 follows 1 b selects random index j f1 qcag identi es ask j 2qca 2 b uses oracle o instead prfask j e anytime value needs computed depending prfask j z z o z instead instance public address key apk j value 3 finally outputs tx o previously evaluated expression prfpk ikhsig o b aborts ask j outputs 1 b b evaluates expression prfpk ikhsig o result equals ask j hi b outputs 1 outputs 0 conducting strategy require knowledge ask j having simulation trapdoor b need witnesses generate valid zk snark proofs bprf 1 1 brand 1 1 argue pr pr non negligible case 1 o rand observe hi 2 pr brand 1 1 jbrand 1 abort output length prf h h h brand 1 1 pr 1 pr brand 1 aborts 2 pr brand 1 aborts case 2 o prf case distribution simulation identical a1 b set ask j equal seed o recall eventmac holds hi prfpk ikhsig 2qca s view experiment independent j probability ask j 1 qca probability hi prfpk ikhsig 3 qca ask j h pr bprf 1 1 bprf 1 abort 3 qca h h h bprf 1 1 pr 1 pr bprf 1 aborts 3 qca pr bprf 1 aborts clearly 2 negligible 3 non negligible j 3 qcaj bprf 1 1 brand 1 1 pr pr non negligible su ces pr brand 1 aborts pr bprf 1 aborts negligible recall b aborts previously evaluated expression prfpk ikhsig o prior receiving s output note b s calls o occur ask j evaluates functions prfaddr prfsn prfpk construction functions possible evaluate expression prfpk ikhsig calls ask j prfaddr prfsn b aborts previously queried prfpk expression prfpk ikhsig easy happen conditions eventmac ask j query imply condition eventsig eventcol excluded eventmac probability condition occurring 0 50 bounding probability eventkey de ne 4 pr eventkey let e zk snark extractor assume way contradiction 4 non negligible construct algorithm b nds collisions prfsn non negligible probability contradicting fact prfsn collision resistant algorithm b works follows 1 run simulating interaction challenger c obtain tx 2 run e pkpour vkpour obtain witness zk snark proof pour tx old old new new 3 valid witness instance x rt sn sn cm cm vpub hsig h1 h2 121 2 abort output 0 old old new new 4 parse path1 path2 c1 c2 sk 1 addroldsk 2 c12 addrold c old old old old old 5 2f1 2g parse c addrold old r s cm pk v iiii sk skold old 6 2f1 2g parse addroldsk enc note valid witness snold prfsn old old 2f1 2g ai sk 7 2f1 2g old look pour transaction tx 2t contains sn b tx found let ask seed input compute snold tx old old old sn prfsn 6 ask output old collision prfsn iask sk sk ask note eventkey holds proof pour valid negligible probability witness valid old old serial number sn sn appears previous pour transaction t 12 pk pk valid holds h1 prf old hsig h2 prf old hsig aa sk 1 sk 2 old old ask contradicts conditions event eventkey sk 1 sk 2 overall conclude b nds collision prfsn probability 4 negl d 3 proof balance de ne advbal recall addr set goal negligible addresses returned s createaddress queries augmenting ledger witnesses modify bal experiment way ect s view challenger c computes pour transaction txpour ledger l old old new new maintained oracle odap witness path1 path2 c1 c2 sk 1 addroldsk 2 c12 addrold c old old new new zk snark instance x rt sn sn cm cm vpub hsig h1 h2 corresponding 121 2 29 txpour way c obtains augmented ledger l ai witness zk snark instance xi th pour transaction l note parse l list matched pairs txpour txpour pour transaction l corresponding witness discussion relative modi cation bal experiment balanced ledgers augmented ledger l balanced following holds txpour l contains openings e decommitments distinct coin comol d old old mitments cm cm cm output coin commitment pour mint 12 transaction precedes txpour l 0 ii notwo txpour tx0 l contain openings coin commitment pour 29 concretely pour transactions l inserted c simply retains witness internally odap generate transaction valid pour transactions inserted c uses zk snark multi instance knowledge extractor corresponding section 2 1 knowledge extraction fails c aborts outputs 1 happens negligible probability 51 old old new new old old iii txpour l contains openings cm cm cm cm values v v 1212 12 new new old old new new v v respectively condition v v v v 12 1212 vpub iv txpour l 2f1 2g following conditions hold old cmi output mint transaction txmint l public value v old txmint equal vi old b cm output pour transaction tx00 contains pour l witness old old opening cm value v0 equal v ii v txpour l txpour inserted holds 2f1 2g old cm output earlier mint pour transaction tx0 public address th output tx0 contained addr intuitively conditions ensure l spend money previously minted paid address s control concretely prove induction l balanced vunspent vbasecoin va addr vmint vaddr light su ces argue augmented ledger induced modi ed bal experiment balanced negligible probability suppose way contradiction case induces non negligible probability augmented ledger l balanced distinguish ve cases corresponding conditions hold non negligible probability case reach contradiction concluding proof violates condition suppose pr wins violates condition non negligible construction odap txpour l txpour inserted satis es condition violation originate pair txpour l txpour old old old inserted cm cm ii 2f1 2 cm 12 corresponding output coin commitment pour mint transaction precedes txpour l observe validity txpour implies old old old serial numbers sn sn distinct recalling sn equals 12 old old old old old prfsn old implies 6 ai sk 11 sk 22 sk witness contains valid authentication paths path1 path2 merkle tree constructed coin commitments transactions preceding txpour l ii reach contradiction old old old old cm cm fact sn 6 sn implies witness contains 12 12 old old distinct openings cm rst opening contains ask 1 old second opening 11 old contains old violates binding property commitment scheme comm sk 22 old ii 2f1 2 cm previously appear l pathi invalid authentication path yields collision function crh violates collision resistance crh violates condition ii suppose pr wins violates condition ii non negligible observe condition ii violated l contains pour transactions txpour tx0 spending pour 0 coin commitment cm revealing serial numbers sn sn txpour tx0 pour valid case sn 6 sn0 argued transactions spend cm produce di erent serial numbers corresponding witnesses a0 contain di erent openings cm contradicts binding property commitment scheme comm violates condition iii suppose pr wins violates condition iii non negligible case contradiction immediate condition iii violated equation 52 old old new new v v v v vpub hold construction statement pour 121 2 soundness zk snark violated violates condition iv suppose pr wins violates condition iv non negligible observe condition iv violated l contains old pour transaction txpour coin commitment cmold opened value v old old mint pour transaction tx0 opens cm value v0 di erent v contradicts binding property commitment scheme comm violates condition v suppose pr wins violates condition v non negligible observe condition v violated l contains inserted pour transaction txpour spends output previous transaction tx0 public address addrpk apk pk lies enc prfaddr addr witness associated tx0 contains ask apk 0 omit ask argument verify case construct new adversary b uses distinguish non negligible probability prf random function 53 references bb04 dan boneh xavier boyen secure identity based encryption random oracles proceedings 24th annual international cryptology conference crypto 04 pages 443 459 2004 bbdp01 mihir bellare alexandra boldyreva anand desai david pointcheval key privacy publickey encryption proceedings 7th international conference theory application cryptology information security asiacrypt 01 pages 566 582 2001 bbsu12 simon barber xavier boyen elaine shi ersin uzun bitter better bitcoin better currency proceedings 16th international conference financial cryptography data security fc 12 pages 399 414 2012 bcct12 nir bitansky ran canetti alessandro chiesa eran tromer extractable collision resistance succinct non interactive arguments knowledge proceedings 3rd innovations theoretical computer science conference itcs 12 pages 326 349 2012 bcct13 nir bitansky ran canetti alessandro chiesa eran tromer recursive composition bootstrapping snarks proof carrying data proceedings 45th acm symposium theory computing stoc 13 pages 111 120 2013 bcg 13 eli ben sasson alessandro chiesa daniel genkin eran tromer madars virza snarks c verifying program executions succinctly zero knowledge proceedings 33rd annual international cryptology conference crypto 13 pages 90 108 2013 bcgt13a eli ben sasson alessandro chiesa daniel genkin eran tromer fast reductions rams delegatable succinct constraint satisfaction problems proceedings 4th innovations theoretical computer science conference itcs 13 pages 401 414 2013 bcgt13b eli ben sasson alessandro chiesa daniel genkin eran tromer concrete e ciency probabilistically checkable proofs proceedings 45th acm symposium theory computing stoc 13 pages 585 594 2013 bci 13 nir bitansky alessandro chiesa yuval ishai rafail ostrovsky omer paneth succinct noninteractive arguments linear interactive proofs proceedings 10th theory cryptography conference tcc 13 pages 315 333 2013 bctv14 eli ben sasson alessandro chiesa eran tromer madars virza succinct non interactive zero knowledge von neumann architecture proceedings 23rd usenix security symposium security 14 pages 2014 available http eprint iacr org 2013 879 bel06 mihir bellare new proofs nmac hmac security collision resistance proceedings 26th annual international conference advances cryptology crypto 06 pages 602 619 2006 ben13 eli ben sasson universal ordable computational integrity 2013 bitcoin 2013 future payments url http www youtube com watch v yrcpreupkcu feature youtu t 26m6s bfls91 l aszl o babai lance fortnow leonid levin mario szegedy checking computations polylogarithmic time proceedings 23rd annual acm symposium theory computing stoc 91 pages 21 32 1991 bgh 05 eli ben sasson oded goldreich prahladh harsha madhu sudan salil vadhan short pcps veri able polylogarithmic time proceedings 20th annual ieee conference computational complexity ccc 05 pages 120 134 2005 cer00 certicom research sec 1 elliptic curve cryptography 2000 url http www secg org collateral sec1 final pdf cha82 david chaum blind signatures untraceable payments proceedings 2nd annual international cryptology conference crypto 82 pages 199 203 1982 chl05 jan camenisch susan hohenberger anna lysyanskaya compact e cash proceedings 24th annual international conference theory applications cryptographic techniques eurocrypt 05 pages 302 321 2005 cl01 jan camenisch anna lysyanskaya e cient system non transferable anonymous credentials optional anonymity revocation proceedings 20th annual international conference theory application cryptographic techniques eurocrypt 01 pages 93 118 2001 ddm03 george danezis roger dingledine nick mathewson mixminion design type iii anonymous remailer protocol proceedings 2003 ieee symposium security privacy sp 03 pages 2 15 2003 54 dfkp13 george danezis cedric fournet markulf kohlweiss bryan parno pinocchio coin building zerocoin succinct pairing based proof system proceedings 2013 workshop language support privacy enhancing technologies petshop 13 2013 url http www0 cs ucl ac uk staff g danezis papers danezisfournetkohlweissparno13 pdf dms04 roger dingledine nick mathewson paul syverson tor second generation onion router proceedings 13th usenix security symposium security 04 pages 21 21 2004 dw13 christian decker roger wattenhofer information propagation bitcoin network proceedings 13th ieee international conference peer peer computing p2p 13 pages 1 10 2013 es13 ittay eyal emin g un sirer majority bitcoin mining vulnerable 2013 gen04 rosario gennaro multi trapdoor commitments applications proofs knowledge secure concurrent man middle attacks proceedings 24th annual international cryptology conference crypto 04 pages 220 236 2004 ggpr13 rosario gennaro craig gentry bryan parno mariana raykova quadratic span programs succinct nizks pcps proceedings 32nd annual international conference theory application cryptographic techniques eurocrypt 13 pages 626 645 2013 gmr89 shafi goldwasser silvio micali charles racko knowledge complexity interactive proof systems siam journal computing 18 1 186 208 1989 preliminary version appeared stoc 85 gos06a jens groth rafail ostrovsky amit sahai non interactive zaps new techniques nizk proceedings 26th annual international conference advances cryptology crypto 06 pages 97 111 2006 gos06b jens groth rafail ostrovsky amit sahai perfect non interactive zero knowledge np proceedings 25th annual international conference advances cryptology eurocrypt 06 pages 339 358 2006 gro10 jens groth short pairing based non interactive zero knowledge arguments proceedings 16th international conference theory application cryptology information security asiacrypt 10 pages 321 340 2010 gw11 craig gentry daniel wichs separating succinct non interactive arguments falsi able assumptions proceedings 43rd annual acm symposium theory computing stoc 11 pages 99 108 2011 kl07 jonathan katz yehuda lindell introduction modern cryptography chapman hall crc 2007 lee13 timothy b lee bitcoin needs scale factor 1000 compete visa s washington post http www washingtonpost com november 2013 lip12 helger lipmaa progression free sets sublinear pairing based non interactive zero knowledge arguments proceedings 9th theory cryptography conference theory cryptography tcc 12 pages 169 189 2012 lip13 helger lipmaa succinct non interactive zero knowledge arguments span programs linear error correcting codes proceedings 19th international conference theory application cryptology information security asiacrypt 13 pages 41 60 2013 max13 greg maxwell coinjoin bitcoin privacy real world august 2013 bitcoin forum url https bitcointalk org index php topic 279249 0 mggr13 ian miers christina garman matthew green aviel d rubin zerocoin anonymous distributed e cash bitcoin proceedings 2013 ieee symposium security privacy sp 13 pages 397 411 2013 mic00 silvio micali computationally sound proofs siam journal computing 30 4 1253 1298 2000 preliminary version appeared focs 94 mpj 13 sarah meiklejohn marjori pomarole grant jordan kirill levchenko damon mccoy geo rey m voelker stefan savage stful bitcoins characterizing payments men names proceedings 2013 conference internet measurement conference imc 13 pages 127 140 2013 nak09 satoshi nakamoto bitcoin peer peer electronic cash system 2009 url http www bitcoin org bitcoin pdf nat12 national institute standards technology fips pub 180 4 secure hash standard http csrc nist gov publications pubsfips html 2012 55 pghr13 bryan parno craig gentry jon howell mariana raykova pinocchio nearly practical veri able computation proceedings 34th ieee symposium security privacy oakland 13 pages 238 252 2013 pol13 polarssl polarssl http polarssl org oct 2013 rm11 fergal reid harrigan martin analysis anonymity bitcoin system proceedings 3rd ieee international conference privacy security risk trust social computing socialcom passat 11 pages 1318 1326 2011 rs12 dorit ron adi shamir quantitative analysis bitcoin transaction graph cryptology eprint archive report 2012 584 2012 st99 tomas sander amnon ta shma auditable anonymous electronic cash proceedings 19th annual international cryptology conference advances cryptology crypto 99 pages 555 572 1999 val08 paul valiant incrementally veri able computation proofs knowledge imply time space e ciency proceedings 5th theory cryptography conference tcc 08 pages 1 18 2008 wui14 pieter wuille proposed bip dealing malleability available https gist github com sipa 8907691 2014 56