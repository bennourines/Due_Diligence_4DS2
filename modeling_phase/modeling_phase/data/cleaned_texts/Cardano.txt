ouroboros provably secure proof stake blockchain protocol aggelos kiayias alexander russell bernardo david roman oliynykov july 20 2019 abstract present ouroboros blockchain protocol based proof stake rigorous security guarantees establish security properties protocol comparable achieved bitcoin blockchain protocol protocol provides proof stake blockchain discipline offers qualitative efficiency advantages blockchains based proof physical resources e g proof work present novel reward mechanism incentivizing proof stake protocols prove given mechanism honest behavior approximate nash equilibrium neutralizing attacks selfish mining present initial evidence practicality protocol real world settings providing experimental results transaction confirmation processing 1 introduction primary consideration operation blockchain protocols based proof work pow bitcoin 34 energy required execution time writing generating single block bitcoin blockchain requires number hashing operations exceeding 260 results striking energy demands early calculations indicated energy requirements protocol comparable small country 36 state affairs motivated investigation alternative blockchain protocols obviate need proof work substituting energy efficient mechanism provide similar guarantees fundamentally proof work mechanism bitcoin facilitates type robust randomized leader election process elects miners issue block furthermore provided miners follow protocol selection performed randomized fashion proportionally computational power miner deviations protocol distort proportionality exemplified selfish mining strategies 25 43 natural alternative mechanism relies notion proof stake pos miners investing computational resources order participate leader election process instead run process randomly selects proportionally stake possesses according current blockchain ledger university edinburgh iohk akiayias inf ed ac uk work partly performed national kapodistrian university athens supported erc project codamoda 259152 work partly supported h2020 project 653497 panoramix university connecticut iohk acr cse uconn edu aarhus university iohk bernardo bmdavid com work partly supported european research council starting grant 279447 iohk roman oliynykov iohk io 1 effect yields self referential blockchain discipline maintaining blockchain relies stakeholders assigns work rewards based stake possesses reported ledger aside protocol artificial computational demands stakeholders sense sounds ideal realizing proof stake protocol appears involve number definitional technical analytic challenges previous work concept pos discussed extensively bitcoin forum 1 proof stake based blockchain design formally studied bentov et al conjunction pow 7 sole mechanism blockchain protocol 6 bentov et al showed protocols secure classes attacks provide formal model analyzing pos based protocols security proofs relying precise definitions heuristic proof stake based blockchain protocols proposed implemented number cryptocurrencies 2 based heuristic security arguments cryptocurrencies frequently found deficient point view security 6 discussion attacks interesting contrast pos based blockchain protocol classical consensus blockchain relies fixed set authorities e g 21 distinguishes pos based blockchain assume static authorities stake changes time trust assumption evolves system fact complexity system maintenance sublinear total number users stakeholders alternative pow concept proof space 2 24 specifically investigated context blockchain protocols 37 proof space setting prover wishes demonstrate utilization space storage memory case pow utilizes physical resource demand energy related concept proof space time post 32 cases protocol relies expensive physical resource storage computational power pos design challenge fundamental problem pos based blockchain protocols simulate leader election process order achieve fair randomized election stakeholders entropy introduced system mechanisms introduce entropy prone manipulation adversary instance adversary controlling set stakeholders attempt simulate protocol execution trying different sequences stakeholder participants finds protocol continuation favors adversarial stakeholders leads called grinding vulnerability adversarial parties use computational resources bias leader election results present ouroboros provably secure proof stake system best knowledge blockchain protocol kind rigorous security analysis detail results follows provide model formalizes problem realizing pos based blockchain protocol model introduce spirit 28 focusing persistence liveness formal properties robust transaction ledger persistence states node system proclaims certain transaction stable remaining nodes queried responding honestly 1see proof stake instead proof work bitcoin forum thread posts user quantummechanic https bitcointalk org index php topic 27787 0 2a non exhaustive list includes nxt neucoin blackcoin tendermint bitshares 2 report stable stability understood predicate parameterized security parameter k affect certainty property holds e g k blocks deep liveness ensures honestly generated transaction available sufficient time network nodes u time steps stable conjunction liveness persistence provides robust transaction ledger sense honestly generated transactions adopted immutable model suitably adapted reflect pos based dynamics second describe novel blockchain protocol based pos protocol assumes parties freely create accounts receive payments stake shifts time utilize simple secure multiparty implementation coin flipping protocol produce randomness leader election process distinguishes approach prevents called grinding attacks previous solutions defined values deterministically based current state blockchain collective coin flipping way introduce entropy 6 unique approach fact system ignores round round stake modifications instead snapshot current set stakeholders taken regular intervals called epochs interval secure multiparty computation takes place utilizing blockchain broadcast channel specifically epoch set randomly selected stakeholders form committee responsible executing coin flipping protocol outcome protocol determines set elected stakeholders execute protocol subsequent epoch outcomes leader elections epoch provide set formal arguments establishing adversary break persistence liveness protocol secure number plausible assumptions 1 network synchronous sense upper bound determined honest stakeholder able communicate stakeholder 2 number stakeholders drawn honest majority available needed participate epoch 3 stakeholders remain offline long periods time 4 adaptivity corruptions subject small delay measured rounds linear security parameter alternatively players access sender anonymous broadcast channel core security arguments probabilistic argument combinatorial notion forkable strings formulate prove investigate experimentally analysis distinguish covert attacks special class general forking attacks covertness interpreted spirit covert adversaries secure multiparty computation protocols cf 3 adversary wishes break protocol prefers caught covertly forkable strings subclass forkable strings smaller density permits provide distinct security arguments achieve different trade offs terms efficiency security guarantees forkable string technique natural general tool applications analysis specific pos protocol fourth turn attention incentive structure protocol present novel reward mechanism incentivizing participants system prove approximate nash equilibrium way attacks like block withholding selfish mining 25 43 mitigated design core idea reward mechanism provide positive payoff protocol actions stifled coalition parties diverges protocol way possible plausible assumptions certain protocol execution costs small following protocol faithfully equilibrium players rational fifth introduce stake delegation mechanism seamlessly added blockchain protocol delegation particularly useful context like allow protocol scale setting set stakeholders highly fragmented cases 3 delegation mechanism enable stakeholders delegate voting rights e right participating committees running leader selection protocol epoch liquid democracy k delegative democracy 27 stakeholders ability revoke delegative appointment wish independently given model protocol description explore attacks considered practice addressed framework specifically discuss double spending attacks transaction denial attacks 51% attacks stake desynchronization attacks finally present evidence practical efficiency design consider double spending attacks illustrative purposes perform comparison nakamoto s analysis bitcoin transaction confirmation time assurance 99 9% covert adversaries transaction confirmation time 10 16 times faster bitcoin depending adversarial hashing power general adversaries confirmation time 5 10 times faster concrete analysis double spending attacks relies combinatorial analysis forkable covertly forkable strings applies broader class adversarial behavior nakamoto s simplified analysis 3 survey prototype implementation report benchmark experiments run amazon cloud showcase power proof stake blockchain protocol terms performance related follow work parallel development ouroboros number protocols developed targeting positions design space distributed ledgers based pos sleepy consensus 8 considers fixed stakeholder distribution e stake evolve time targets mixed corruption setting adversary allowed adaptive perform fail stop recover corruptions addition byzantine faults straightforward extend analysis mixed corruption setting cf remark 2 resulting security argued corruptions delay setting fully adaptive follow work shown analysis extended incorporate adaptive corruptions 22 refined model availability 4 covers fail stop recover sleepy corruptions snow white 9 addresses evolving stakeholder distribution uses corruption delay mechanism similar arguing security contrary approach leader election 9 enables degree grinding e making feasible significantly bias adversarially chosen high probability event affords efficient randomness generation process follow work 22 shown possible obtain adaptive security similarly efficient randomness generation extending forkable strings analysis introduced present paper algorand 31 provides distributed ledger following byzantine agreement block approach withstand adaptive corruptions given agreement needs reached block protocols produce blocks rate substantially slower pos blockchain slow matches expected length execution byzantine agreement protocol hand algorand parameterised free forks blocks settle immediately conclusion consensus sub protocol particular settlement happen expected constant number rounds asymptotically superior blockchain protocol worth noting blockchain protocols somewhat mitigate inherent slow letting ledger users choose different level settlement security depending value transactions risk overlay protocol lightning 41 benefit comes expense imposing specific participation bounds 3nakamoto s simplifications pointed 28 analysis considers setting block withholding attacker acts interaction opposed general attacker instance tries strategically split honest parties chains course double spending attack 4 sub protocol instance unnecessary case blockchain protocol follow work ouroboros dynamic availability 4 discussion topic algorand approach require agreed concept time participants merely relies assumption time passes roughly speed protocol presented requires access global time follow work 5 shown possible ouroboros protocol enhanced time synchronization sub protocol retaining core security argument present fruitchain 40 provides reward mechanism approximate nash equilibrium proof pow based blockchain use similar reward mechanism blockchain level underlying mechanics different operate pos setting core idea provide pos analogue endorsing inputs fair proportion logic pow based byzantine agreement protocol honest majority 28 finally present paper prove error bound commonprefix property persistence transactions error rate drops sub exponentially security parameter experimentally demonstrate exponential drop follow work 42 shows gap closed proving exponentially decreasing error bound paper overview lay basic model sec 2 simplify analysis protocol present stages outlined sec 3 short sec 4 describe analyze protocol static setting transition dynamic setting sec 5 present protocol enhancement anonymous channels sec 7 incentive mechanism equilibrium argument presented sec 8 following discuss delegation sec 9 sec 10 resilience protocol particular attacks interest finally sec 11 discuss transaction confirmation times general performance results obtained prototype implementation running amazon cloud 2 model time slots synchrony consider setting time divided discrete units called slots ledger described detail associates time slot ledger block players equipped roughly synchronized clocks indicate current slot permit carry distributed protocol intending collectively assign block current slot general slot indexed integer r 1 2 assume real time window corresponds slot following properties current slot determined publicly known monotonically increasing function current time player access current time discrepancies parties local time insignificant comparison length time represented slot length time window corresponds slot sufficient guarantee message transmitted honest party beginning time window received honest party end time window accounting small inconsistencies parties local clocks particular network delays occur exceed slot time window transaction ledger properties protocol implements robust transaction ledger provided ledger maintains divided blocks assigned time slots determine 5 order transactions incorporated ledger satisfy following properties persistence parameter k n node system proclaims certain transaction tx stable remaining nodes queried report tx position ledger agree entire prefix ledger prior tx stability defined terms blockchain transaction declared stable block k blocks deep ledger liveness parameter u n honest nodes system attempt include certain transaction passing time corresponding u slots called transaction confirmation time nodes queried responding honestly report transaction stable persistence liveness derived following elementary properties 28 30 39 provided protocol derives ledger data structure form blockchain simply chain party maintains locally updates onset slot properties follows common prefix cp parameter k n chains c1 c2 adopted honest parties onset slots sl1 sl2 c dk 1 c2 c dk 1 denotes chain obtained removing k blocks c1 denotes prefix relation honest chain growth hcg parameters 0 1 s n consider chain c adopted honest party let sl2 slot associated block c let sl1 prior slot c honestly generated block sl2 sl1 s number blocks appearing c sl1 s parameter called speed coefficient existential chain quality cq parameter s n consider chain c adopted honest party onset slot portion c spanning s prior slots honestly generated block appears portion remarks place definition common prefix reflects strong variant appearing 30 chain quality work simple existential formulation convenience previous work focused general notion bounds density honestlygenerated blocks sufficiently long portion chain fact establish density bound directly existential chain quality lines proof chain growth section 4 5 chain growth focus version pertaining suffix chain following honest block fact note section 4 5 combining cq hcg directly infer following stronger version chain growth cg parameters 0 1 s n consider chain c adopted honest party onset slot portion c spanning s prior slots number blocks appearing portion chain s case bitcoin longest chain plays preferred role protocol provides straightforward guarantee honest chain growth 6 security model adopt model introduced 28 analyzing security blockchain protocols enhanced ideal functionality f denote viewp f z view party p execution protocol adversary environment z security parameter access ideal functionality f similarly denote execf z output z note multiple different functionalities encompassed f contrary 28 analysis standard model random oracle functionality interfaces incorporate ideal functionality protocol diffuse key transaction functionality denoted fd kt described note diffuse functionality mechanism obtain protocol synchronization diffuse functionality diffuse functionality maintains incoming string party ui participates party activated allowed moment fetch contents incoming string think mailbox additionally parties instruct functionality diffuse message case message appended party s incoming string functionality maintains rounds slots parties activated round allowed diffuse rounds advance activated parties diffused message adversary activated interact functionality read inboxes diffuse requests deliver messages inboxes order prefers end round functionality ensure inboxes contain messages diffused necessarily order requested diffused current slot index requested time party party fetch certain slot messages written incoming string flushed key transaction functionality key registration functionality initialized n users u1 un respective stakes s1 sn given initialization functionality consult adversary accept possibly sequence corrupt u messages mark corresponding users u corrupt corrupt users registered public key functionality allow adversary set publickeys honest users functionality sample public secret key pairs record based digital signature algorithm consider modes key generation ideal mode key generation outsourced instance ideal signature functionality real mode actual digital signature algorithm utilized cf figure 1 variants explicit public keys corrupt users marked subsequently sequence following actions place user request sign verify message functionality respond accordingly restricting signing requests owners respective keys ii entire directory public keys requested functionality return requesting user iii new user requested created message create u c environment case functionality follow procedure consult adversary corruption status u set public possibly secret key depending corruption status additionally store c suggested initial state functionality return public key environment successful completion interaction iv existing user requested corrupted adversary message corrupt u user corrupted delay d slots specifically corruption request registered timer maintained corruption place d slots passed according round counter maintained diffuse component functionality note running real mode corruption 7 effect revealing secret key adversary case adversary able access signing interface corrupted party assume execution protocol respect functionality f incorporates functionalities functionalities explained note corrupted stakeholder u relinquish entire state point adversary activated place stakeholder u restrictions imposed f adversary corrupt stakeholder given permission environment z running protocol execution permission form message corrupt u provided adversary environment environment arbitrary permissions respect initial stakeholder set respective stake adversary restricted controlling percentage stake case refer adversary initially bounded adversary summary activations following slot slj environment z allowed activate subset stakeholders wishes possibly produce messages transmitted stakeholders adversary activated entity slj adversarial party activations easy model confers sweeping power adversary establish significant guarantees protocols interest important restrict environment suitably taking account details protocol able argue security foresight restrictions impose environment follows restrictions imposed environment environment responsible activating honest parties round subject following constraints activation honest parties running protocol slot honest activated party parameter k z signify maximum number slots honest shareholder offline case honest stakeholder spawned beginning protocol create u c initialization chain c provided environment match honest parties chain active previous slot environment distribute transaction data d 0 1 parties emulating effect diffusing transactions peer peer network transaction data including required signatures stakeholder obtained environment specified protocol slot slr active stakeholder uj view stakeholder include set sj r public keys stake pairs form vki si 0 1 n j 1 nr nr number users introduced slot according view uj public keys marked corrupted corresponding stakeholder corrupted marked corrupted delayed adversary adversary 1 2 bounded particular execution parameter 0 holds total stake corrupted keys divided total stake p si 1 2 possible sj r note distinction notion property execution 1 2 initially bounded 8 adversary refers initial distribution appearing genesis block violated event bad1 2 occurs given execution stake shift bounded short periods specifically chain adopted honest party observed shift stake distribution nearby prefixes chain bounded definition 5 2 precise definition note availability assumption restricting honest parties long periods disconnection stated conservative protocol tolerate longer offline times depending course execution sake simplicity use restriction finally note proofs property q holds high probability executions fact argue q bad1 2 holds high probability executions captures fact exclude environments adversaries trigger bad1 2 non negligible probability 3 ouroboros protocol overview design analysis provide general overview approach design analyze protocol protocol s analysis depend number parameters k number blocks certain message order treated immutable history ledger ii parameters bound adversarial stake stake shift sense adversary 1 2 initially bounded 1 2 bounded execution stake shifts occur short time periods iii d corruption delay imposed adversary e honest stakeholder corrupted d slots corresponding corrupt message generated execution iv l lifetime system measured slots v r length epoch measured slots discussion present protocol description stages successively improving adversarial model withstand stages ideal functionality fls available participants functionality captures resources available parties preconditions secure operation protocol e g genesis block specified fls stage 1 static stake d l r stage trust assumption static remains initial set stakeholders execution divided epochs initial stake distribution hardcoded genesis block includes public keys stakeholders vki si n 1 based restrictions environment adversarial stake 1 2 assumed initial stakeholders specifically environment initially allow corruption number stakeholders relative stake represents 1 2 environment allows party corruption providing tokens form corrupt u adversary note corruption delay imposed stage corruptions parties stake initially corruption model effectively static fls subsequently sample seed weighted stake stakeholder sampling way lead election subset m keys vki1 vkir form committee possess honest majority overwhelming probability r uses fact relative stake possessed malicious parties 1 2 linear dependency r 2 imposed stage guarantee applicability strong concentration bounds detail committee selected implicitly appointing stakeholder probability proportional stake l r slots subsequently stakeholders issue blocks following schedule 9 determined slot assignment longest chain rule applied possible adversary fork blockchain views honest parties prove novel combinatorial argument probability k common prefix violation drops exponentially k cf theorem 4 24 similar reasoning yield favorable guarantees chain growth chain quality favorable analysis covert adversaries e adversaries prefer remain radar cf section 6 stage 2 dynamic stake beacon adversarial look ahead e epoch period r slots delay d 2r l central idea extension lifetime protocol consider sequential composition invocations describe protocol relies trusted beacon emits uniformly random string regular intervals specifically beacon slots j 1 r 1 jr reveals j th random string seeds leader election function following epoch simplify relationship stage adopts secure multiparty computation randomness generation expose randomness beacon adversary e slots prior exposure honest parties adversarial look ahead parameter critical difference compared static stake protocol stake distribution allowed change drawn blockchain means stake distribution adopted j th epoch j 2 determined recent block time stamp j 1 r k 0 appropriate parameter k 0 generic parameter k 0 appearing given precise formula description protocol evolving stake distribution transactions continuously generated transferred stakeholders environment players incorporate posted transactions blockchain based ledgers maintain order accommodate new accounts created fls functionality enables new vk sk created demand assigned new party ui specifically environment create new parties interact fls public secret key way treating trusted component maintains secret wallet note adversary interfere creation new party corrupt supply adversarially created public key instead environment request transactions stakeholder accounts generate transactions collaboration adversary behalf corrupted accounts recall assumption slot view honest player stakeholder distribution places 1 2 stake majority honest players note different honest players perceive different stakeholder distribution certain slot furthermore stake distribution guaranteed shift statistical distance certain number slots permits honest players obtain reliable estimates past stake distributions examining portions blockchains adversarial blocks security proof seen induction number epochs l r base case supplied proof static stake protocol end argue setting 1 2 bound adversarial stake sufficient security single draw observe size committee m selected overcome additive term size ln l r given lifetime system includes number successive epochs corruption delay set d 2r fact set precisely function e k 0 enabling adversary perform adaptive corruptions long instantaneous stage 3 dynamic stake beacon epoch period r slots delay d 2r l stage remove dependence beacon introducing secure multiparty 10 protocol guaranteed output delivery effectively simulates way obtain long livedness protocol described stage 2 design weaker assumptions stage 1 design e mere availability initial random string stakeholder distributions honest majority core idea following given guarantee honest majority elected stakeholders hold high probability use elected set participants instance simple secure multiparty computation mpc protocol naturally require choice length epoch sufficient accommodate run mpc protocol security point view main challenge demonstrate mpc suitably simulates beacon relaxation output known adversary known honest parties feature stage cryptographic design perspective use ledger simulation reliable broadcast supports mpc protocol stage 4 input endorsers stakeholder delegates anonymous communication final stage design augment protocol new roles entities maintaining ledger consider benefits anonymous communication input endorsers create second layer transaction endorsing prior block inclusion mechanism enables protocol withstand deviations selfish mining enables honest behaviour approximate nash equilibrium reasonable assumptions costs running protocol note input endorsers assigned slots way slot leaders inputs included blocks acceptable endorsed eligible input endorser second delegation feature allows stakeholders transfer committee participation selected delegates assume responsibility stakeholders running protocol including participation mpc issuance blocks delegation naturally gives rise stake pools act way mining pools bitcoin finally observe including anonymous communication layer remove corruption delay requirement imposed analysis expense increasing online time requirements honest parties 4 4 analysis static stake protocol 4 1 basic concepts protocol description begin describing blockchain protocol spos static stake setting leaders assigned blockchain slots probability proportional fixed initial stake effective stake distribution execution simplify presentation abstract leader selection process treating simply ideal functionality faithfully carries process randomly assigning stakeholders slots following section explain instantiate functionality specific secure computation remark ideal leader assignment process analyzing standard longest chain preference rule pos setting appears require significant new ideas challenge arises large collections slots epochs described assigned stakeholders favorable properties efficiency incentive perspective furnishes adversary novel means attack specifically adversary control certain population stakeholders beginning epoch choose standard chain update broadcast messages delivered honest parties knowledge future assignments slots 4 follow work achieved efficiently 22 11 stakeholders additionally adversary control particular slot freely generate multiple blocks associated slot committing distinct prior blockchains strategically advertise honest players contrast adversaries typical pow settings constrained decisions online fashion freely generate multiple blocks remark dramatic effect ability adversary produce alternate chains discussion forkable strings detailed discussion static stake case assume fixed collection n stakeholders u1 un interact protocol stakeholder ui possesses si stake protocol starts stakeholder ui verification signing key pair vki ski prescribed signature scheme generated assume loss generality verification keys vk1 known stakeholders describing protocol establish basic definitions following notation 28 definition 4 1 genesis block genesis block b0 contains list stakeholders identified public keys respective stakes vk1 s1 vkn sn auxiliary information foresight note auxiliary information seed slot leader election process definition 4 2 state state string st 0 1 definition 4 3 block block b generated slot sl 1 r contains current state st 0 1 data d 0 1 slot number sl signature signsk st d sl computed sk corresponding stakeholder u generating block slot definition 4 4 blockchain blockchain simply chain relative genesis block b0 sequence blocks b1 bn associated strictly increasing sequence slots state sti bi equal h bi 1 h prescribed collision resistant hash function length chain len c n number blocks block bn head chain denoted head c treat string legal chain convention set head let c chain length n k non negative integer denote c dk chain resulting removal k rightmost blocks c k len c define c dk let c1 c2 indicate chain c1 prefix chain c2 let c k bk adopt interval notation reflect contiguous portions chain specifically c k bk b parentheses indicate removal endpoint example c k bk b 1 definition 4 5 epoch epoch set r adjacent slots s 1 r relevant value r parameter protocol analyze section definition 4 6 adversarial stake ratio let ua set stakeholders controlled adversary adversarial stake ratio defined p j ua sj pn 1 si n total number stakeholders si stakeholder ui s stake reflecting corruption delay general consider adversaries subject corruption delay imparts delay time adversary selects party corruption time party actually passes adversarial control adversary parties 12 identified corruption adversarial control counted adversarial stake ratio unambiguous stake distributions principle possible honest parties disagree current previous stake distribution avoid ambiguities explicitly identifying stake distribution considering adversarial stake ratio slot leader selection protocol described section 0 j r slot leader ej determined sole right generate block slj specifically slot stakeholder ui selected slot leader probability pi proportional stake registered genesis block b0 assignments independent slots static stake case genesis block procedure selecting slot leaders determined ideal functionality fls defined figure 1 functionality parameterized set initial stakeholders u1 s1 un sn assigning stakeholder respective stake distribution d provides auxiliary information leader selection function f defined definition 4 7 leader selection process leader selection process respect stakeholder distribution s vk1 s1 vkn sn d f pair consisting distribution deterministic function d holds slj sl1 slr f s slj outputs ui u1 un probability pi si pn k 1 sk si stake held stakeholder ui weighting stake furthermore family random variables f s slj r j 1 independent note sampling proportional stake implemented straightforward manner instance simple process operates follows let pi si pn j sj 1 n 1 provided stakeholder selected process flips pi biased coin result coin 1 party ui selected slot process complete note pn 1 process certain complete unique leader implement process function f sufficient randomness allocated simulate biased coin flips implement precision individual coin flip selecting stakeholder require ndlog e random bits total note pseudorandom number generator prg use shorter seed string stretch prg appropriate length protocol fls mode hybrid model start describing simple pos based blockchain protocol considering static stake fls sig hybrid model e genesis block b0 consequently slot leaders determined ideal functionality fls sig fls sig provides stakeholders genesis block containing stake distribution indexed signature verification keys generated euf cma signature scheme fls fdsig obtains keys signature ideal functionality fdsig subtle difference comes play describing ideal version spos intermediate hybrid argument security proof discussed section 4 2 stakeholders u1 un interact fls protocol spos described figure 2 interested applications transactions inserted ledger analysis consider simple coin transfer transactions format stakeholder vk1 transfers stakeholders vk2 x coins transaction consist transaction template tx format accompanied signature tx signing key corresponding vk1 define valid transaction follows 13 functionality fls mode fls mode incorporates diffuse key transaction functionality fd kt section 2 parameterized respective stakes initial stakeholders s0 u1 s1 un sn distribution d function f d f leader selection process addition fls mode parameterized mode determines signature verification keys generated fls mode instantiated mode sig resp mode fdsig denoted fls sig resp fls fdsig fls interacts stakeholders follows signature key pair generation fls sig generates signing verification keys ski vki stakeholder ui executing kg 1 1 n fls fdsig generates ski vki querying fdsig figure 3 keygen sidi behalf ui unique session identifier sidi related ui setting ski sidi vki vi received fdsig response 1 n case fls mode sets s 0 0 vk1 s1 vkn sn genesis block generation receiving genblock req ui stakeholder ui fls proceeds follows set fls samples d case fls sends genblock s 0 0 f ui signatures verification signing verification requests behalf user ui fls fdsig provides access corresponding fdsig interface fls sig utilizes ski vki respond restricting access signing respective secret key owners figure 1 functionality fls mode definition 4 8 valid transaction pair tx considered valid transaction verifier v following holds transaction template tx format stakeholder vk1 transfers stakeholder vk2 x coins transaction serial number sn vk1 verification key contained current stake distribution s x z vrfvk1 tx 1 ledger contain transactions issued stakeholder serial number sn transaction valid respect blockchain previous transaction stakeholder serial number simplicity assume properly signed transactions valid included ledger particular means way parse ledger disambiguate recorded double overspents e g following order imposed ledger given definitions 4 4 4 8 define valid chain blockchain according definition 4 4 transactions contained block valid according definition 4 8 protocol relies maxvalids c c function chooses chain given current chain c set valid chains c available network static case analyze simple longest chain rule dynamic case rule parameterized common chain length section 5 function maxvalid c c returns longest chain c c ties broken favor c maximum length arbitrarily 14 protocol spos spos protocol run stakeholders u1 un interacting fls sig sequence slots s 1 r spos proceeds follows 1 initialization stakeholder ui u1 un receives key registration interface public secret key receives current slot diffuse interface case sl1 sends genblock req ui fls sig receiving genblock s0 f answer ui sets local blockchain c b0 s0 initial internal state st h b0 receives key registration interface initial chain c sets local blockchain c initial internal state st h head c 2 chain extension slot slj s stakeholder ui performs following steps ui receives environment transaction data d 0 1 inserted blockchain b collect valid chains received broadcast set c verifying chain c 0 c block b0 st0 d0 sl0 0 c0 holds vrfvk0 0 st0 d0 sl0 1 vk0 verification key stakeholder u 0 f s0 sl0 ui computes c 0 maxvalid c c sets c 0 new local chain sets state st h head c 0 c ui slot leader determined f s0 slj generates new block b st d slj st current state d 0 1 transaction data signski st d slj signature st d slj ui computes c 0 c b broadcasts c 0 sets c 0 new local chain sets state st h head c 0 3 transaction generation receiving transaction template tx environment ui computes signski tx provided tx consistent state ledger view ui sends tx environment figure 2 protocol spos 4 2 transition ideal protocol step security analysis spos introduce idealized protocol ispos present intermediate hybrid argument shows computationally indistinguishable spos instead relying fls sig euf cma signature scheme ispos operates ideal signature scheme end ispos interacts fls fdsig obtaining signing verification keys ideal signature scheme employed protocol sections prove ispos secure series combinatorial arguments hybrid approach insulates combinatorial arguments specific details underlying signature schemes instantiate spos biases schemes introduce distributions spos figure 3 present functionality fdsig defined 16 shown euf cma signature schemes realize fdsig notice fact idealized protocol actually realized based practical digital signature schemes dsa ecdsa ultimately ispos indistinguishable spos idealized protocol ispos run stakeholders interacting fls fdsig fdsig basically ispos behaves exactly spos calls vrfvk signsk m instead locally computing signski m ui sends sign sid m fdsig receiving signature sid m outputting signature instead locally computing vrfvk0 m ui sends verify sidi m v0 fdsig v 0 corresponds verification key vk0 outputting value f received message verified sidi m f protocol ispos described figure 4 idealized description developed arguing dynamic stake case additional 15 functionality fdsig fdsig interacts stakeholders follows key generation receiving message keygen sid stakeholder ui verify sid ui sid0 sid0 ignore request hand keygen sid adversary receiving verificationkey sid v adversary output verificationkey sid v ui record pair ui v signature generation receiving message sign sid m ui verify sid ui sid0 sid0 ignore request send sign sid m adversary receiving signature sid m adversary verify entry m v 0 recorded output error message ui halt output signature sid m ui record entry m v 1 signature verification receiving message verify sid m v0 stakeholder ui 0 hand verify sid m v0 adversary receiving verified sid m adversary 1 v 0 v entry m v 1 recorded set f 1 condition guarantees completeness verification key v 0 registered legitimately generated signature m verification succeeds 2 v 0 v signer corrupted entry m 0 v 1 0 recorded set f 0 record entry m v 0 condition guarantees unforgeability v 0 registered signer corrupted signed m verification fails 3 entry m v0 f0 recorded let f f 0 condition guarantees consistency verification requests identical parameters result answer 4 let f record entry m v0 output verified sid m f ui 0 figure 3 functionality fdsig building blocks considered idealized protocol following proposition immediate corollary results 16 showing euf cma signature schemes realize fdsig proposition 4 9 ppt z holds ppt s execfls sig spos z execfls fdsig ispos s z computationally indistinguishable light proposition remaining analysis focus properties protocol ispos note implication apply any5 possible property consider execution ispos properties prove ispos verifiable environment z result inherited spos proposition 4 9 4 3 fork abstraction security arguments routinely use elements 0 1 n indicate slots particular window slots length n assigned adversarial stakeholders 5an example property property testing non trivial fact parties private states 16 protocol ispos ispos protocol run stakeholders u1 un interacting fls fdsig sequence slots s 1 r ispos proceeds follows 1 initialization stakeholder ui u1 un receives key registration interface public secret key receives current slot diffuse interface case sl1 sends genblock req ui fls fdsig receiving genblock s0 f answer ui sets local blockchain c b0 s0 initial internal state st h b0 receives key registration interface initial chain c sets local blockchain c initial internal state st h head c 2 chain extension slot slj s stakeholder ui performs following steps collect valid chains received broadcast set c verifying chain c 0 c block b0 st0 d0 sl0 0 c0 holds fdsig answers verified sid st0 d0 sl0 1 queried verify sid st0 d0 sl0 0 vk0 vk0 verification key stakeholder u 0 f s0 sl0 ui computes c 0 maxvalid c c sets c 0 new local chain sets state st h head c 0 b ui slot leader determined f s0 slj generates new block b st d slj st current state d 0 1 transaction data obtained fdsig s answer signature sid st d slj queried sign sidi st d slj ui computes c 0 c b broadcasts c 0 sets c 0 new local chain sets state st h head c 0 3 transaction generation given transaction template tx ui returns obtained fdsig s answer signature sidi tx queried sign sidi tx provided tx consistent state ledger view ui figure 4 protocol ispos strings interpretation refer characteristic strings definition 4 10 characteristic string fix execution e genesis block b0 adversary environment z let s 1 n denote sequence slots length s n characteristic string w 0 1 n s defined wk 1 adversary controls slot leader slot k characteristic string w 0 1 index adversarial wi 1 honest start intuition approach analyze protocol let w 0 1 n characteristic string sequence slots s fundamental properties wish ensure protocol cp cq hcg common prefix cp require technical effort section develop graph theoretic abstraction facilitate reasoning properties principally motivated task establishing cp motivate consider observers offline immediately prior commencement sequence slots s ii adopted current chain c0 prior commencement s iii come online slot s request update chain fundamental concern analysis possibility observers presented diverging view sequence s specifically possibility adversary force observers adopt different chains c1 c2 common prefix exactly c0 observe characteristic strings permit instance entirely honest string 0n ensures observers adopt chain c consist n new blocks common prefix c0 hand strings guarantee common extension c0 case 1n possible adversary produce completely different histories 17 sequence slots s furnish observers distinct chains c1 c2 share common prefix c0 bulk proof ouroboros protocol achieves cp relies fact characteristic strings permitting forkings rare density 2 n long fraction adversarial slots 1 2 reason protocol abstract level define formal notion fork captures relationship chains adopted honest slot leaders execution protocol ispos preparation definition recall honest players choose extend maximum length chain available player network furthermore maximal chain c includes block b previously broadcast honest player prefix c prior b entirely agree chain terminating b broadcast previous honest player confluence property follows immediately fact state honest block effectively commits unique chain beginning genesis block conclude chain c diffused honest player begin chain produced previously honest player alternatively genesis block continue possibly sequence adversarial blocks finally terminate honest block follows chains broadcast honest players form natural directed tree fact honest players reliably broadcast chains build longest available chain introduces second important property tree depths honest blocks added honest players protocol distinct course actual chains induced execution ispos comprised blocks containing variety data immaterial reasoning forking elementary chain properties reason formal notion fork merely reflects directed tree formed relevant chains identities players expressed indices string w responsible generating blocks chains forks forkable strings define basic combinatorial structures use reason possible views observed honest players protocol execution characteristic string w 0 1 1 2 2 0 3 1 4 4 0 5 0 6 1 1 8 0 0 9 t t figure 5 fork f string w 010100110 vertices appear labels honest vertices highlighted double borders note depths honest vertices associated honest indices w strictly increasing tines distinguished figure labeled t terminates vertex labeled 9 longest tine fork second tine t terminates vertex labeled 3 quantity gap t indicates difference length t t case gap t 4 quantity reserve t v w wi 1 indicates number adversarial indices appearing label honest vertex v tine case reserve t 3 leaf f honest f closed 18 definition 4 11 fork let w 0 1 n let h wi 0 denote set honest indices fork string w directed rooted tree f v e labeling v 0 1 n edge f directed away root root r v given label r 0 labels directed path tree strictly increasing honest index h label exactly vertex f function d h 1 n defined d depth f unique vertex v v strictly increasing specifically j h j d d j matter notation write f w indicate f fork string w fork trivial contains single vertex root definition 4 12 tines depth height path fork f originating root called tine tine t let length t denote length equal number edges path vertex v let depth v denote length unique tine terminating v height fork usual tree defined length longest tine overload notation applies tines defining t v v terminal vertex tine t borrow truncation operator described earlier paper chains tine t let t dk denote tine obtained removing k edges length t k define t dk consist solely root vertex v fork labeled adversarial index e w v 1 vertex adversarial vertex honest convenience declare root vertex honest extend terminology tines tine honest terminates honest vertex adversarial convention tine t honest fork honestly constructed chains discussed execution e ispos naturally associate characteristic string w fork fd w corresponding chains constructed diffused honest participants protocol figure 5 example demonstrates quantities defined remainder section fork shown figure reflects execution honest player associated slot builds directly genesis block ii honest player associated slot shown chain length 1 produced adversarial player slot 2 addition honestly generated chain step elects extend iii honest player associated slot 5 shown chain length 2 building chain step augmented adversarial block produced player slot 4 etc remark tight correspondence described forks executions requires slot marked adversarial owner slot fell adversarial control protocol direct indication challenge long range attacks involve corruption slot leaders long awarded leadership long lived protocols attacks mitigated bounded depth longest chain rule permits analysis forks characteristic strings determined corruption schedule adversary bounded period time begin defining natural notion inclusion forks 19 definition 4 13 fork prefixes w prefix string w 0 0 1 f w f 0 w 0 f prefix f 0 written f v f 0 f consistently labeled subgraph f 0 specifically vertex edge f appears f 0 furthermore labels given vertex appearing f f 0 identical f v f 0 tine f appears prefix tine f 0 particular labels appearing tine terminating common vertex identical depth honest vertex appearing f f 0 identical cases convenient work forks commit final honest indices definition 4 14 closed forks fork closed leaf honest convention trivial fork consisting solely root vertex closed note fork fd discussed corresponding honestly created chains closed chain constructed honest player naturally terminates block broadcast honest slot remark closed fork unique longest tine maximal tines terminate honest vertex distinct depths note additionally w prefix w f w unique closed fork f w f v f particular taking w w note fork f w unique closed fork f w f v f case f closure f fork adopted chains consider valid chains adopted honest participants protocol set clearly includes chains constructed diffused honest participants hand contain additional valid chains delivered adversary honest participants particular associate fork fa w adopted chains note fd v fa fork fa general closed note maximal tines fork adopted honest player according longest chain rule length chain previously diffused honest player begin precisely defining notion definition 4 15 viability let f w fork string w 0 1 n let t tine f t viable honest indices h t d h length t recall t label terminal vertex t t viable honest participant observer witnessing execution time t provided tine t honest tines generated time t conceivably select t maxvalid rule observe honest tine viable definition depth terminal vertex honest tine exceeds prior honest vertices remarked maximal tines appearing fa viable 4 3 1 abstract chain properties let w 0 1 n characteristic string define following properties w direct analogues general protocol properties defined given tine t sequence slots s t max s refer portion t spanning s maximum subgraph t 0 t v s v t v t 0 use notation t s denote subgraph continue 20 use interval notation sequences slots sl1 sl2 sl1 sl2 parentheses place brackets indicate endpoint left sl1 sl2 sl1 sl2 1 final matter notation elide parentheses expressions t sl1 sl2 simply writing t sl1 sl2 refer portion t spanning s slots particular sequence slots specified common prefix cp parameter k n characteristic string w possesses k cp fork f w pair viable tines t1 t2 f t1 t2 tine t dk 1 prefix t2 equivalently length t1 length t1 t2 k t1 t2 denotes common prefix tines honest bounded chain growth hcg parameters 0 1 s n characteristic string w possesses hcg parameters s fork f w viable tine t f honest vertex v t v s t path t v t contains s vertices chain growth cg parameters 0 1 s n characteristic string w possesses s cg fork f w viable tine t f portion t spanning s slots contains s vertices existential chain quality cq parameter s n characteristic string w possesses s cq fork f w viable tine t f portion t spanning s slots contains honest vertex 4 3 2 probabilistic preliminaries anticipating proofs sections record chernoff hoeffding bound elementary stochastic dominance argument theorem 4 16 chernoff hoeffding bound e g 33 let x1 xt independent random variables xi 0 1 let x pt 1 xi e x 0 pr x 1 e 2 2 pr x 1 e 2 2 additionally 0 pr x e 2 2 t pr x e 2 2 t definition 4 17 elements x y 0 1 n write x y xi yi partial order define notion monotone subsets 0 1 n subset e 0 1 n monotone pair x y 0 1 n x e x y implies y e let x y random variables taking values 0 1 n write x y pr x e pr y e monotone set e case y stochastically dominates x lemma 4 18 let x x1 xn family random variables taking values 0 1 property 0 e xi x1 xi 1 p let b b1 bn family independent random variables taking values 0 1 e bi 1 p x b proof proceed induction statement clear n 1 general consider random variable x satisfying conditions theorem taking values 0 1 n 1 let e 0 1 n 1 monotone event wish prove pr x e pr b e 21 write x y z y takes values 0 1 n z 0 1 induction assume y b1 bn consider events e0 y1 yn y1 yn 0 e e1 y1 yn y1 yn 1 e observe monotonicity e implies e0 e1 e0 e1 monotone study pr x e element y y1 yn 0 1 n define q y pr x e y y observe pr x e e q y recalling e0 e1 y e0 q y 1 y e1 e0 q y p assumption y 6 e1 q y 0 conclude pr x e pr y e0 p pr y e1 e0 ppr y e1 1 p pr y e0 ppr b1 bn e1 1 p pr b1 bn e0 1 pr b1 bn e0 ppr b1 bn e1 e0 pr b e desired inequality line 1 follows induction hypothesis 4 4 chain quality lemma 4 19 abstract existential chain quality consider characteristic string w w1 wl drawn 0 1 l wi independently assigned value 1 probability 1 2 0 1 2 s 0 pr w satisfy s cq cq s l 2 3 2 lexp 2 2 s proof s cq violation w consists fork f w viable tine t pair indices sl1 sl2 sl1 s sl2 t t sl1 sl2 contains honest vertices violation let sl 1 denote largest index honest vertex t 0 sl1 note root f honest fiat sl 1 defined similarly let sl 2 denote smallest index sl2 sl 2 t t 0 sl 2 viable defined t viable observe sl2 sl sl 2 index honest vertex t sl sl2 assumption tine t 0 sl 1 viable supports extension honest vertex contradicts minimality sl 2 assume s 0 sl 1 sl1 sl1 s sl2 sl 2 observe t sl 1 sl 2 contains honest vertices define rank violation quantity sl 2 sl 1 refer sl 2 target violation pair sl 2 signature violation note rank s cq violation s consider sequence sl 1 hsl0 hslg sl 2 22 hsl0 hslg denote honest indices region sl 1 sl 2 let t0 tg denote tines ti hsli note t 0 sl 1 t0 length ti 1 length ti 0 g t 0 sl 2 viable hslg honest note length tg length t 0 sl 2 conclude length t 0 sl 2 length t 0 sl 1 g remark g 0 w w wsl 1 1 wsl 2 note w hand t sl 1 sl 2 contains honest vertex immediate upper bound length t 0 sl 2 length t 0 sl 1 1 w 1 w denotes number adversarial indices w 1 w 0 w fixing particular signature sl follows pr w admits s cq violation signature sl pr w 0 w 1 w 0 pr w 1 w 2 pr w 1 w 1 2 exp 2 2 w denotes wsl 1 wsl follows sl l pr w admits s cq violation signature sl s x s exp 2 2 z s 1 exp 2 2 d 1 2 2 exp 2 2 s 1 exp 2 2 2 2 exp 2 2 s union bound applied indices yields pr w admits s cq violation y exp 2 2 2 2 lexp 2 2 s h 2 3 2 lexp 2 2 s final inequality follows exp x 1 3 2 x x 0 1 2 4 5 chain growth begin lemma demonstrating chain growth cg follows existential chain quality cq honest bounded chain growth hcg lemma 4 20 consider characteristic string w satisfies cq parameter s cq hcg parameters hcg shcg satisfies cg parameters s 2s cq shcg hcg shcg shcg 2s cq particular assuming shcg 2s cq execution satisfies cg parameter hcg 2 proof let f w fork let t viable tine consider portion t spanning s s 2s cq shcg slots cq honest vertex t associated s cq 23 s cq slots honest blocks separated shcg slots applying hcg tine terminates later honest block necessarily viable guarantees hcg s 2s cq hcg s 2s cq s z s hcg shcg shcg 2s cq s vertices appear region inequality follows function f x x x 0 strictly increasing x 0 minimized s shcg 2s cq statement lemma follows establish concrete bounds hcg coupled conclusions cq section 4 4 yield desired bounds cg lemma 4 21 abstract honest chain growth consider w w1 wl drawn 0 1 l wi independently takes value 1 probability 1 2 s 0 0 pr w admits s hcg violation hcg s l 2 3 2 lexp 2 2 s 1 2 particular taking remark pr w admits 1 2 s hcg violation 2 2 2 lexp 2 2 s proof event w admits s hcg violation fork f w viable tine t f indices sl1 sl2 t honest vertex v1 associated sl1 ii sl2 t iii sl1 s sl2 iv t sl1 sl2 contains fewer s vertices let sl1 hsl0 hsl1 hslg sl2 denote increasing sequence honest indices interval sl1 sl2 0 g let ti denote tine ti hsli observe t 0 sl1 t0 case g 0 length ti length ti 1 0 g 1 observe length t length t 0 sl2 length tg length t0 g length t 0 sl1 g follows viability t length t length t 0 sl1 g note g number zeros appearing string w wsl1 1 wsl2 light discussion g s sl2 target violation sl2 sl1 w rank observe pr w admits s hcg violation target sl rank pr 0 w s pr 0 w 1 pr wt w e wt w exp 2 2 inequality follows chernoff hoeffding bounds theorem 4 16 24 union bound applied ranks conclude pr w admits s hcg violation target sl x s exp 2 2 z s 1 exp 2 2 d 1 2 2 exp 2 2 s 1 exp 2 2 2 2 exp 2 2 s complete argument union bound targets yields bound pr w possess s hcg l exp 2 2 2 2 exp 2 2 s 2 3 2 lexp 2 2 s final inequality follows exp x 1 3 2 x x 0 1 2 lemma 4 22 abstract chain growth consider w w1 wl drawn 0 1 l wi independently takes value 1 probability 1 2 s 0 pr w satisfy 1 4 s cg cg 1 4 s l 2 4 lexp 2 s 2 proof corollary follows directly combining lemmas 4 19 4 20 4 21 parameters s cq s 4 shcg s 2 hcg specifically applying lemma 4 19 s cq s 4 pr w satisfy s 4 cq 2 2 2 lexp 2 s 2 likewise applying lemma 4 21 shcg s 2 hcg 1 2 hcg 1 2 pr w satisfy 1 2 s 2 hcg 2 2 2 lexp 2 s light lemma 4 20 considering s cq shcg 2 pr w satisfy 1 4 s cg 2 2 2 lexp 2 s 2 2 2 2 lexp 2 s 2 4 lexp 2 s 2 4 6 common prefix definition 4 23 flat forks relation tines t1 t2 fork f write t1 t2 share edge note equivalence relation set nontrivial tines hand t denotes tine consisting solely root vertex t 6 t tine t fork flat tines t1 6 t2 length equal height fork string w 0 1 said forkable flat fork f w note order execution ispos yield entirely disjoint chains maximum length view observer characteristic string associated execution forkable goal establish following upper bound number forkable strings apply control probability common prefix violation theorem 4 24 let 0 1 let w characteristic string drawn 0 1 n independently assigning wi 1 probability 1 2 pr w forkable 2 n notation hides constant depends note subsequent work russell et al 42 improved bound 2 n 25 structural features forks reach gap reserve margin definition 4 25 gap reserve reach let f w closed fork let t denote unique tine maximum length f define gap tine t denoted gap t difference length t t gap t length t length t define reserve tine t number adversarial indices appearing w index t specifically t given path r v1 vk r root f define reserve t wi 1 vk remark quantity depends f specific string w associated f finally tine t define reach t reserve t gap t definition 4 26 margin closed fork f w define f maximum reach taken tines f f max t reach t likewise define margin f denoted f penultimate reach taken edgedisjoint tines f specifically margin f f max t16 t2 min reach t1 reach t2 2 remark maxima obtained honest tines specifically t adversarial tine fork f w reach t reach t t longest honest prefix t equivalence relation nonempty tines follows pair edge disjoint tines t1 t2 achieving maximum defining equation 2 satisfy reach t1 f reach t2 f relevance margin notion forkability reflected following proposition proposition 4 27 string w forkable closed fork f w margin f 0 proof w honest indices trivial fork consisting single root node flat closed non negative margin conditions equivalent consider forkable string w honest index let denote largest honest index w let f flat fork w let f w closure f obtained f removing adversarial vertices ends tines f note tine t containing longest tine f largest honest index w hand f flat case edge disjoint tines t1 t2 length t prefixes tines f clearly reserve gap non negative reach margin f 0 desired hand suppose w closed fork margin f 0 case edge disjoint tines f t1 t2 reach ti 0 produce flat fork simply adding ti path gap ti vertices labeled subsequent adversarial indices promised definition reserve light proposition string w focus attention quantities w max f w f closed f w max f w f closed f 26 convenience m w w w note overloads notation apply forks strings setting clear context remark definitions guarantee priori w w achieved fork established lemma case clear w 0 w w strings w furthermore proposition 4 27 string w forkable w 0 refer w margin string w preparation proof theorem 4 24 establish recursive description quantities lemma 4 28 m 0 0 nonempty strings w 0 1 m w1 w 1 w 1 m w0 w 1 0 w w 0 0 w 1 w 0 w 1 w 1 furthermore string w closed fork fw w m w fw fw proof proof proceeds induction w define f trivial fork f w unique closed fork string m 0 0 f f desired general consider m w 0 string w 0 wx w 0 1 x 0 1 argument recursively expands m w 0 terms m w value symbol x case consider relationship closed forks f v f 0 f w f 0 w 0 wx case x 1 f f 0 graphs forks assumed closed easy reach tine t f w increased exactly viewed tine f 0 w 0 write reachf0 t reachf t 1 introduce notation reach denote reach particular fork follows f 0 f 1 f 0 f 1 f w 0 closed fork f w 0 note f treated fork w applying argument find w 0 w 1 similar argument implies w 0 w 1 hand induction fork fw m w fw fw m w 0 w 1 w 1 conclude m w 0 w 1 w 1 3 m w 0 fw fw fw treated fork w 0 w1 case x 0 delicate consider relationship closed forks f w f 0 w 0 w0 f v f 0 f 0 necessarily obtained f appending path labeled string form 1a0 end tine t f fact easy assume appended honest tine order possible gap t reserve t reach t 0 particular gap t reserve t inequality note depth new honest vertex exceed deepest honest vertex f gap t second inequality reserve t possible adversarial indices added t reserve t define quantity 0 equation gap t let t 0 denote tine f 0 resulting extending t way parameter pair forks f v f 0 27 course honest tine t f honest tine f 0 clear reachf0 t reachf t 1 length longest tine t 0 f 0 exceeds length longest tine f exactly 1 note reach new honest tine t 0 f 0 0 gap t 0 reserve t 0 zero remains describe w w determined process case w w 0 induction fork fw m w fw fw let t1 t2 edge disjoint tines fw fw reach t1 fw reach t2 define f 0 w 0 fork obtained extending tine t2 fw parameter 0 yield new tine t 0 2 f 0 reachf0 t1 w 1 reachf0 t 0 2 0 follows w0 w 1 w0 0 w0 w 1 w0 0 case conclude w0 w 1 w0 0 fork fw0 f 0 achieves statistics desired return establish w0 w 1 w0 0 let f w0 closed fork w0 f let f w unique closed fork f v f let denote parameter extension let t honest tine f reachf t w0 t tine f reachf t reachf t 1 w 1 t obtained extension reachf t 0 w 1 assumption case w0 w 1 desired remains w0 0 consider f w0 closed fork f w0 let t 1 t 2 edge disjoint honest tines f reachf t 1 f reachf t 2 f w0 let f w unique closed fork f v f let parameter extension t 1 t 2 tines f reachf t reachf t 1 particular reachf t 1 reachf t 2 follows reachf t 2 f w 0 w0 0 tines result extension zero reach f reachf t 1 reachf t 2 case follows f reachf t 2 0 desired case w 0 induction fork fw m w fw fw let t1 t2 edge disjoint tines fw fw reach t1 fw reach t2 define f 0 w 0 fork obtained extending tine t1 fw parameter 0 yield new tine t 0 1 f 0 reachf0 t 0 1 0 reachf0 t2 reachf t2 1 follows w0 0 w0 w 1 w0 0 w0 w 1 case conclude w0 0 w0 w 1 fork fw0 f 0 achieves statistics desired return establish w0 0 w0 w 1 let f w0 closed fork w0 f let f w unique closed fork f v f let denote parameter extension let t honest tine f reachf t w0 note t tine f reachf t reachf t 1 w 1 0 contradicts w0 0 t obtained extension reachf t 0 remains w0 0 let f w0 closed fork f w0 let t 1 t 2 edge disjoint honest tines f reachf t 1 f reachf t 2 f w0 let f w 28 unique closed fork f v f let parameter extension similarly t 1 tine f f reachf t 1 reachf t 1 1 f 1 w 1 0 contradicts f 0 follows t 1 extend tine t1 f reachf t1 0 extension occur tines non negative reach f 0 w t 2 tine f t1 6 t 2 reachf t 2 f w conclude w0 reachf t 2 reachf t 2 1 w 1 desired case w 0 w 6 0 induction fork fw m w fw fw let t1 t2 edge disjoint tines fw fw reach t1 fw reach t2 fact extension fw suffice construction concreteness define f 0 w 0 fork obtained extending tine t1 fw parameter 0 reachf0 ti reachfw ti 1 follows w0 w 1 w0 w 1 w0 w 1 w0 w 1 case conclude w0 w 1 w0 w 1 fork fw0 f 0 achieves statistics desired return establish w0 w 1 w0 w 1 let f w0 closed fork w0 f let f w unique closed fork f v f let denote parameter extension let t honest tine f reachf t w0 note t tine f reachf t reachf t 1 w 1 t obtained extension reachf t 0 w 1 desired recall w 0 remains w0 w 1 let f w0 closed fork f w0 let t 1 t 2 edge disjoint honest tines f reachf t 1 f reachf t 2 f w0 let f w unique closed fork f v f let parameter extension t 1 t 2 tines f reachf t reachf t 1 particular reachf t 1 reachf t 2 reachf t 2 w reachf t 2 w 1 desired complete argument consider case tines t arises extension note case reachf t 2 0 t 2 obtained extension zero reach t 1 obtained extension reachf t 2 reachf t 1 0 separate analysis cases depending sign w w 0 reachf t 2 0 w 1 desired w 0 t 2 extension tine f suppose contrary t 2 extends tine t2 f reachf t2 0 additionally t 1 tine f edge disjoint t2 reachf t 1 reachf t 1 1 0 follows w f 0 contradiction possibility t 1 extension tine t1 f case reachf t1 0 note t 2 tine f edge disjoint t1 min reachf t 2 reachf t1 f 0 reachf t 2 f conclude reachf t 2 reachf t 2 1 w 1 desired recursive description place return proof theorem 4 24 restate convenience theorem 4 24 restated let 0 1 let w string drawn 0 1 n independently assigning wi 1 probability 1 2 pr w forkable 2 n 29 proof theorem 4 24 theorem concerns probability distribution 0 1 n given independently selecting wi 0 1 pr wi 0 1 2 1 pr wi 1 string w1 wn chosen probability distribution define random variables rt w1 wt mt w1 wt goal establish pr w forkable pr mn 0 2 n extract statement lemma 4 28 facts random variables rt 0 rt 1 rt 1 wt 1 1 rt 1 rt 1 wt 1 0 4 mt 0 mt 1 mt 1 wt 1 1 mt 1 mt 1 wt 1 0 5 rt 0 rt 1 1 wt 1 1 rt 1 0 wt 1 0 mt 1 0 wt 0 6 light properties 4 random variables rt behaved positive particular considering distribution placed wi simply follow familiar biased random walk figure 6 likewise considering properties 5 random variables mt follow biased random walk negative remainder proof combines probability laws 6 fact mt rt establish mn 0 high probability 1 0 1 p q q p p q p q figure 6 simple biased walk p 1 2 q 1 p recall basic facts standard biased walk associated markov chain figure 6 let zi 1 1 2 denote family independent random variables pr zi 1 1 2 biased walk given variables yt pt zi following properties constant escape probability gambler s ruin constant probability depending yt 6 1 t 0 general k 0 pr t yt k k 7 constant 1 depending fact constant 1 1 e g 29 chapter 12 complete development 30 concentration chernoff bound consider t steps biased walk beginning state 0 resulting value tightly concentrated t specifically e yt t pr yt t 2 2 t 8 constant hidden notation depends e g 1 cor 1 14 partitioning string w write w w 1 w n w t w1 1 wat dt ne t 0 1 let r 0 0 r t rat similarly define m 0 0 m t mat fix small constant define events based random variables r t m t hot let hott denote event r t n m t n volatile let volt denote event n m t r t n cold let coldt denote event m t n note t exactly events occurs partition probability space establish pr coldt 1 coldt 1 2 n 9 pr coldt 1 volt 10 pr hott 1 volt 2 n 11 cold vol 1 hot 1 1 0 figure 7 illustration transitions cold vol hot note event vol0 occurs definition assuming inequalities observe system likely eventually cold stay way case cold n occurs m n n 0 w forkable specifically note probability system transitions volatile hot 2 n transition vol hot bounded 2 n n possible transition opportunities note system volatile transitions cold constant probability period particular probability system volatile entire process 31 2 n finally note probability system transitions cold state 2 n n possible times happen individual transition occurs probability 2 n follows system cold end process probability 1 2 n remains establish inequalities 9 10 11 inequality 9 follows directly 4 7 specifically light 5 random variables mi follow probability law simple biased walk negative conditioned m t mat n probability future ms climbs value 1 n 2 n desired 1 fixed constant depends inequality 10 follows 4 6 7 8 specifically conditioned volt r t n recall 4 random variables ri follow probability law simple biased walk positive let d event ri 0 2 n according 8 t 2 n pr d 2 n near certainty random variables ri visit value 0 period observe ri 0 6 mi 1 1 constant probability conditioned 7 constant probability subsequent random variables mj return value 0 additionally light 8 probability sequence wi wj length 2 n x j k 1 wk 1 1 wk 0 n n 22 n follows constant probability walk ri hits 0 described mi terminates value n inequality 11 follows 4 6 7 8 specifically conditioned volt r t n recall 4 random variables ri follow probability law simple biased walk positive let d event ri 0 2 n according 8 t 2 n pr d 2 n near certainty random variables ri visit value 0 period conditioned d order rat 1 n sequence random variables 0 ri ri 1 rj b nc value 0 sequence arises taking time variables rat visit 0 j subsequent time sequence larger n light 7 probability subsequence appearing particular value n follows probability rat 1 n n n 2 n desired exact probabilities forkability explicit values n order gain insight density forkable strings exactly computed probability string w drawn wi independently assigned value 1 probability p 40 41 50 forkable different lengths results presented figure 8 reducing common prefix forkability returning challenge common prefix note random assignment slots stakeholders given fls guarantees coordinates associated characteristic string w independent bernoulli random variables taking value 1 probability equal adversarial stake theorem 4 24 establishes 32 0 4 0 42 0 44 0 46 0 48 0 5 0 0 2 0 4 0 6 0 8 probability wi 1 probability forkability probability forkability n 500 n 1000 n 1500 n 2000 figure 8 graphs probability string drawn bit independently assigned value 1 certain probability forkable graphs string lengths n 500 1000 1500 2000 shown probabilities 40 41 49 50 execution protocol ispos induce tines chains maximal length common prefix context ispos wish establish stronger common prefix property pair chains principle presented adversary honest party recent common prefix sense removing small number blocks shorter chain results prefix longer chain formally articulate prove property introduce definition tines forks definition 4 29 divergence let f fork string w 0 1 viable tines t t 0 f define notation t t0 rule t t0 length t length t t 0 t t 0 denotes common prefix t t 0 define divergence viable tines t1 t2 quantity div t1 t2 t1 t2 t1 t2 t2 t1 t2 t1 max t1 t2 t2 t1 t1 t2 overload notation defining divergence f maximum pairs viable tines div f max t1 t2 viable tines f div t1 t2 finally define divergence w maximum divergence possible forks w div w max f w div f observe div t1 t2 k t1 t2 tine t dk 1 prefix t2 33 divergence common prefix violations divergence directly reflects possibility common prefix violation particular characteristic string w satisfies k cp div w k establish string large divergence large forkable substring apply theorem 4 31 conclude characteristic strings arising ispos bit bernoulli random variable unlikely large divergence possess common prefix property specific fork relevance described fa arising protocol analysis fork realizes large divergence theorem 4 30 let w 0 1 forkable substring w w w div w proof consider string w 0 1 n fork f w pair viable tines t1 t2 t1 t2 t1 t2 div w 12 assume t2 t1 minimum pairs tines 12 holds 13 begin identifying substring w remainder proof devoted constructing flat fork w establish forkability let y denote vertex tine t1 t2 diagram let y t1 t2 y t1 t2 let denote smallest honest index w t2 convention index define n 1 follows t1 specifically t1 t2 label adversarial t1 t1 t2 n 1 t1 indices distinguish substring w w 1 w 1 subject remainder proof function strictly increasing tine observe w 1 t1 y length t1 length t1 t2 div w w desired length suffices establish forkable briefly summarize proof presenting details begin establishing structural properties tines t1 t2 follow assumptions 12 13 establish w forkable extract f flat fork w steps fork f subjected minor restructuring ensure long tines pass y ii flat fork constructed treating vertex y root portion subtree f labeled indices w conclusion construction segments tines t1 t2 yield required long disjoint tines satisfying definition forkable observe vertex y adversarial easy construct alternative fork f w pair tines f achieve larger divergence specifically construct f f adding new adversarial vertex y f y y adding edge y vertex preceding y replacing edge t1 following y y relevant properties fork maintained t1 t2 divergence resulting tines increased diagram 34 y y t1 t2 similar argument implies fork f0 w1 w obtained including vertices f labels equal y unique vertex depth depth y y presence vertex y f0 depth depth y redirecting t1 y argument likewise result fork larger divergence note increasing new tine resulting redirecting t1 y y according definition f0 index string additionally implies f0 vertices depth exceeding depth y remark minimality assumption 13 implies honest index h h depth min length t1 length t2 specifically h d h min length t1 length t2 14 consider honest index h tine th th h recall t1 t2 viable h t2 follows immediately d h length t2 similarly h t1 d h length t1 remains settle case t1 h t2 particular regime wish likewise guarantee d h length t1 sake contradiction assume length th d h length t1 considering tine th separately investigate cases depending th shares edge t1 vertex y th t1 share edge vertex y th t2 share edge observe div w th t2 t1 t2 div w div w div th t2 t2 h t2 t1 contradicts 13 hand th shares edge t1 y similarly observe div w t1 th t1 t2 div w h t1 t2 t1 contradicts 13 light remarks observe fork f pinched y yield essentially identical fork f byc w exception tines length exceeding depth y pass vertex y specifically fork f byc w defined graph obtained f changing edge f directed vertex depth depth y 1 originates y resulting tree defined fork suffices check increasing tines f byc purpose consider effect pinching individual tine t terminating particular vertex v replaced tine t byc defined length t depth y tine t unchanged t byc t length t depth y t vertex z depth depth y 1 note z y f0 contains vertices depth exceeding depth y t byc defined path given tine terminating y new edge y z suffix t beginning z z y increasing label property tree f byc legal fork vertex set note depths vertices f f byc identical excising tree rooted y pinched fork f byc extract fork string w 1 wn specifically consider induced subgraph f yc f byc given vertices y z depth z depth y treating y root vertex suitably defining labels yc f yc yc z z y subgraph defining properties fork 35 w 1 wn particular considering honest follows honest index h depth d h length y labels vertex f yc tine t f byc let t yc denote suffix tine beginning y forms tine f yc length t depth y define t yc consist solely vertex y note t yc 1 t yc 2 share edges fork f yc finally let f denote tree obtained f yc union tines t f yc labels t drawn w appears prefix w 1 wn length t max h w h honest d h immediate f w conclude proof f flat purpose consider tines t yc 1 t yc 2 mentioned share edges f yc prefixes t 1 t 2 t yc 1 t yc 2 appearing f share edges wish prefixes maximum length f case f flat desired immediate tine t 1 labels t yc 1 drawn w considering 14 depth relevant honest vertices t 2 observe t2 honest t2 t 1 tine t 2 labeled w argument relying 14 ensures t 2 length relevant honest vertices t2 honest t2 terminal vertex t yc 2 appear f index w case length t yc 2 d h honest index w follows length t 2 length t yc 2 1 depth honest index w desired theorem 4 31 let k l n 0 1 2 let w w1 wl length l wi independently distributed 0 1 pr wi 1 1 2 pr w possess k cp cp k l lexp k constant hidden notation depends proof recall w violates k cp precisely fork f w div f k wish probability div w k exp k log l follows theorem 4 30 div w k forkable substring w length k pr w possess k cp pr 1 l k 1 w w forkable x 1 l x k 1 l pr w w forkable z according theorem 4 24 probability string length t drawn distribution forkable exp c t positive constant c note 1 x l t k 1 e c t z k 1 e c t dt 2 c2 1 c k 1 e c k 1 e k follows sum exp k pr w possess k cp l exp k exp ln l k desired 36 4 7 security analysis idealized protocol theorem 4 32 consider execution e ispos lifetime l slots 1 2 initially bounded adversary environment z persistence parameter k fails hold probability cp k l h l exp k h liveness parameter u 2 k fails hold probability hcg 1 2 2k l cq l h o l exp 4 2 k exp 2 2 h h denotes probability collision queries h participants protocol including probabilities conditioned bad1 2 assume executions adversary 1 2 bounded proof recall fls fdsig functionality directly provides leader selection schedule adversarial selection corrupted players total stake 1 2 yields characteristic string w w1 wl wi selected independently e wi 1 2 recall luxury ideal signature scheme furthermore probability taken evaluations hash function participants protocol including adversary collision observed h q q 2 range q total number queries hash function range size range function light properties unlikely collision queries hash function adopted chains form defined fork fa w observe w satisfies cp hcg cq execution e satisfies cp hcg cq parameters possible course execution e actually satisfies properties stronger parameters execution yields specific fork fa abstract quantities cp cg cq w worst case estimates taken forks observe violation persistence imply directly violation k cp result pr e violates persistence pr fa violates k cp h pr w violates k cp h cp k l h l exp k h inequality follows directly theorem 4 31 liveness parameter u 2 k observe implied 1 2 2k hcg cq specifically consider transaction tx provided input data period s u slots let t viable tine spans s light cq t contains honestly generated block associated slot sl1 slots s tx available honest party generating block appear t 0 sl1 similarly honest block associated slot sl2 slots s u 2 k sl2 sl1 2k consequence 1 2 2k hcg tine t contains k blocks sl1 indexed slots s specifically length t sl1 sl2 k guarantees u liveness pr e violates liveness pr fa violates cq 1 2 2k hcg h pr w violates cq 1 2 2k hcg h cq l hcg 1 2 2k l h l o exp 2 2 o exp 4 2 k h completes proof 37 5 analysis dynamic stake protocol 5 1 trusted beacon static version protocol previous section assumed stake static execution e epoch meaning stake changing hands inside given epoch affect leader election forth modification protocol spos executed multiple epochs way epoch s leader election process parameterized stake distribution certain designated point previous epoch allowing change stake distribution epochs affect leader election process construct protocol hybrid model enhancing fls ideal functionality provide randomness auxiliary information leader election process epochs enhanced functionality called fdls discuss implement fdls fls way reduce assumption simple common random string selected setup describing protocol case dynamic stake need explain modification fls multiple epochs considered resulting functionality fdls allows stakeholders query leader selection data specific epoch fdls parameterized initial stake stakeholder epoch e1 starts subsequent epochs parties consideration stake distribution latest block previous epoch s r k 0 slots k 0 parameter set given predetermined view stakeholder distribution functionality fdls provide random string leave interpretation according stakeholder distribution party calling effective stakeholder distribution sequence s1 s2 defined follows s1 initial stakeholder distribution slots j 1 r 1 jr j 2 effective stakeholder sj determined stake allocation found latest block timestamp j 1 r k 0 provided honest parties agree undefined honest parties disagree functionality fdls defined figure 9 maximum flexibility anticipate needs phase analysis allow adversary perform lookahead beacon value e 0 slots prior onset epoch account lookahead value k 0 suitably adjusted functionality fdls fdls incorporates diffuse key transaction functionality section 2 parameterized public keys respective stakes initial epoch e1 starts stakeholders s0 vk1 s0 1 vkn s0 n distribution d leader selection function f addition fdls operates follows genesis block generation receiving genblock req ui stakeholder ui operates functionality fls message signature key pair generation operates functionality fls epoch randomness update receiving epochrnd req ui ej stakeholder ui j 2 current epoch fdls proceeds follows j set fdls samples j d fdls sends epochrnd j ui adversary allowed lookahead e 0 slots interface e parameter functionality figure 9 functionality fdls beacon lookahead parameter e 0 describe protocol dpos modified version spos updates genesis 38 block data leader selection process new epoch protocol adopts adaptation static maxvalids function defined narrows selection chains share common prefix specifically adopts following rule parameterized prefix length k function maxvalidk c c returns longest chain c c fork c k blocks multiple exist returns c returns listed c matter notation simply refer rule maxvalid parameter inferred context protocol dpos described figure 10 functions fdls hybrid model define idealised version protocol idpos holds access digital signature performed interface fdsig protocol dpos parameters k e r l satisfying 2 k e r dpos protocol run set stakeholders initially equal u1 un interacting fdls sequence l slots s 1 l divided epochs length r l dpos proceeds follows 1 initialization stakeholder ui u1 un receives key registration interface public secret key receives current slot diffuse interface case sl1 sends genblock req ui fls receiving genblock s0 f answer ui sets local blockchain c b0 s0 initial internal state st h b0 receives key registration interface initial chain c sets local blockchain c initial internal state st h head c 2 chain extension slot sl s online stakeholder ui performs following steps new epoch ej j 2 started ui defines sj stakeholder distribution drawn recent block timestamp equal j 1 r 2 k e e 0 lookahead adversary allowed beacon sends epochrnd req ui ej fls receiving epochrnd j answer b collect valid chains received broadcast set c verifying chain c 0 c block b0 st0 d0 sl0 0 c0 holds vrfvk0 0 st0 d0 sl0 1 vk0 verification key stakeholder u 0 f sj 0 j 0 sl0 ej 0 epoch block b0 belongs determined sl0 ui computes c 0 maxvalid c c sets c 0 new local chain sets state st h head c 0 c ui slot leader determined f sj j sl current epoch ej generates new block b st d sl st current state d 0 1 data signski st d sl signature st d sl ui computes c 0 c b broadcasts c 0 sets c 0 new local chain sets state st h head c 0 3 transaction generation protocol spos figure 10 protocol dpos similar argument proposition 4 9 following statement proposition 5 1 ppt z holds ppt s execfdls sig dpos z execfdls fdsig idpos s z computationally indistinguishable 39 light proposition remaining section focus analysis idpos remark 1 modification maxvalid diverge k blocks chain possessed require stakeholders online k slots relevance rule comes fact stake shifts time feasible adversary corrupt stakeholders possess stake majority point triggering bad1 2 adversarial chains produced event rejected ready state main result section establishes dpos protocol robust transaction ledger environmental conditions assumed recall dynamic stake case ensure adversary exploit way stake changes time corrupt set stakeholders enable control majority elected committee stakeholders epoch order capture dependency stake shifts introduce following property definition 5 2 stake shift consider slots sl1 sl2 execution e stake shift sl1 sl2 maximum statistical distance taken chains c adopted honest party weighted stake distributions defined c 0 sl1 c 0 sl2 definition place ready state main theorem theorem 5 3 fix parameters k e r l r 2 k e l integer multiple r consider execution e idpos lifetime l coupled 1 2 initially bounded adversary corruption delay d r e 2 k beacon lookahead e environment z exhibiting stake shift period slots persistence parameter k liveness parameter u 2 k violated probability cp k l hcg 1 2 2k l cq l h l h exp k o exp 2 2 h h denotes probability collision occurring queries h including probabilities conditional space bad1 2 proof consider execution e generated idpos 1 2 initially bounded adversary corruption delay d r e 2 k environment z implicitly condition bad1 2 simply working conditioned probability space furthermore condition event collisions queries hash function participants adversary adjusting ambient probability space second conditioning introduce error term h security guarantees terms random variable e begin defining random variables important family random variables capture high level chain properties protocol chain guarantees t chaint event course epochs numbered 1 t cp satisfied parameter k cq satisfied parameter hcg satisfied parameters 1 2 2k 40 remark reasoning parallel theorem 4 32 properties directly imply cg parameters k 2k 2 2 k particular guarantees growth k blocks period 2 k slots convenience adopt convention chain0 occurs fiat continue define number ancillary random variables relevant values case chaint occurs instantaneous common prefix chaint occurs chains adopted family honest players outset slot tr share common prefix slot tr 2 k let c t denote common chain follows directly chain properties discussed guarantee k cp growth k blocks window 2 k slots analysis critically relies property c t immutable specifically chaint occurs honest participants agree c t maxvalidk revise k blocks currently adopted chain c t prefix future chains held honest parties chaint occur define c t instantaneous stake distribution instantaneous characteristic string s1 defined genesis block t 1 define st stake distribution determined c t 1 chaint 1 occurs set st t define random variable w t 0 1 r r chaint 1 occurs w t characteristic string associated epoch t precisely characteristic string defined leader election schedule determined stake distribution st beacon t ii set parties corrupted selected corruption adversary slot r t 1 e work delay d r e 2 k includes parties adversarial control point epoch t 2 k slots following epoch chaint 1 occur w t z r later convenience identify random variables hont indicate majority slots epoch t honest hamming weight w t strictly r 2 specifically define hont w t hont 1 p w t r 2 hont 0 let w t denote concatenation w 1 w t 1 use word instantaneous emphasize random variables defined state protocol particular time slot features describe e g stake distributions chains etc evolve future course protocol note critical properties random variables considering chaint chains s t occurrence chaint implies variety protocol data established epochs persists rest protocol specifically c 1 c t generally c s prefix chains adopted honest parties epochs s 1 s 2 result honest parties unanimously agree stake distribution ss 1 s t 1 end epoch defined rest protocol 41 continuing discuss ramifications chaint fact honest parties agree s1 st 1 course agree beacon values yields persistent agreement leader schedules t 1 epochs matter analysis remark chaint unambiguously defines characteristic string w w 1 w t 1 fork f t 1 w associated chains adopted honest parties note particular graph structure f t 1 simply defined unambiguous leader schedules structure chains held honest players fact collisions observed hash function ideal signature scheme check f t 1 w suffices ensure slot behaving adversarially vis vis structure fork example violating longest chain rule generating multiple blocks correctly reflected definition w note block signed leader slot associated slot number adopted honest player 2 k slots sufficient time player accumulate chain length k alteration slot possible w surely identifies slot adversarial leader adversarial control following 2 k slots definition w supports fork f t 1 desired shift attention distribution determined w conditioned chaint noted stake distribution st 1 unambiguously determined c t 0 rt 2 k e cf chain extension step figure 10 slot rt e beacon exposed adversary chain stable view honest parties applying cq 1 2 2k hcg honest party added k blocks chain exist prefix honest parties chains remainder protocol follows beacon value t 1 independent st 1 consider adversarial stake distribution indicated c 0 rt e 2 k block chain honestly generated directly apply guarantee provided bad1 2 distribution light cq honestly generated block c appearing slots block c 0 rt e 2 k recalling guarantee stake shift slots adversarial stake ratio given c 0 rt e 2 k 1 2 follows pr w t r 1 w t w t 1 w t r 1 1 2 fork f t 1 determined epoch t 1 protocol property f t 1 w 1 w t 1 complete proof consider virtual characteristic string x obtained substituting w w 1 w l r 0 note chaint fails t string w string x violate k cp cq 1 2 2k hcg observe string x taking values 0 1 l property t pr xi 1 x1 xi 1 1 2 lemma 4 18 random variable x stochastically dominated random variable b b1 bl 0 1 l given independently assigning bi 1 probability exactly 1 2 event characteristic string violates k cp cq 1 2 2s cg clearly monotone violation preserved monotonically increasing set adversarial slots remark additionally characteristic string satisfies k cp z 2k hamming weight string z 2 interval z slots immediate k cp violation light lemma 4 19 lemma 4 22 theorem 4 31 follows pr x violates k cp cq 1 2 2k cg pr b violates k cp cq 1 2 2k cg l h o exp 2 2 exp k h 42 conclude observe x satisfies k cp s cq 1 2 2s cg chaint holds t w x light comment case hont satisfied t follows case e satisfies k cp cq 1 2 2k cg desired properties imply persistence parameter k liveness parameter u 2 k liveness persistence dpos observe proposition 5 1 theorem 5 3 combined security protocol dpos setting trusted beacon particular attack persistence liveness dpos transformed attack idpos follows dpos possesses liveness persistence properties idpos extra error term account failure signature scheme omit details turn focus final protocol beacon implemented 5 2 simulating trusted beacon protocol dpos handles multiple epochs takes consideration changes stake distribution relies fdls perform leader selection process section remove dependency fdls protocol dls allows stakeholders compute randomness auxiliary information necessary leader election resulting modified protocol denote dpos dls operates fls hybrid world recall essential difference fls fdls continuous generation random strings 2 3 epochs e2 e3 idea simple protocol dls use coin tossing protocol generate unbiased randomness define values j j 2 bootstrapping initial random string initial honest stakeholder distribution notice adversary cause simple coin tossing protocol fail aborting build coin tossing scheme guaranteed output delivery protocol dls described figure 12 uses publicly verifiable secret sharing pvss 44 resulting combined protocol dpos dls operates dpos runs dls support random beacon generation epoch simplicity describe combined protocol random oracle model e access random oracle functionality fro possible achieve alternative realisations depend random oracle abstraction advantage simulation argument exploit fact pvss scheme coin flipping protocol built simulates perfect beacon negligible distinguishing advantage simulation suggests case honest majority simulator interacts adversary produces indistinguishable protocol transcripts given beacon value commitment stage describing simulator outside scope exposition simulator inferred pvss schemes 44 18 realized random oracle model advantage programmability oracle note random oracle means necessary possible derive simulator taking advantage common reference string crs embedded genesis block commitments coin tossing coin tossing protocol allows parties obtain uniformly random string classic approach construct protocol commitment schemes commitment scheme committer carries commitment phase sends evidence given value receiver revealing later opening phase committer send value receiver convince value identical value committed commitment phase scheme called binding hard 43 committer convince receiver committed value sent evidence commitment phase called hiding hard receiver learn value opening phase denote commitment phase randomness r message m com r m opening open r m standard party coin tossing protocol 11 party starts sampling uniformly random string u1 sending com r u1 party sends uniformly random string u2 clear finally party opens u1 sending open r u1 parties compute output u u1 u2 note classical protocol committer selectively choose abort protocol opening commitment observes value u2 intrinsic problem party setting avoid problem multi party setting relying verifiable secret sharing scheme honest majority protocol participants publicly verifiable secret sharing vss secret sharing scheme allows dealer pd split secret n shares distributed parties p1 pn adversary corrupting t parties recover verifiable secret sharing vss scheme 26 additional guarantee honest parties recover adversary corrupts shares held parties controls dealer malicious define vss scheme pair efficient dealing reconstruction algorithms deal rec interested vss secret random string dealing algorithm deal t n takes input number shares generated n parameter t n outputs shares 1 n random value reconstruction algorithm rec takes input shares 1 n outputs secret long t shares corrupted unavailable shares set considered corrupted publicly verifiable secret sharing scheme allows party verify validity shares non interactive way learning shares achieved publishing auxiliary verification information later attested correspond shares revealed specifically setup algorithm assumed executed honestly key generation algorithm keygen executed shareholder resulting secret public key having encryption denoted recoverable secret key th stakeholder running algorithm decrypt finally verify algorithm capable verifying encrypted shares public key setup information refer discrete logarithm based pvss 44 18 details constructing protocol dls main problem solved realizing fdls protocol run stakeholders generating uniform randomness leader selection process tolerating adversaries try interfere aborting feeding incorrect information parties order generate uniform randomness j epoch ej j 2 elected stakeholders epoch ej 1 employ coin tossing scheme honest parties guaranteed receive output long honest majority protocol stages commit reveal employs parameters k stages protocol presented figure 11 commitment phase consisting 2k 3 slots proceeds follows 1 r stakeholder ui engages pvss executing deal r r 2 posts output shares blockchain later 2k 3 slots beginning commitment phase players check blockchain slot commitment phase contains proper pvss shares r 2 1 selected stakeholders requires running pvss verification commitment assuming case reveal stage commences reveal stage lasts 44 cg cq slots commit cq slots hcg 2k slots synchronize cq slots cq slots reveal stake distribution deadline figure 11 stages protocol dpos use blockchain broadcast channel epoch r 2k 4 slots slots 1 r stakeholder ui reveals share received commitment cf protocol dls figure 12 remark possible expense expanding length epoch somewhat run efficient opening stage force open commitments kept private given optimistically force open required overall communication complexity case improve prelude section dls protocol implements fdls functionality based fls functionality bulletin board fbb specifically functionality operates follows parameterized k stakeholder distribution s0 stakeholders submits message m passed adversary slots reported pending party querying bulletin board finally 2 k slots pending messages submitted 2 k slots finalized slot selected adversary reported party querying functionality slot finalised 1 slots later slot originally submitted use fbb global functionality cf 17 proposition 5 4 essentially 44 ppt z holds ppt s execfls fro fbb dls z execfdls fbb s z computationally indistinguishable computational diffie hellman assumption lookahead parameter fdls set e proof fixing simulator s runs controls honest parties postings respect underlying dls protocol following round structure protocol recall structure pvss protocol 44 public parameters g g party registered public key form yi gxi commitment party picks random polynomial p degree d r 2 coefficients a0 a1 ad performs commitment publishing values c0 g a0 cd g ad y1 y p 1 1 yr y p r r let xi qd j 0 c j j g p proof equality discrete logarithms party publishes proof logg xi logyi yi commitment verified checking proofs discrete log equality note commitment opened publishing s ga0 proof equality discrete logarithms logg s logg c0 hash product opened commitments value beacon parties force open commitments publishing values si si y x 1 proof equality discrete logarithms logsi yi logyi g subsequently possible recover random value computing lagrange coefficients 1 d respect indexes available i1 id compute s qd j 1 s j ij 45 describe simulated execution protocol based ddh tuple hg g c di initial commit stage s follows protocol honest party modifying commitment c0 computed c a0 opposed g a0 simplicity assume adversarial parties 1 r 2 simulated execution public keys yr 2 1 yr selected powers g polynomial values p 1 p r 2 selected behalf honest party random subsequently share encryptions y p 1 1 y p r 2 r 2 calculated note values p r 2 1 p r evaluated directly value p 0 determined logg c0 a0 logg c unknown simulator possible s calculate yr 2 1 y p r 2 1 r 2 1 yr y p r r performing lagrange interpolation taking advantage fact logg yi r 2 1 r known specifically simulator calculate g p r 2 1 gp r suitable lagrange interpolation bases g p 1 gp r 2 ca0 g p 0 raising corresponding honest party secret keys simulator obtains yr 2 1 yr similar manner values c1 g a1 cd g ad calculated lagrange interpolation bases g p 1 gp r 2 ca0 g p 0 proofs performed s behalf honest party simulated taking advantage random oracle programmability observe pvss opening honest party equal da0 s follows strategy honest parties receives pvss values contributed malicious party conclusion 2 k round s queries fdls obtain beacon value epoch moment s ready program random oracle epoch fixed correct beacon value critical moment simulation note programmability achievable provided value da0 pvss honest party set desired random value value defined s fails assuming failure event happen given s controls majority parties capable extracting pvss value contributed malicious party note requires proper secret key honest party turn requires logg g argue failure event happens negligible probability sake contradiction suppose happens probability non negligible perform simulation setting values hg g ci given instance cdh problem random honest party subsequently critical moment simulation terminate returning output value x1 a0 x random input value random oracle table given failure event happens probability conclude algorithm breaks cdh probability rq q number queries posed random oracle 5 3 robust transaction ledger key idea combine dls protocol ability simulate fdls shown proposition 5 4 recursive argument theorem 5 3 observing blockchain play role fbb dls requires resulting combined protocol dpos dls executes operations dpos dls order slot queues messages transmitted diffusion protocol transmits end slot theorem 5 5 fix parameters k e r l r 2k 4 l integer multiple r consider execution e dpos dls lifetime l coupled 1 2 initially bounded adversary corruption delay d 2r environment z exhibiting stake46 protocol dls parameter k dls protocol run subset elected stakeholders corresponding slot epoch ej lasts r 2k 4 slots stakeholders loss generality denoted u1 ur necessarily distinct precondition assume setup algorithm pvss executed output posted fbb stakeholder ui performed keygen obtain yi si posted public key yi fbb stakeholders keys missing protocol executed r adjusted accordingly 1 commitment phase 2k 3 slots slot r 2k 4 epoch ej 1 r stakeholder ui performs deal r r 2 y1 yr obtain encryptions 1 n posts fbb 2 reveal phase slots slot r epoch ej 1 r ui runs decrypt si li recover encrypted shares li ul successfully posted fbb r encrypted shares verify correctly e pass verify finalized fbb slots commitment phase subsequently posts li fbb implementation epochrnd req follows given input epochrnd req ui ej values j l calculated equal h rec l1 lr assuming ul posted fbb shares correctly j l set 0 finally epoch randomness set j r l 1 j l responce set epochrnd j figure 12 protocol dls fls fbb fro underlying pvss scheme shift slots persistence parameter k liveness parameter u 2 k violated probability l h exp k o exp 2 2 h l r dls dsig h denotes probability collision occurring queries h including dsig distinguishing advantage digital signature implementation dls distance dsig implementation probabilities conditional space bad1 2 proof fix environment z adversary consider execution e idpos dls consider modified execution e execution dls protocol substituted simulation provided proposition 5 4 modified execution e define set random variables chain t c t hon t epoch t proof theorem 5 3 stakeholder distribution beacon simulation samples beacon epoch drawn immutable chain c t simulation stop reasons case chain c t e immutable chain stakeholders defined stakeholder distribution determined execute beacon protocol second case fail dishonest majority r selected stakeholders e hont 0 observe modified execution e proof theorem 5 3 repeated identically infer probability b event persistence liveness violated simulation fails e l h exp k o exp 2 2 h consider event b persistence liveness violated execution e protocol idpos dls let t index earliest epoch takes place t 47 event happens define intermediate hybrid distributions e e denoted e t holds beacon generation t epochs performed simulation e remaining performed e performing dls observe e 0 e e l r e furthermore conditional 1 t t holds computational distance e t 1 e t dls follows probability b bounded probability b plus l r dls result persistence liveness violated e probability h exp k o exp 2 2 h l r dls armed result proposition 5 1 infer simulator s1 idealises digital signature protocol acts attacker execution e pr h execfls sig fro dpos dls z pr h execfls fdsig fro idpos dls s1 z dsig follows immediately persistence liveness violated execution dpos dls probability stated theorem remark 2 note easy extend adversarial model include fail stop recover corruptions addition byzantine corruptions advantage mixed corruption setting feasible prove tolerate large number fail stop corruptions arbitrarily 50% intuition simple forkable string analysis applies arbitrary percentage slot leaders rendered inactive necessary provision expand parameter k inverse proportionally rate non stopped parties rate constant asymptotically analysis apply investigation direction follow work ouroboros genesis 4 6 covert adversaries general notion fork defined definition 4 11 reflects possibility adversarial slot leaders broadcast multiple blocks single slot adversaries simultaneously extend different chains provides adversary significant opportunities interfere protocol leaves suspicious audit trail multiple signed blocks slot conspicuously deviates protocol motivates consideration restricted class covert adversaries broadcast block slot adversary deviate protocol extending short chains produce suspicious evidence strategy deniable blame network delays actions 6 6 1 covert forks covertly forkable strings adversary yields restricted notion fork defined definition 6 1 let f w fork string w 0 1 f covert labeling v 0 1 injective particular adversarial index labels node 6contrast general adversary attempts fork signing different blocks slot adversary merely blame network deviation 48 general case define notion forkable string adversaries definition 6 2 string w covertly forkable flat covert fork f w covert adversaries forks simpler structure general adversaries particular string covertly forkable majority indices adversarial provides analogue proposition 4 27 covertly forkable strings proposition 6 3 string w 0 1 n covertly forkable wt w n 2 proof let w covertly forkable string f w flat covert fork f flat edge disjoint tines t1 t2 length equal height f follows number vertices f 2 height f 1 covert case labeling function injective follows n 2 height f recall root vertex labeled 0 index w hand height f number honest indices w conclude length w twice number honest indices desired wt w n 2 produce flat covert fork f w placing honest indices common tine t1 selecting length t1 adversarial indices form edge disjoint second tine t2 structure covertly forkable strings simple analogue theorem 4 24 density covertly forkable strings follows directly standard large deviation bounds theorem 6 4 let 0 1 let w string drawn 0 1 n independently assigning wi 1 probability 1 2 pr w covertly forkable 2 2n proof follows standard estimates cumulative density function binomial distribution exact probabilities covert forkability explicit values n comparison general case computed probability string drawn binomial distribution covertly forkable results presented figure 13 note probabilities simply appropriate evaluations cumulative density function binomial distribution analogous results general case appeared figure 8 6 2 common prefix covert adversaries revisit notion common prefix setting covert adversaries define covert divergence w maximum divergence possible covert forks w cdiv w max f w f covert div f setting general adversaries wish establish string large covert divergence large covertly forkable substring direct analogue theorem 4 31 implies characteristic strings arising ispos unlikely large covert divergence possess common prefix property covert adversaries record analogue theorem 4 30 covert adversaries 49 0 4 0 42 0 44 0 46 0 48 0 5 0 0 2 0 4 binomial distribution parameter probability covert forkability probability covert forkability n 500 n 1000 n 1500 n 2000 figure 13 graphs probability string drawn binomial distribution covertly forkable graphs string lengths n 500 1000 1500 2000 shown parameters 40 41 49 50 theorem 6 5 let w 0 1 covertly forkable substring w w w cdiv w proof brief portions proof direct analogs proof theorem 4 30 consider covert fork f w pair viable tines t1 t2 f t1 t2 t1 t2 cdiv w assume proof general case pair tines minimizes quantity t2 t1 pairs divergence equal cdiv w let y denote vertex tine t1 t2 contrast setting general adversary clear y honest motivates slightly different choice beginning string w define largest honest index w tine t1 t2 convention 0 index proof theorem 4 30 define smallest honest index w t2 convention n 1 honest index define w w 1 w 1 proof theorem 4 30 easy confirm w 1 t1 t1 t2 cdiv w remainder proof argues w covertly forkable proof theorem 4 30 depth d h honest index h min length t1 length t2 h t1 follows directly definition viability t1 h t2 consider tine th labeled h length th min length t1 length t2 tine th coupled t1 t2 produce pair tines divergence div t1 t2 strictly t1 t2 complete proof define injective function h h denotes set honest indices 1 1 complement set adversarial indices w existence function implies h w covertly forkable criterion given proposition 6 3 let a0 denote set adversarial indices w appearing label tines t1 t2 function defined follows h honest index h h smallest adversarial index a0 labels vertex depth equal 50 d h assuming function defined clearly injective labels appear multiple vertices covert fork depths honest vertices pairwise distinct confirm h defined note h h d d h min length t1 length t2 vertex v t1 t2 depth equal d h furthermore defining properties vertex labeled index w d h length t1 t2 common vertex v tines length v d h note vertex honest definition h v defined case d h length t1 t2 tines distinct vertices depth d h adversarial h defined case finally remark proof theorem 4 31 applies minor adaptations covert case theorem 6 6 let k r n 0 1 2 let w w1 wr drawn 0 1 r wi independently takes value 1 probability 1 2 pr cdiv w k r exp 2 k directly bounds probability covert adversay effect common prefix violation execution ispos proof proof theorem 4 31 applies directly case asymptotics rely theorem 6 4 fact x t k e ct z k 1 e ct dt o 1 e ck e ck o 1 hidden constant depend c k 7 anonymous communication stronger adversaries protocols constructed previous section proven secure delayed adaptive corruptions meaning requesting corrupt given party ui adversary wait d slots corruption actually happens naturally desirable d small possible eliminate altogether achieve security standard adaptive adversary delay required adversary able corrupt parties direct response knowledge leader election schedule recall protocol determines schedule epoch epoch basis attack particularly devastating notice slot leaders selected weighting public keys stake adversary choose corrupt user ui knowing public key adversary able observe communication ui diffuse functionality order determine public key associated user ui detect ui selected slot leader eliminate delay extending model sender anonymous broadcast channel provided diffuse functionality having environment activate parties round introduce following modifications ideal functionalities diffuse functionality functionality work described section 2 remove information sender message delivering receiver ur s inbox input tape ensuring sender remain anonymous 7 7 practice sender anonymous broadcast channel properties akin diffuse functionality implemented mix networks 19 dc networks 20 executed nodes running protocol 51 key transaction functionality functionality work described section 2 allow immediate corruption user u receiving message corrupt u adversary apart modifications ideal functionalities change environment behavior requiring activates users slot slj having parties activated slot results anonymity set size equal number honest parties making difficult adversary associate given public key user e honest parties associated given public key associated corrupted party extended model reprove theorem 5 5 delay d strengthening restrictions imposed environment following way adversary restricted 1 2 relative stake windows length d sets consecutive slots length d sum corrupted keys maximum stake held key period d slots possible sj r uj honest party 1 2 minimum total stake period case violated event bad1 2 d true given execution strengthened condition remove corruption delay requirement d theorem 5 5 assuming bad1 2 substituted bad1 2 d 8 incentives far analysis focused cryptographic setting set honest players operate presence adversary corrupt players section consider setting coalition rational players incentives deviate honest protocol operation 8 1 input endorsers order address incentives modify basic protocol assign different roles stakeholders epoch set elected stakeholders slot leaders epoch responsible issuing blocks forming randomness epoch necessarily disjoint set stakeholders called endorsers slot types stakeholders associated slot leader issue block slot endorser endorse input included slot remark adapt discussion setting multiple endorsers assume single input endorser slot description like insignificant modification gives room improvement following reason endorsers contributions acceptable d slots late d n parameter protocol particular protocol calls slot leaders include block inputs endorsed previous d endorsers appearing existing chain note blocks endorsed inputs diffused independently block containing 0 d endorsed inputs note case valid endorser input available slot leader issue block leader ahead issue block e block actual inputs e g transactions case transaction ledger note slot endorsers like slot leaders selected stake weight representative sample stakeholder population case transaction ledger transaction included 52 input endorsers simultaneously case transaction multiply present blockchain occurrence canonical position ledger enhanced protocol dposwe easily seen persistence liveness behaviour dpos modification endorsers provide possibility adversary prevent chain growing accepting inputs consistent measure chain quality terms number endorsed inputs included produces favorable result easy number endorsed inputs originating set stakeholders s k long portion chain proportional relative stake s high probability stems fact sufficient single honest block created endorsed inputs d slots included assuming d cq parameter previous sections set stakeholders s endorser subset d slots probability proportional cumulative stake result follows bitcoin stakeholders issue blocks incentivized participate protocol collecting transaction fees contrary bitcoin course need incentivize stakeholders invest computational resources issue blocks availability transaction verification incentivized incentivized online stakeholder minimum online operational following circumstances slot prior slot elected shareholder queries network obtains currently longest blockchain endorsed inputs include block slot elected shareholder issues block containing endorsed inputs slot commit stage epoch supposed issue pvss commitment random string slot reveal stage epoch supposed issue required opening shares general sufficient frequency check elected shareholder current epoch slot elected input endorser issues endorsed input e g set transactions requires processing available transactions verifying order incentivize actions setting transaction ledger fees collected issue transactions included ledger transfered block issuers bitcoin instance fees collected miner produces block transactions reward setting similarly reward given parties issuing blocks endorsing inputs reward mechanism block dependent advocated 38 setting possible collect fees transactions included sequence blocks pool distribute pool shareholders participated slots example input endorsers active receive reward proportional number inputs endorsed period rounds independently actual number transactions endorsed ways distribute transaction fees feasible including bitcoin bitcoin method known vulnerable attacks e g selfing mining attack 53 reward mechanism pair input endorsers operates follows let c chain consisting blocks b0 b1 consider sequence blocks cover j th epoch denoted b1 bs timestamps jr 1 j 1 r contain r 0 sequence endorsed inputs originate j th epoch included j 1 epoch define reward pool p j equal sum transaction fees included endorsed inputs correspond j th epoch transaction occurs multiple times different endorsed inputs conflicting versions occurrence transaction taken account considered ledger position calculation p j total order induced order endorsed inputs included c sequence blocks identify l1 lr slot leaders corresponding slots epoch e1 er input endorsers actively contributed sequence r endorsed inputs subsequently th stakeholder ui claim reward j ui ej r 1 j ui lj r p j 0 1 parameter protocol claiming reward performed issuing coinbase type transaction point 2 k slots subsequent epoch reward claimed observe reward mechanism following features rewards elected committee members committee members independently issued block ii rewards input endorsers inputs contributed iii rewards entities epoch j slot jr 2 k proceed system nash approximate equilibrium cf 35 section 2 6 6 specifically theorem states coalition deviating protocol add additive total rewards technical difficulty formulation number players relative stake rewards receive based transactions generated course protocol execution simplify analysis consider setting number players static stake possess shift time protocol negligible cost executed observe total rewards utility assumption protocol costs coalition v honest players able extract execution lasting l tr 2 k 1 slots equal rv e x t j 1 p j iej v e r 1 slj v e rj provided e satisfies cp parameter k cq satisfied parameter hcg satisfied parameters 1 2 2k rj total endorsed inputs emitted j th epoch possibly included time slots epoch j 1 p j reward pool epoch j slj v e number times member v elected slot leader epoch j iej v e number times member v selected endorse input epoch j set convention value rv e 0 e execution basic underlying properties blockchain fail particular cp parameter k cq satisfied parameter hcg satisfied parameters 1 2 2k finally observe actual rewards obtained set rational players v execution e different rv e instance coalition v endorse set inputs case obtain smaller number rewards 54 establish fact protocol nash equilibrium proving coalition v deviating proper protocol behavior obtain utility exceeds rv e suitable constant 0 theorem 8 1 fix 0 polynomially related parameters k conditions restrictions theorem 5 5 honest strategy protocol nash equilibrium coalition players represented adversary provided maximum total rewards pall provided possible protocol executions bounded polynomial proof consider coalition rational players v restricted statement theorem engages protocol execution number players follow protocol faithfully total number l epochs deviation protocol result substantially higher rewards v observe based theorem 5 5 matter strategy v probability 1 function negligible security parameters k protocol enable users obtain rewards entitled slot leaders input endorsers stems following liveness honest block included slots epoch input endorsers follow protocol opportunity enter endorsed inputs times elected second rewards received proportional times party input endorser issued block successfully equal number times slot leader result error utility received coalition v equal rv follows player v expected utility e rv pall pall maximum rewards produced possible execution result follows assumption statement theorem pall sufficiently large remark 3 theorem simplicity assumed protocol costs affecting final utility essence means protocol costs assumed negligible straightforward extend proof cover setting negative term introduced payoff function player proportional number times inputs endorsed number messages transmitted beacon protocol proof resilient modifications endorsed inputs beacon protocol messages stifled adversary reward function designed suitable weights actions offsets cost note rewards provided assumed flat slots endorsed inputs costs flat leave future work investigation refined setting costs rewards proportional actual computational steps needed verify transactions issue blocks remark 4 reward function described considers number times entity input endorser considering work verify given transactions furthermore sensitive slot leader issued block assigned time slot provide context choices suppose slot leaders receive reward issue block easy parties follow protocol parties receive proportion reward pool associated block issuance roughly proportional stake malicious coalition easily increase ratio rewards performing block witholding attack case selfish mining attack given happens non negligible probability straightforward definition rv e respects assignment vulnerable attack nash equilibrium theorem shown consider case extending reward function input endorsers rewarded based transactions verify opposed flat reward 55 considered theorem special care necessary design function straightforward way implement input endorser verify transaction pool higher claim fee strategy adversary deviate protocol improve ratio rewards perform block withholding endorsed input censorship remove endorsed inputs blockchain originate honest parties include removed transactions endorsed input transmitted possible opportunity given attack natural way define rv e susceptible nash equilibrium theorem shown possible direction ameliorating problem share transaction fee transaction input endorsers endorsed suggests following modification protocol input endorser attempt include transactions collected sequence k slots retransmit endorsed input case removed main chain leave analysis class reward mechanisms future work 9 stake delegation discussed previous section stakeholders online order generate blocks selected slot leaders unattractive stakeholders small stake system requiring majority elected stakeholders participate coin tossing protocol refreshing randomness introduces strain stakeholders network require broadcasting storing large number commitments shares mitigate issues providing method reducing size group stakeholders engage coin tossing protocol instead elected stakeholders directly forming committee run coin tossing group delegates act behalf detail forth delegation scheme stakeholders authorize entities called delegates stakeholders represent coin tossing protocol delegate participate protocol represents certain number stakeholders aggregate stake exceeds given threshold participation threshold ensures fragmentation attack aims increase delegate population order hurt performance protocol incur large penalty capable force size committee runs protocol small worth noting delegation mechanism similar mining pools proof work blockchain protocols 9 1 minimum committee size appreciate benefits delegation recall basic protocol dpos committee member selected weighing stake honest probability 1 2 fraction stake held honest players number honest players selected k invocations weighing stake binomial distribution interested probability malicious majority directly controlled chernoff bound specifically let y number times malicious committee member elected pr y k 2 pr y 1 1 2 k exp min 2 1 2 k 4 exp 2 1 2 k 4 2 1 2 assuming 1 4 follows 1 56 consider case 0 05 bound exp 0 00138 k provides error 1 1000 long k 5000 similarly case 0 1 bound exp 0 00625k provides error k 1100 observe order withstand significant number epochs 215 equate period day 88 years require error probability 2 40 need k 32648 cases wealth system concentrated small set stakeholders choice bound create large committee course maximum size committee k 9 2 delegation scheme concept delegation simple stakeholder allow delegate generate blocks behalf context protocol slot leader signs block generates certain slot scheme implemented straightforward way based proxy signatures 12 stakeholder transfer right generate blocks creating proxy signing key allows delegate sign messages form st d slj e format messages signed protocol dpos authenticate block order limit delegate s block generation power certain range epochs slots stakeholder limit proxy signing key s valid message space strings ending slot number slj specific range values delegate use proxy signing key given stakeholder simply run protocol dpos behalf signing blocks stakeholder elected generate proxy signing key simple scheme secure verifiability prevention misuse properties proxy signature schemes ensure stakeholder verify proxy signing key actually issued specific stakeholder specific delegate delegate use keys sign messages inside key s valid message space respectively remark proxy signatures described high level generic primitive easy construct schemes standard digital signature schemes delegation proxy shown 12 construction stakeholder signs certificate specifying delegates identity e g public key valid message space later delegate sign messages valid message space providing signatures messages public key signed certificate added advantage proxy signature schemes built aggregate signatures way signatures generated proxy signing key essentially size regular signatures 12 important consideration setting fact stakeholder want withdraw support stakeholder prior proxy signing key expiration observe proxy signing keys uniquely identified revoked certificate revocation list blockchain 9 2 1 eligibility threshold delegation described ameliorate fragmentation occur stake distribution prevent malicious stakeholder dividing stake multiple accounts refraining delegation induce large committee size address mentioned threshold t 1% applied means delegate representing fraction t total stake automatically barred committee member facilitated redistributing voting rights delegates representing t delegates deterministic fashion e g starting highest stake 57 breaking ties according lexicographic order suppose committee formed c1 cm total k draws weighing stake committee member hold ki votes pm 1 ki k based eligibility threshold follows m t 1 maximum value case stake distributed t 1 delegates holding t stake 10 attacks discussion discuss number practical attacks indicate reflected modeling mitigated double spending attacks double spending attack adversary wishes revert transaction confirmed network objective attack issue transaction e g payment adversarial account holder victim recipient transaction confirmed revert transaction e g including ledger second conflicting transaction attack feasible conditions theorem 5 5 persistence ensures transaction confirmed honest player honest players point disagree transaction impossible bring system state confirmed transaction invalidated assuming preconditions theorem hold section experimental discussion double spending grinding attacks stake grinding attacks adversary tries influence slot leader selection process improve chances selected generate blocks perform attacks double spending basically generating block taken input slot leader selection process adversary tests possible block headers block contents order find gives best chance selected slot leader future attack affects pos based cryptocurrencies collect randomness slot leader selection process raw data blockchain e block headers contents protocol uses coin tossing protocol proven generate unbiased uniform randomness discussed section 5 2 adversary influence randomness generated figure 12 guaranteed uniformly random guaranteeing slot leaders selected probability proportional stake transaction denial censorship attacks transaction denial attack adversary wishes prevent certain transaction confirmed instance adversary want target specific account prevent account holder issuing outgoing transaction attack feasible conditions theorem 5 5 liveness ensures provided transaction attempted inserted sufficient number slots network eventually confirmed desynchronization attacks desynchronization attack shareholder behaves honestly incapable synchronizing correctly rest network leads ill timed issuing blocks offline periods shareholder supposed participate attack mounted preventing party s access time server mechanism allows synchronization parties desynchronization occur exceedingly long delays message delivery model allows parties desynchronized incorporating adversary guarantees liveness 58 persistence provided desynchronized parties security long parties 50% stake desynchronized 50% parties desynchronized protocol fail general models like partial synchrony 23 39 interesting consider pos design setting follow work ouroboros praos information topic 22 eclipse attacks eclipse attack message delivery shareholder violated subversion peer peer message delivery mechanism case desynchronization attacks model allows parties eclipse attacked incorporating adversary guarantees liveness persistence provided parties 51% attacks 51% attack occurs adversary controls majority stake system easy sequence slots case high probability forkable system finds setting honest stakeholders placed different forks long periods time persistence liveness violated bribery attacks bribery attacks 13 adversary deliberately pays miners cryptocurrency fiat money work specific blocks forks aiming generating arbitrary fork benefits adversary e g supporting double spending attack miners pow based cryptocurrencies stake order blocks makes attack strategy feasible setting adversary offers bribe higher reward correctly generating block rational miner clear incentive accept bribe participate attack increases miner s financial outcome pos based protocol malicious slot leaders agree deliberately attack system risk forego potential profit earn behaving honestly risk lose equity notice slot leaders money invested system order able generate blocks attack system observed bring currency value bribe higher reward correct behavior loss currency devaluation easily offset additional profits participating attack bribery attacks effective pos based consensus protocol pow based currently rationality model formally encompass attack strategy investigating efficacy pos based consensus protocols left future work long range attacks attacker wishes double spend later point time mount long range attack 14 computing longer valid chain starts right genesis block single stakeholder actively participating protocol attacker owns small fraction total stake locally compute chain generating blocks slots elected slot leader generating blocks ahead current time alternative chain blocks main chain attacker post transaction main chain wait confirmed goods delivered exchange transaction present longer alternative chain invalidate previously confirmed transaction attack ineffective ouroboros reasons protocol dls output valid leader selection data allowing protocol continue majority stakeholders participate delegates participate behalf stakeholders reject blocks generated slots far ahead time alternative chain generated artificially blocks protocol messages generated solely attacker controls small 59 fraction stake leader selection data needed start new epochs considered invalid nodes attacker find strategy generate alternative chain valid leader selection data presenting chain blocks generated slots far ahead time result successful attack blocks far ahead time rejected honest stakeholders final alternative chain shorter main chain stake attacks stake problem refers general attacks pos blockchain systems facilitated shareholders continuing simultaneously multiple blockchains exploiting fact little computational effort needed build pos blockchain provided stakeholders frequently online stake taken care analysis forkable strings adversary brute forces possible strategies fork evolving blockchain near future viable chain selection rule instructs players ignore deep forks deviate block received time online worth noting contrary pow based blockchains protocol infeasible fork generated earnest shareholders slots uniquely assigned given moment single uniquely identified shareholder elected advance blockchain players following longest chain rule adopt newly minted block adversary presents moment alternative blockchain older blocks remarked 15 tragedy commons lead stakeholders pos based schemes adhere attacks power deter attacks incur financial losses join attack lead rational stakeholders accept small bribes alternative currencies obtain financial gain incentive structure ouroboros slot leaders endorsers potentially join attack receive rewards main adversarial chain resulting stakeholders achieving higher profits joining attack past majority attacks stake moves assumption current majority stakeholders honest means past account keys potentially hold stake present compromised leads potential vulnerability pos system set malicious shareholders past build alternative blockchain exploiting old accounts fact effortless build blockchain light theorem 5 5 attack occur shareholders frequently online observe evolution system case stake shifts higher anticipated preconditions theorem seen special instance stake problem attacker longer owns stake system free financial losses conducting attack selfish mining type attack attacker withholds blocks releases strategically attempting drop honestly generated blocks main chain way attacker reduces chain growth increases relative ratio adversarially generated blocks conventional reward schemes bitcoin implications enables attacker obtain higher rate rewards compared rewards receiving case following honest strategy reward mechanism selfish mining attacks neutralized intuition input endorsers entities receive rewards proportionally contributions stifled block withholding input endorser contribution accepted sufficiently long period time endorsement took place ensuring incorporated blockchain sufficient 60 chain quality chain growth given input endorsers contributions approximately proportional stake ensures reward distribution affected substantially block withholding 11 experimental results implemented prototype instantiation ouroboros haskell rustbased parity ethereum client order evaluate concrete performance specifically implemented protocol dpos protocol dls generate leader selection parameters e generating fresh randomness weighed stake sampling procedure instantiation use pvss scheme 44 implemented elliptic curve secp256r1 pvss scheme s share verification information includes commitment secret commitment specified protocol dls eliminates need separate commitment generated stored blockchain order obtain better efficiency final output protocol dls uniformly random binary string 32 bytes string seed prg chacha implementation 10 stretched r random labels log bits corresponding slot epoch weighing stake leader selection process implemented random binary string associated epoch perform sequence coin flips selecting stakeholder signature scheme signing blocks ecdsa implemented curve secp256r1 11 1 transaction confirmation time optimal network conditions examine time required confirming transaction setting network substantial load transactions processed appear adversary btc ob covert ob general 0 10 50 3 5 0 15 80 5 8 0 20 110 7 12 0 25 150 11 18 0 30 240 18 31 0 35 410 34 60 0 40 890 78 148 0 45 3400 317 663 figure 14 transaction confirmation times minutes achieve assurance 99 9% hypothetical double spending attack different levels adversarial power bitcoin ouroboros covert general adversaries fig 14 lay comparison terms transaction confirmation time bitcoin ouroboros showing verifier wait sure best possible8 doublespending attack succeeds probability 0 1% case bitcoin consider double spending attacker commands certain percentage total hashing power wishes revert transaction attacker attempts double spend block witholding attack described paper attacker mines private fork releases long 8the best possible case ouroboros bitcoin use best known attack 61 case ouroboros consider double spending attacker attempts brute force space possible forks current slot leader distribution certain segment protocol commands certain percentage total stake consider covert general adversarial setting ouroboros scenarios measure number minutes wait order achieve probability double spending 0 1% fig 15 present graph illustrates speedup graphically 0 1 0 2 0 3 0 4 4 6 8 10 12 14 16 adversarial strength blockwitholding attacker speedup ob btc confirmation time speed ouroboros btc covert general figure 15 ouroboros vs bitcoin speedup transaction confirmation time hypothetical double spending attacker assurance level 99 9% ouroboros 10 5 times faster regular adversaries 16 10 times faster covert adversaries note measurements compare ouroboros implementation bitcoin way systems parameterized 10 minute block production rate bitcoin 20 second slots ouroboros conservative parameter selection exploring alternative parameterizations bitcoin making proof work easier speed transaction processing carefully measuring impact overall security 11 2 absolute performance ouroboros implemented ouroboros instance rust based ethereum parity client 9 subsequently experiments run amazon s elastic compute cloud ec2 c4 2xlarge instances east 1 region smaller runner instance responsible coordinating worker instances experiment consists steps 1 worker instance builds clean docker image containing specific revision fork 9ethcore parity https ethcore io parity html 62 parity software10 containing ouroboros proof concept changes based parity 1 6 8 release 2 worker instance started isolated mode nodes talk period parity account recovered node start time network established 3 worker instance restarted production mode allows communication nodes transactions mined 4 single worker instance informed nodes nodes aware nodes parity s peer peer discovery methods 5 worker instance number transactions generated ingested experiment 650 000 total transactions generated participating nodes shared stake equally transferred given transaction small avoid account running funds instance generates transactions hardcoded shared random seed keeps transactions originating local user account 20 transactions saved single json file ready directly passed parity rpc endpoint curl command line tool ingestion single file 20 transactions ingested second spent idle file avoid overwhelming instances requests setups tested focusing adjusting ouroboros slot duration number participating nodes 10 20 30 40 nodes tested ultimately limited number instances allowed single ec2 region slot durations 5 10 20 seconds tested variance experiments small figure 16 present case 40 nodes slot length 5 seconds exhibits median value 257 6 transaction second 12 acknowledgements thank ioannis konstantinou contributed preliminary version protocol thank lars br unjes duncan coutts kawin worrasangasilpa comments previous drafts article thank peter ga zi comments previous drafts article assisting generalize theorem 4 30 viable forks thank saad quader noting inconsistency previous definitions common prefix divergence assisting adapt theorem 4 30 thank george agapov prototype implementation protocol haskell jake goulding parity based implementation references 1 noga alon joel spencer probabilistic method wiley 3rd edition 2008 2 giuseppe ateniese ilario bonacina antonio faonio nicola galesi proofs space space essence michel abdalla roberto de prisco editors security cryptography networks 9th international conference scn 2014 amalfi italy september 10available https github com input output hk parity tree experiment 2 020fd77dc70d3f25e0e0f44bd6b1e19ccf3790d3 63 figure 16 measuring transactions second 40 node equal stake deployment slot length 5 seconds 3 5 2014 proceedings volume 8642 lecture notes computer science pages 538 557 springer 2014 3 yonatan aumann yehuda lindell security covert adversaries efficient protocols realistic adversaries j cryptology 23 2 281 343 2010 4 christian badertscher peter gazi aggelos kiayias alexander russell vassilis zikas ouroboros genesis composable proof stake blockchains dynamic availability david lie mohammad mannan michael backes xiaofeng wang editors proceedings 2018 acm sigsac conference computer communications security ccs 2018 toronto canada october 15 19 2018 pages 913 930 acm 2018 5 christian badertscher peter ga zi aggelos kiayias alexander russell vassilis zikas ouroboros chronos permissionless clock synchronization proof stake manuscript 2019 6 iddo bentov ariel gabizon alex mizrahi cryptocurrencies proof work corr abs 1406 5694 2014 7 iddo bentov charles lee alex mizrahi meni rosenfeld proof activity extending bitcoin s proof work proof stake extended abstract y sigmetrics performance evaluation review 42 3 34 37 2014 8 iddo bentov rafael pass elaine shi sleepy model consensus iacr cryptology eprint archive 2016 918 2016 9 iddo bentov rafael pass elaine shi snow white provably secure proofs stake iacr cryptology eprint archive 2016 919 2016 10 daniel j bernstein chacha variant salsa20 sasc state art stream ciphers 2008 64 11 manuel blum coin flipping telephone allen gersho editor advances cryptology report crypto 81 crypto 81 ieee workshop communications security santa barbara california usa august 24 26 1981 pages 11 15 u c santa barbara dept elec computer eng ece report 82 04 1981 12 alexandra boldyreva adriana palacio bogdan warinschi secure proxy signature schemes delegation signing rights j cryptology 25 1 57 115 2012 13 joseph bonneau buy rent bribery attacks bitcoin style consensus jeremy clark sarah meiklejohn peter y ryan dan s wallach michael brenner kurt rohloff editors financial cryptography data security fc 2016 international workshops bitcoin voting wahc christ church barbados february 26 2016 revised selected papers volume 9604 lecture notes computer science pages 19 26 springer 2016 14 vitalik buterin long range attacks problem adaptive proof work https blog ethereum org 2014 05 15 long range attacks problem withadaptive proof work 2014 15 vitalik buterin proof stake faq https github com ethereum wiki wiki proof stakefaq 2016 16 ran canetti universally composable signature certification authentication 17th ieee computer security foundations workshop csfw 17 2004 28 30 june 2004 pacific grove usa page 219 ieee computer society 2004 17 ran canetti yevgeniy dodis rafael pass shabsi walfish universally composable security global setup salil p vadhan editor theory cryptography 4th theory cryptography conference tcc 2007 amsterdam netherlands february 21 24 2007 proceedings volume 4392 lecture notes computer science pages 61 85 springer 2007 18 ignacio cascudo bernardo david scrape scalable randomness attested public entities dieter gollmann atsuko miyaji hiroaki kikuchi editors applied cryptography network security 15th international conference acns 2017 kanazawa japan july 10 12 2017 proceedings volume 10355 lecture notes computer science pages 537 556 springer 2017 19 david chaum untraceable electronic mail return addresses digital pseudonyms commun acm 24 2 84 88 1981 20 david chaum dining cryptographers problem unconditional sender recipient untraceability j cryptology 1 1 65 75 1988 21 george danezis sarah meiklejohn centrally banked cryptocurrencies 23nd annual network distributed system security symposium ndss 2016 san diego california usa february 21 24 2016 internet society 2016 22 bernardo machado david peter gazi aggelos kiayias alexander russell ouroboros praos adaptively secure semi synchronous proof stake protocol iacr cryptology eprint archive 2017 573 2017 23 cynthia dwork nancy lynch larry j stockmeyer consensus presence partial synchrony j acm 35 2 288 323 1988 65 24 stefan dziembowski sebastian faust vladimir kolmogorov krzysztof pietrzak proofs space rosario gennaro matthew robshaw editors advances cryptology crypto 2015 35th annual cryptology conference santa barbara usa august 16 20 2015 proceedings ii volume 9216 lecture notes computer science pages 585 605 springer 2015 25 ittay eyal emin gun sirer majority bitcoin mining vulnerable angelos d keromytis editor financial cryptography volume 7397 lecture notes computer science springer 2014 26 paul feldman practical scheme non interactive verifiable secret sharing 28th annual symposium foundations computer science los angeles california usa 27 29 october 1987 pages 427 437 ieee computer society 1987 27 bryan ford delegative democracy http www brynosaurus com deleg deleg pdf 2002 28 juan garay aggelos kiayias nikos leonardos bitcoin backbone protocol analysis applications elisabeth oswald marc fischlin editors advances cryptology eurocrypt 2015 34th annual international conference theory applications cryptographic techniques sofia bulgaria april 26 30 2015 proceedings ii volume 9057 lecture notes computer science pages 281 310 springer 2015 29 charles m grinstead j laurie snell introduction probability american mathematical society 2nd edition 1997 30 aggelos kiayias giorgos panagiotakos speed security tradeoffs blockchain protocols cryptology eprint archive report 2015 1019 2015 http eprint iacr org 2015 1019 31 silvio micali algorand efficient democratic ledger corr abs 1607 01341 2016 32 tal moran ilan orlov proofs space time rational proofs storage cryptology eprint archive report 2016 035 2016 http eprint iacr org 2016 035 33 rajeev motwani prabhakar raghavan randomized algorithms cambridge university press new york ny usa 1995 34 satoshi nakamoto bitcoin peer peer electronic cash system http bitcoin org bitcoin pdf 2008 35 noam nisan tim roughgarden eva tardos vijay v vazirani algorithmic game theory cambridge university press new york ny usa 2007 36 karl j o dwyer david malone bitcoin mining energy footprint issc 2014 ciict 2014 limerick june 26 27 2014 37 sunoo park krzysztof pietrzak albert kwon jo el alwen georg fuchsbauer peter gazi spacemint cryptocurrency based proofs space iacr cryptology eprint archive 2015 528 2015 38 rafael pass cryptography game theory securty cryptography networks 2016 invited talk 2016 39 rafael pass lior seeman abhi shelat analysis blockchain protocol asynchronous networks iacr cryptology eprint archive 2016 454 2016 66 40 rafael pass elaine shi fruitchains fair blockchain iacr cryptology eprint archive 2016 916 2016 41 joseph poon thaddeus dryja bitcoin lightning network scalable chain instant payments https lightning network lightning network paper pdf january 2016 42 alexander russell cristopher moore aggelos kiayias saad quader forkable strings rare cryptology eprint archive report 2017 241 march 2017 http eprint iacr org 2017 241 43 ayelet sapirshtein yonatan sompolinsky aviv zohar optimal selfish mining strategies bitcoin corr abs 1507 06183 2015 44 berry schoenmakers simple publicly verifiable secret sharing scheme application electronic voting michael j wiener editor advances cryptology crypto 99 19th annual international cryptology conference santa barbara california usa august 15 19 1999 proceedings volume 1666 lecture notes computer science pages 148 164 springer 1999 remarks forkable strings divergence analysis paper demonstrates w 0 1 n forkable fact flat fork f w extra property f components non tines p q property non tine r f r p r q natural ask tines suffice flat fork f w union tines fact forkable strings require tines fork specifically consider string w 02k 1 k 1001 1k 0 2k flat fork shown figure 17 proves w forkable tines successfully fork w w 0 0 1 1 1 0 0 1 1 1 0 0 figure 17 fork f string w 02k1 k 1001 1k0 2k honest vertices highlighted double borders 67