b vite high performance asynchronous decentralized application platform chunming liu charles vite org daniel wang daniel loopring org ming wu woo vite org abstract vite generalised decentralized application platform meets requirements industrial applications high throughput low latency scalability taking account security vite uses dag ledger structure transactions ledgers grouped accounts snapshot chain structure vite lack security dag ledger hdpos consensus algorithm writing confirming transactions asynchronous provides high performance scalability vite vm compatible evm smart contract language extended solidity providing powerful ability description addition important improvement vite design adoption asynchronous event driven architecture transmits information messages smart contracts greatly improves system throughput scalability addition built native tokens vite supports users issue digital assets provides cross chain value transfer exchange based loopring protocol 1 vite realizes resource allocation quotas light users pay transaction fees vite supports contract scheduling service contract update block pruning features 1 introduction application large volume transmitted nodes nodes need transfer set transactions achieve consistency final state organize group transactions specific data structure usually referred ledgers 1 1 definition vite universal dapp platform support set smart contracts state machine independent state different operational logic definition 1 3 ledger ledger composed set communicate message delivery transactions abstract data type recursively conin general system transactional state machine structed defined follows state system s xe2 x88 x88 s known world state composed state independent account l xce x93 tt event causes changes account status called l l1 l2 transactions formalized definition follows tt xe2 x88 x88 2t representing set transactions xce x93 xe2 x88 x88 2t xe2 x86 x92 l represents function constructing book set transactions l set ledgers l xc3 x97l xe2 x86 x92 l representing operation merging sub ledgers definition 1 1 transactional state machine transactional state machine 4 tuple t s g xce xb4 t set transactions s set states g xe2 x88 x88 s initial state known genesis block xce xb4 s xc3 x97 t xe2 x86 x92 s state transition function semantics transactional state machine discrete transition system defined follows noted systems ledgers usually represent group transactions state bitcoin 2 ethereum 3 ledger definition 1 2 semantics transactional state machine block chain structure transactions globally semantics transactional state machine t s s0 xce xb4 ordered modify transaction ledger need discrete transition system s s0 xe2 x86 x92 xe2 x86 x92 xe2 x88 x88 s xc3 x97 s reconstruct sub ledger account book transition relationship increasing cost tampering transaction time decentralized application platform according group transactions different distributed system final consistency valid books constructed represent differconsensus algorithm final state reached ent order transactions cause system enter nodes realistic scenarios stored state different state happens usually called smart contracts set completed data decentralized xe2 x80 x9dfork xe2 x80 x9d 1 x0cdefinition 1 4 fork assume tt tt xe2 x80 xb2 xe2 x88 x88 2t tt xe2 x8a x86 tt xe2 x80 xb2 l xce x931 tt l xe2 x80 xb2 xce x932 tt xe2 x80 xb2 don xe2 x80 x99t meet l xe2 xaa xaf l xe2 x80 xb2 l l xe2 x80 xb2 fork legers xe2 xaa xaf represents prefix relitionship equivalent defining contract account receives state transition function xce xb4a evm widely platforms problems example lack library function support security according semantics transactional state problems machine easily prove initial state ledger structure ethereum block chain ledger forked node eventually enter 2 block chain blocks block contains state forked ledger received list transactions block refers hash certainly enter different state depends previous block form chain structure inherent logic transaction ledger ledgers organize partial orders transactions xce x93 t1 t2 t1 t2 xe2 x88 x88 t t1 t2 1 reality transactions satisfy commutative laws problem account greatest advantage structure effectively design frequently cause forks system starts prevent transactions tampered initial state receives forked ledgers ends maintains order transactions exchange state ledgers false forked transaction orders generate new ledger higher probability fork fact definition ledger state space transactional state machine regarded definition 1 5 false fork initial state s0 xe2 x88 x88 s ledger tree initial state root node different l1 l2 l1 l2 xe2 x88 x88 l s0 xe2 x86 x92 s1 s0 xe2 x86 x92 s2 l1 xcc xb8 l2 s1 s2 transaction order represents different paths leaf node final state reality state large number ledgers l1 l2 false fork ledgers leaf nodes leads large number designed ledger minimize probability false forks consensus algorithm xce xa6 called pow false fork proposed bitcoin protocol 2 pow algorithm relies fork occurs node needs choose mathematical problem easily verifiable multiple forked ledgers order ensure consisdifficult solve example based hash function tency state nodes need use algorithm h n xe2 x86 x92 n finding result x meet requirement complete selection algorithm called h t x xe2 x89 xa5 d dis given number called difficulty t consensus algorithm binary representation trade list contained definition 1 6 consensus algorithm consensus al block block block chain contains solution gorithm function receives set ledgers returns problems add difficulty blocks total difficulty block chain ledger ledger l xe2 x88 x91 xe2 x88 x91 xce xa6 2 xe2 x86 x92l d l d li d li 2 consensus algorithm important system design good consensus algorithm possess high choosing correct account convergence speed reduce sway consensus fork choose fork highest difficulty different forks high ability guard malicious attacks xce xa6 l1 l2 ln lm m arg max d li 3 xe2 x88 x881 n pow consensus algorithm better security running bitcoin ethereum ethereum 4 took lead realizing system main problems algorithm design ethereum definition world solve mathematical problem requires large state s xce xa3a mapping account xe2 x88 x88 computing resources resulting waste energy state account xcf x83a xe2 x88 x88 xce xa3 state second slow convergence speed algorithm state machine ethereum global means affecting system xe2 x80 x99s overall throughput present node achieve status account time tps ethereum 15 totally state transition function xce xb4 ethereum defined unable meet needs decentralized applications set program codes group code called smart contract ethereum defines turing complete 1 3 direction improvement virtual machine called evm instruction set called evm code users develop smart contracts birth ethereum ethereum community programming language solidity similar javascript similar projects began improve system compile evm code deploy ethereum different directions abstract model system 5 smart contract successfully deployed following directions improved 1 2 current progress 2 x0c xe2 x80 xa2 improving system state s xe2 x80 xa2 improving state transition function xce xb4 xe2 x80 xa2 improving structure ledger xce x93 xe2 x80 xa2 improving consensus algorithm xce xa6 1 3 1 improve state system main idea improving state system localize global state world node longer concerned transactions state transfers maintains subset state machine way potentials set s set t greatly reduced improving scalability system systems include cosmos 6 aelf 7 pchain essence chain based scheme sacrifices wholeness system state exchange scalability makes decentralization dapp running weakened transaction history smart contract longer saved node network node addition cross contract interaction bottleneck system example cosmos interactions different zone require common chain hub complete 6 figure 1 false fork shown l collection possible forked accounts set transactions s collection states reached different orders according definition 1 4 mapping f l xe2 x86 x92 s surjective according definition 1 5 mapping injective calculate probability false fork suppose c users right produce ledgers m l n s mi li li l f l si si xe2 x88 x88 s probability false fork follows c n xe2 x88 x91 mi 1 pf f 4 xe2 x88 x92 c xe2 x88 x921 m m 1 formula order reduce probability false fork ways 1 3 2 improve state transition function based improving evm projects provide abundant smart contract programming languages example smart contract language rholang defined rchain based xcf x80 calculus smart contract neo called neocontract developed popular programming languages java c etc eos programmed c c xe2 x80 xa2 xef xbf xbd establish equivalence relations l ledger set divide equivalence classes construct fewer forked ledgers xe2 x80 xa2 xef xbf xbd restrict users right produce ledgers reducing c way important direction vite design discussed detail later second ways adopted algorithms pow algorithm 1 3 3 improve ledger structure user right produce block pos improvement direction ledger structure algorithm limits power production block construction equivalent class linear ledger system rights dpos algorithm 11 limits user global order multiple transactions improved right produce block restricted nonlinear ledger records partial order relations group agent nodes nonlinear ledger structure dag directed acyclic present improved consensus algorithm graph present byteball 8 iota 9 nano 10 influential projects appeared example cardano uses projects realized function encrypting money pos algorithm called ouroboros literature 12 gives based dag xe2 x80 x99s account structure projects trying strict proof related characters algorithm use dag implement smart contracts far bft dpos algorithm eos 13 variant improvements direction explored dpos algorithm improves system throughput fast producing blocks qtum 14 xe2 x80 x99s consensus algorithm pos algorithm casper algorithm adopted rchain 1 3 4 improve consensus algorithm 15 pos algorithms improvement consensus algorithm imthere projects forward prove throughput system main direction proposals improving consensus algorithm neo 16 suppress generation false fork uses bft algorithm called dbft cosmos 6 uses discuss factors involved false fork algorithm called tendermint 17 3 x0c2 ledgers transactions possible order expand scope tampering t2 2 1 overview role ledgers determine order transactions order transactions affect following aspects xe2 x80 xa2 consistency status state system crdt conflict free replicated data types 18 transaction exchangeable sequence different transaction execution lead system entering different state xe2 x80 xa2 effectiveness hash ledger transaction packaged blocks contain hash referenced order transactions affects connectivity hash quoted ledgers greater scope impact greater cost tampering transactions change transaction rebuilt hash directly indirectly refers block transaction figure 3 ledger structure comparison obviously objectives contradictory necessary trade offs designing account structure account maintenance partial order transactions essentially partial ordered set poset 19 represented hasse diagram hasse diagram 20 dag topology picture compares common ledger structures ledgers near left maintained design ledger main objectives partial order hasse diagram appears flat lower false fork rate ledgers near right maintain partial order relationships hasse diagram slender tamper resistant picture left common set based structure centralization system tamper proofing features right typical blockchain ledger best tamper proof features dag ledgers block lattice account figure 2 ledger merge 10 nano left right tangle book 9 iota terms characteristics xe2 x80 xa2 reducing false fork rate discussed blocklattice maintains partial order relations previous section reduction false fork suitable accounting structure high performance rate achieved establishing equivalent decentralized application platforms poor class combining group accounts lead tampering characteristics expose security risks far system state single account projects adopt ledger structure nano shown according formula false order pursue high performance vite adopts fork rate false fork rate ledger dag ledger structure time introducing c 2 c 1 left pf f 35 5 xe2 x88 x92 5c xe2 x88 x921 merge additional chain structure snapshot chain improving ledger space false fork rate right graph consensus algorithm shortcomings block lattice c c 1 known c security successfully improvements pf f xe2 x80 xb2 23 13 xe2 x88 x92 3c xe2 x88 x921 xe2 x80 xb2 1 pf f pf f minimize discussed detail later partial ordering relationship transactions allow transactions exchanged sequentially 2 2 pre constraint xe2 x80 xa2 tamper proof transaction t modified ledger l sub ledgers book l l1 l2 sub ledger l1 affected hash references sub ledger l2 need rebuilt form new valid ledger l xe2 x80 xb2 l1 l2 xe2 x80 xb2 affected sub ledger l2 xce x93 t2 t2 x x xe2 x88 x88 t x t increase cost tampering transactions necessary maintain partial order relationship let xe2 x80 x99s look precondition ledger structure state machine model structure essentially combination entire state machine set independent state machines account corresponding independent state machine transaction affects state account ledger transactions grouped accounts organized chain transactions account 4 x0cfollowing restrictions state s transaction t vite way initial state final state t1 t2 s xe2 x80 xb2 different paths s0 xe2 x86 x92 s1 xe2 x86 x92 s xe2 x80 xb2 t2 t1 xe2 x80 xb2 s0 xe2 x86 x92 s2 xe2 x86 x92 s paths respectively passed intermediate state s1 s2 intermediate states mapping final state s xe2 x80 xb2 account dimensions words care state accounts need execute transactions correspond account need carry transactions accounts define split transactions ethereum single degree freedom transactions required vite definition 2 1 single degree freedom constraint system state s xe2 x88 x88 s vector s s1 s2 sn formed state si account xe2 x88 x80ti xe2 x88 x88 t performing transaction ti system state transfers follows s1 xe2 x80 xb2 si xe2 x80 xb2 sn xe2 x80 xb2 xcf x83 ti s1 si sn need meet sj xe2 x80 xb2 sj j xcc xb8 constraint called single degree freedom constraint transaction intuitively single degree freedom transaction change state account affecting status accounts system multidimensional space state space vector located transaction executed state system moves direction parallel coordinate axis note definition stringent transaction definition bitcoin ethereum models transaction bitcoin change state accounts sender recipient ethereum change state accounts message constraint relationship transactions simplified transaction orthogonal parallel provides conditions grouping transactions according accounts example illustrate definition 2 2 transaction decomposition dividing transaction degree freedom greater 1 set single degree freedom transactions named transaction decomposition transfer transaction split sending transaction receiving transaction contract transaction split contract request transaction contract response transaction message contract split contract request transaction contractual response transaction different types transactions ledgers called xe2 x80 x9dtrading pairs xe2 x80 x9d definition 2 3 trading pair sending transaction contract request transaction collectively referred xe2 x80 x9drequest transaction xe2 x80 x9d receiving transaction contract response transaction collectively referred xe2 x80 x9dresponse transaction xe2 x80 x9d request transaction corresponding response transaction called transaction pairs account initiating request transaction t recorded t corresponding response transaction recorded e t account corresponding transaction recorded e t based definition conclude possible relationship transactions vite figure 4 single degree freedom trading intermediate definition 2 4 transaction relationship exist following relations transactions t1 state t2 orthogonality t1 xcc xb8 t2 transactions shown figure suppose alice bob 10 usd respectively initial state system orthogonal recorded ast1 xe2 x8a xa5 t2 parallel t1 t2 transactions s0 10 10 alice wants transfer 2 usd bob model bitcoin ethereum transactiont xe2 x80 xb2 parallel recorded t1 xe2 x88 xa5 t2 t xe2 x80 xb2 causality t2 te1 transactions system directly final state s0 xe2 x86 x92 s xe2 x80 xb2 definition vite transaction t xe2 x80 xb2 changed causal recorded t1 xe2 x96 xb7 t2 t2 xe2 x97 x81 t1 status accounts alice bob conform principle single degree freedom transaction split transactions 1 transaction t1 represents transferring 2 usd alice 2 transaction t2 represents receiving 2 usd bob 2 3 definition ledger define ledger define poset let xe2 x80 x99s define partial ordering relationship transactions vite definition 2 5 partial order transactions use dualistic relationship represent partial order relation transactions 5 x0ca response transaction follow corresponding request transaction t1 t2 xe2 x87 x94 t1 xe2 x96 xb7 t2 transactions account strictly globally ordered xe2 x88 x80t1 xe2 x88 xa5 t2 t1 t2 t2 t1 blockchain structure node receives longer forked chain new fork selected consensus result original fork abandoned transaction original fork rolled system transaction rollback event lead double spend imagine business receives payment provides goods services payment withdrawn merchant face losses user receives payment transaction needs wait system xe2 x80 x9dconfirm xe2 x80 x9d transaction ensure probability rolling low partial ordering relationship established transaction set t meet characteristics xe2 x80 xa2 irreflexive xe2 x88 x80t xe2 x88 x88 t t t xe2 x80 xa2 transitive xe2 x88 x80t1 t2 t3 xe2 x88 x88 t t1 t2 t2 t3 t1 t 3 xe2 x80 xa2 asymmetric xe2 x88 x80t1 t2 xe2 x88 x88 t t1 t2 doesn xe2 x80 x99t exist t2 t 1 definition 3 1 transaction confirmation probability transaction rolled given threshold xcf xb5 transaction called confirmed pr t xcf xb5 xe2 x87 x94 t conf irmed way define vite account strict partial order set confirmation transactions confusing concept transaction recognized depends fact implicit confidence level 1 xe2 x88 x92 xcf xb5 merchant selling diamonds coffee seller suffered different losses attacked double spend result needs set smaller xcf xb5 transaction essence number confirmations bitcoin bitcoin confirmation number indicates depth transaction block chain greater number confirmations lower probability transaction rolled 2 merchants indirectly set confidence level confirmation setting waiting number confirmation numbers probability transaction rollback decreases time hash reference relationship account structure mentioned design ledger better tampering characteristics rolling transaction needs reconstruct subsequent blocks exchange block new transactions constantly figure 5 relationship ledger added ledgers successive transaction vite nodes transaction probability tampered decrease strict poset correspond dag structure block lattice structure transaction shown figure circles represent transactions grouped account transaction attached arrows denote dependencies transactions xe2 x86 x92 b end account chain account indicates depends b transaction generated accounts vite ledger defined structurally similar automatically successor node transaction block lattice transactions divided request necessary design consensus algorithm response transactions corresponds reasonably avoid hidden dangers double spend separate block account ai corresponds chain nano adopts voting based consensus algorithm 10 transaction pair response transaction referencing transaction signed set representative nodes selected hash corresponding request transaction group users representative node weight signature transaction weight believed transaction confirmed 3 snapshot chain following problems algorithm higher confidence degree confirmation 3 1 transaction confirmation needed threshold voting weight needs raised account forked result consensus representative nodes online swing forked ledgers example based intersecting speed guaranteed possible definition 2 6 vite ledger vite ledger thestrict poset composed set t given transaction partial poset 6 x0cthat user collect number tickets necessary confirm exchange second probability transactions rolled decrease time time cost overthrowing historical voting finally historical voting results persisted ledger stored local storage nodes node gets account nodes way reliably quantify probability historical transaction rolled essence voting mechanism partial centralization solution regard voting results snapshot status ledgers snapshot distributed local storage node network order tamper proof ability block chain organize snapshots chain structures kernel vite design snapshot chain 21 order support multiple tokens time structure recording balance information vite xe2 x80 x99s account state uint256 mapping token id balance snapshot block snapshot chain called xe2 x80 x9dgenesis snapshot xe2 x80 x9d saves snapshots genesis block account 3 2 definition snapshot chain snapshot chain important storage structure vite main function maintain consensus vite ledgers definition snapshot chain figure 6 snapshot chain snapshot block snapshot chain corresponds fork vite ledger possible determine consensus result vite ledger snapshot block snapshot block fork snapshot block definition 3 2 snapshot block snapshot chain snapshot block stores state snapshot vite ledger including balance account merkle root contract state hash block account chain snapshot chain chain structure composed snapshot blocks snapshot block refers hash previous snapshot block 3 3 state user account contains balance hash block account chain addition fields state contract account contains merkle root hash structure state account follows snapshot chain transaction confirmation introducing snapshot chain natural security flaws block lattice structure remedied attacker wants generate double spend transaction addition rebuilding hash reference vite ledger needs rebuilt snapshot chain blocks snapshot block transaction need produce longer snapshot chain way cost attack greatly increased vite confirmation mechanism transactions similar bitcoin defined follows struct accountstate account balance map uint32 uint256 balances merkle root contract state optional uint256 storageroot hash transaction account chain uint256 lasttransaction definition 3 3 transaction confirmation vite vite transaction snapshot snapshot chain transaction confirmed depth snapshot block structure snapshot block defined follows snapshot called confirmation number transaction struct snapshotblock hash previous block definition number confirmed transuint256 prevhash actions increase 1 snapshot chain grows snapshot information probability double spend attack decreases map address accountstate snapshot increase snapshot chain way users signature customize required confirmation number waiting uint256 signature different confirmation numbers according specific scenario 7 x0cthe snapshot chain relies consensus algorithm 4 consensus snapshot chain forked longest fork chosen valid fork snapshot chain switched 4 1 goal design new fork original snapshot information rolled designing consensus protocol need means original consensus ledger account following factors overthrown replaced new consensus snapshot chain cornerstone system xe2 x80 xa2 performance primary goal vite fast security needs treated seriously ensure high throughput low delay performance system need adopt consensus algorithm higher convergence speed 3 4 compressed storage xe2 x80 xa2 scalability vite public platform open decentralized applications scalability important consideration account states need saved snapshot block snapshot chain storage space large compression snapshot chains necessary xe2 x80 xa2 security design principle vite pursuing ultimate safety needs ensure safety base line effectively guard kinds attacks compared existing consensus algorithms security pow better consensus reached computing power malicious nodes 50% intersecting speed pow slow meet performance requirements pos variant algorithms remove steps solve mathematical problems improve intersecting speed single attack cost reduce energy consumption scalability pos poor xe2 x80 x9cnothing stake xe2 x80 x9d problem 22 difficult solve bft algorithms better performance figure 7 snapshot compression security performance scalability problem usually suitable private chain consortium chain basic approach compressing snapshot chain stor dpos 11 series algorithm effectively reduces probaage space use incremental storage snapshot block bility false fork limiting permissions generating stores data changed compared previous blocks performance scalability good snapshot block transaction account consequence dpos slight sacrifice security snapshots snapshot block number malicious nodes 1 3 23 save data account generally dpos algorithm obvious advantages recover snapshot information traverse performance scalability choose dpos snapshot block beginning end cover basis vite consensus protocol expand data snapshot block current data properly basis hierarchical delegated consensus protocol asynchronous model overall snapshot 1 snapshot 2 snapshot 3 performance platform improved 1 s1 1 s1 xe2 x80 xb2 2 s2 3 s3 a2 s2 xe2 x80 xb2 xe2 x80 xb2 4 2 figure 8 snapshot compression hierarchical consensus consensus protocol vite hdpos hierarchical delegated proof stake basic idea decompose consensus function xce xa6 functional decomposition final status snapshot account saved snapshotting intermediate state taken account copy data xce xa6 l1 l2 ln xce xa8 xce x9b1 l1 l2 ln snapshot saved matter transac xce x9b2 l1 l2 ln 5 tions generated account snapshots snapshot block takes s xe2 x88 x97 bytes xce x9bm l1 l2 ln maximum s sizeof si number xce x9bi 2l xe2 x86 x92 l called local consensus function bytes occupied account state total number system accounts average ratio active returned result called local consensus xce xa8 2l xe2 x86 x92 l accounts total accounts compression rate 1 xe2 x88 x92a known global consensus function selects unique 8 x0cresult group candidate local consensus final consensus result separation consensus system independent processes 4 3 2 private consensus group private consensus group applicable production transaction blocks ledgers belongs account chain private consensus group blocks local consensus generate blocks corresponding produced owner private key quest transactions response transaction account default user accounts belong private user account contract account writes consensus group ledgers greatest advantage private consensus group reduce probability fork user global consensus snapshots data ledger generhas right produce blocks possibility fork ates snapshot blocks ledger forked choose user initiate double spend attack personally program error disadvantage private consensus group 4 3 right block generation consen user nodes online pack sus group transaction suitable contract account owner xe2 x80 x99s node fails node right generate transaction block replace response transaction produces contracts ledger snapshot block snapshot chain equivalent reducing service availability consensus algorithm adopted reach consensus dapp ledger structure vite organized multiple account chains according different accounts conveniently define right production blocks 4 3 3 delegate consensus group ledger according dimension account production right snapshot block belong delegate consensus group instead user account single group users way number set designated proxy nodes package transaccount chains snapshot chains consensus group action dpos algorithm user accounts consensus group use unified way contractual accounts added consensus group users set set separate agent nodes produce block reach consensus establish new consensus group default definition 4 1 consensus group consensus group consensus group vite help package transactions tuple l u xce xa6 p describing consensus mechanism accounts haven xe2 x80 x99t established delegate portion account snapshot chain l xe2 x88 x88 consensus group individually known represents number account chains snapshot public consensus group chains consensus group ledger u represents delegate consensus group suitable user block production right chain specified contract accounts transactions l xce xa6 specifies consensus algorithm consensus contract account contract response transactions group p specifies parameters consensus higher availability lower delays needed algorithm receivable transactions user account definition users set consensus groups flexibly select different consensus parameters needs elaborate different consensus groups 4 4 priority consensus vite protocol priority global consensus higher local consensus local con4 3 1 consensus group snapshot sensus forked result global consensus selection consensus group snapshot chains called snapshot prevail words global consensus selected consensus group important consensus fork local consensus final result longer group vite consensus algorithm xce xa6 snapshot con fork certain account chain future accounts occurs sensus group adopts dpos algorithm corresponding cause roll global consensus results xce xa8 hierarchical model number agents problem needs attention implementing interval block generation specified cross chain protocol target chain roll parameter p corresponding account chain relay contract example specify snapshot consensus groups mapping chain needs roll accordingly 25 proxy nodes produce snapshot blocks intervals moment local consensus relay chain 1 second ensures transaction confirmed adopted global consensus impossible fast achieving 10 times transaction confirma complete rollback cause data tion need wait 10 seconds maximum relay contract target chain inconsistent 9 x0cthe way avoid problem set parameter delay transaction constant rate fully utilized consensus group parameter p specifies platform resources improve system xe2 x80 x99s throughput snapshot consensus group snapshot local consensus completed delay blocks greatly reduce probability inconsistency relay contracts 5 virtual machine xe2 x80 x99t avoided completely code logic relay contracts necessary deal rollback 5 1 evm compatibility target chain separately present developers ethereum field smart contracts applied based solidity 4 5 asynchronous model evm decided provide evm compatibility order improve system throughput need vite virtual machine original semantics support perfect asynchronous model evm instruction sets kept vite vite xe2 x80 x99s account structure transaction definition differconsensus mechanism life cycle transaction includes transaction initi ent ethereum semantics evm instructions ation transaction writing transaction confirmation need redefined example set instructions order improve performance system need block information detailed semantic differences design steps asynchronous mode referred appendix biggest difference semantics different times quantity transactions message calls discuss detail initiated users different speed transaction writing transaction confirmation processed system fixed relatively asynchronous mode helps flatten peaks troughs improve overall throughput system asynchronous model bitcoin ethereum simple transaction initiated users placed unconfirmed pool miner packages block transaction written confirmed time block chain continues grow transaction eventually reaches preset confirmation confidence level problems asynchronous model 5 2 event driven protocol ethereum transaction message affect status multiple accounts example contract invocation transaction cause status multiple contract accounts change time message calls changes occur time transaction ethereum actually kind rigid transaction satisfies characteristics acid atomicity consistency isolation durability 24 important reason lack expansibility ethereum xe2 x80 xa2 xef xbf xbd transactions persisted ledgers unconbased considerations scalability performance firmed state unrecognized transactions unstable vite adopted final consistency scheme satisfying base consensus involved xe2 x80 x99t prevent basically available soft state eventual consistency 25 sending transactions repeatedly semantics specifically design vite event driven architecture eda 26 smart contract considered xe2 x80 xa2 xef xbf xbd asynchronous mechanism writing independent service messages commuand confirming transactions transactions nicated contracts state shared written confirmed speed writing evm vite need cancel restricted confirmation speed semantics synchronous function calls contracts vite protocol establishes improved asyn allow message communication contracts chronous model transaction split trans evm instructions affected mainly action pair based xe2 x80 x9drequest response xe2 x80 x9d model staticcall vite evm instructions xe2 x80 x99t transfer contract transaction executed immediately return result successfully launched request transaction written generate request transaction write ledger addition written confirming ledger vite semantics function transaction asynchronous transactions calls included instruction sends written dag account vite firstly messages account blocked confirmation process transaction confirmation snapshot chain snapshot 5 3 smart contract language action asynchronous typical producer consumer model ethereum provides turing complete programming lanlife cycle transaction matter production rate guage solidity developing smart contracts support changes upstream downstream deal asynchronous semantics extended solidity defined 10 x0ca set syntax message communication extended solidity called solidity syntax solidity supported solidity including function calls outside contract developer define messages keyword message define message processor messagehandler keyword implement cross contract communication function example contract needs add method contract b update state based return value solidity implemented function code follows contract uint total function invoker address addr uint uint b message b send addr add b sending message return value sum return data message uint sum msg data sum use return data sum 10 total sum pragma solidity 0 4 0 contract b function add uint uint b returns uint ret return b contract uint total line code pragma solidity 0 xcc x82 1 0 indicates source code written solidity compiled directly solidity compiler function invoker address addr uint avoid compiled evm code conform uint b expected semantics vite provide specialized compiler message add compiling solidity compiler partially forward uint sum b addr add b compatible solidity code conflict use return value vite semantics compiled directly sum 10 error reported example syntax total sum local function calls transfers accounts remain compatible obtaining return value cross contract function monetary unit ether compiled contract invoker function called solidity function codeuint sum b addr add b longer valid instead add message sent contract b contract contract b communicate asynchronously asynchronous result returned immediately necessary define message processor sending messages code follows keyword receive returned result update state pragma solidity 0 1 0 contract b message add monitored processing sum message sent sender contract b message add return result message add uint uint b messages solidity compiled message sum uint sum instructions request transaction added add ledger vite ledgers serve message middleware read message asynchronous communication contracts enuint msg data sures reliable storage messages prevents duplication uint b msg data b multiple messages sent contract contract address sender msg sender guarantee fifo messages sent different contracts contract guarantee things uint sum b fifo send message return result noted events solidity event send sender sum sum messages solidity concept events sent indirectly evm log 11 x0c5 4 standard library snapshot chain key security performance vite platform order incite node developers develop smart contracts ethereum participate transaction verification vite protocol plagued lack standard libraries solidity sets forging reward production snapshot example loop verification loopring protocol block performed outside chain important reasons contrary users issue new tokens deploy floating point computing function provided contracts register vns domain names 1 obtain resource solidity especially n square root 1 1 floating quotas need consume mortgage vitetoken numbers combined action factors evm pre deployed contract called conducive optimizing allocation system resources delegatecall command realize function library function ethereum provides precompiled contract mainly hash operations 6 2 resource allocation functions simple meet complex application vite common dapp platform capabilities needs smart contracts deployed vary different provide series standard libraries smart contract different requirements throughput solidity string processing floating point oper delay smart contract performance ations basic mathematical operations containers sorting requirements different stages different design ethereum transaction needs based performance considerations standard assigned gas price launching compete libraries implemented local extension native transactions write accounts typical extension way operations built bidding model effectively control balance vite local code function called supply demand principle user delegatecall instruction evm code difficult quantify current supply demand standard library extended needed situation predict price combecause state machine model system petitors market failure occurs easily deterministic provide functions like random resources competing bid directed numbers similar ethereum simulate pseudo transaction agreement rational random numbers hash snapshot chains allocation resources according account dimension 5 5 gas 6 2 1 quota calculation main functions gas ethereum quantify computing resources storage resources consumed evm code execution second ensure evm code halted according computability theory halting problem turing machines incomputable problem 27 means impossible determine smart contract stopped limited execution analyzing evm code gas calculation evm retained vite gas price concept vite users buy gas exchange paying fees quota based model obtain computing resources calculation quotas discussed detail later chapter xe2 x80 x9deconomic model xe2 x80 x9d adopted quota based resource allocation protocol vite allows users obtain higher resource quotas ways xe2 x80 xa2 pow calculated transaction initiated xe2 x80 xa2 mortgage certain vite account xe2 x80 xa2 destroy small vite time specific quotas calculated following formula 2 q qm xc2 xb7 xe2 x88 x921 6 1 exp xe2 x88 x92 xcf x81 xc3 x97 xce xbe xe2 x8a xa4 qm constant representing upper limit single account quota related total throughput system total number accounts xce xbe xce xbed xce xbes xce xbef vector represents cost 6 economic model user obtaining resource xce xbed pow difficulty user calculates generating transaction xce xbes 6 1 native token vite balance mortgage account xce xbef order quantify platform computing storage time cost user willing pay sources encourage nodes run vite built native increase quota noted xce xbef different token vitetoken basic unit token vite smallest handling fee vite destroyed directly unit attov xe2 x80 x9e1 vite 1018 attov instead paid miners 1 refer 7 2 naming service 12 x0cin formula vector xcf x81 xcf x81d xcf x81s xcf x81f represents weight way obtaining quota quota obtained destruction 1 vite equivalent mortgaged xcf x81s xcf x81f vite seen formula user mortgages vite pays time cost necessary calculate pow quotas initiate transaction effectively prevent dust attacks protect system resources abused time formula logistic function relatively easy users lower quotas reducing threshold low frequency users high frequency users need invest lot resources order obtain higher quotas extra costs pay increase benefits users recent k transactions account chain height xe2 x80 x9dn xe2 x80 x9d costk tn xe2 x88 x91n k xc2 xb7 n xe2 x88 x92k 1 gasi timestampn xe2 x88 x92 timestampn xe2 x88 x92k 1 1 7 transaction tn timestampn timestamp transaction height snapshot block refers gasn fuel consumed transaction verifying transaction node determine quota satisfies condition cost t xe2 x89 xa4 q satisfied transaction rejected case users need repackage transaction increase quotas paying time fee wait period time quote higher snapshot transaction 6 2 2 resource quantification snapshot chain equivalent global clock use quantify resource usage account accurately transaction hash snapshot block quoted height snapshot block took timestamp transaction according difference transaction timestamps judge interval transactions long 6 2 3 quota lease user holds abundant vite assets need utilize resource quotas choose rent quota users vite system supports special type transaction transfer right use account resource quota transaction number vite mortgaged address transferee duration lease specified transaction confirmed resource quota corresponding token included assignee xe2 x80 x99s account lease time exceeded quota calculated transferor account unit leasing time second system converted height difference snapshot block deviation leasing income obtained user vite system provides quota transfer transaction pricing payment leasing achieved party smart contract 6 3 asset issurance addition native token vitetoken vite supports users issue tokens issue tokens special transaction mint transaction target address mint transaction 0 field data transaction parameters token specified follows figure 9 snapshot chain global clock mint shown account generated 4 transactions mytoken 2 time intervals account b generated 2 totalsupply 99999999900000000000000000 transactions average tps period decimals 18 2 times b xe2 x80 x99s transfer transaction owner 0xa3c1f4 fa average tps quantified account symbol myt smart contracts exchange different consumption resources necessary accumulate gas transaction calculate average resource consumption request accepted network vite period time average resource consumption included mint transaction deducted 13 x0cinitiator account mint transaction fee system records information new token assigns token id balances newly generated tokens added owner address owner account genesis account token 6 4 cross chain protocol order support cross chain value transfer digital assets eliminate xe2 x80 x9dvalue island xe2 x80 x9d vite designed vite crosschain transfer protocol vctp asset needs cross chain transmission target chain token corresponds needed vite voucher target token circulating vite called tot token token example want transfer ether ethereum account vite issue tot identifier eth vite initial quantity tot equal total quantity ether target chain gateway contract vite maintain mapping relationship vite transactions target chain transactions consensus group contract located node responsible generating blocks called vctp relay vctp relay needs vite node node target chain time listen transactions sides target chain need deploy vite gateway contract vctp relay starts work corresponding tot vite transferred gateway contract supply tot controlled gateway contract added ensure 1 1 exchange ratio tot target asset time assets target chain controlled vite gateway contract user use ensure tot acceptance reserve picture example cross chain value transmission vite ethereum ethereum user e1 wants transfer token ethereum vite send transaction vite gateway contract address v user xe2 x80 x99s address vite placed parameter balance transfer locked gateway contract account tot reserve listening transaction vctp relay node generates corresponding account sending transaction vite sending tot user xe2 x80 x99s account vite 1 xe2 x83 x9d 2 respectively indicate e1 e2 picture xe2 x83 x9d transfer vite account b noted user specify vite address transferring contract reject transaction 3 user reverse flow shown xe2 x83 x9d launches transfering vite account ethereum account transaction sent vite gateway contract transfers certain quantity tot specifies reception address e1 ethereum transaction vctp relay node generate corresponding response block ethereum gateway contract package transaction ethereum vite gateway contract ethereum ethereum vite gateway contract verify transaction initiated trusted vctp relay ether transferred vite gateway contract target account e1 cross chain relay nodes monitor target network verify cross chain transaction correct reach consensus consensus group snapshot consensus group monitor transaction target chain verify mapping chains correct target network rolled hard forked mapped transactions vite system rolled similarly cross chain transactions vite rolled corresponding transaction target network rolled time cross chain transactions necessary deal transaction rollback contract logic time described 4 4 need set delay parameter cross chain relay consensus group 6 5 loopring protocol loopring protocol 1 open protocol build decentralized asset trading network compared dex solutions loopring protocol based multiparty loop matching provides dual authorization technology prevent preemptive transactions fully open build loopring protocol vite conducive promoting circulation digital assets vite value system circulated value system users issue digital assets transfer assets outside chain vctp use figure 10 cross chain protocol 14 x0cthe loopring protocol achieve asset exchange process completed vite system completely decentralized vite loopring protocol smart contract lpsc vite system asset transfer authorization multi party atomic protection supported vite loopring relay open fully integrate ecosystem users use vite pay asset exchange transactions earned token miners looping perform loop matching vite platform vite names organized form domain names vite myname mycontract level domain retained system specific purposes example vite xx represents vite address eth xx represents ethereum address second level domain open users user owns second level domain subdomain expanded arbitrarily domain owner modify address directed domain time function contract upgrading length domain restricted vns hash domain actually stored target address non vite address 256 bit 7 designs cross chain interaction noted vns different smart 7 1 scheduling contract package specification eip1903 ethereum vns ethereum smart contracts driven transactions resolution service established execution contracts triggered runtime resolution rules dynamically modiusers initiating transaction applications timing fied eip190 package management specification scheduling function needed trigger execution namespace static established compile time contract clock ethereum function achieved 7 3 contract update party contracts 1 performance security guarthe smart contract ethereum immutable anteed vite add timing scheduling function deployed modified bug built contract users register scheduling contract updated unfriendly logic timed scheduling contract public consento developers makes dapp xe2 x80 x99s continuous iteration sus group use snapshot chain clock send difficult vite needs provide scheme request transaction target contract according support smart contract update user defined scheduling logic vite process contract updating includes specialized timer message solidity deploys new version contract inherit users set scheduling logic contract status original contract code timer 7 2 service b points contract new address vns ethereum contract generate address identify contract deployed problems identifying contracts addresses c removes old contract selfdestruct instruction steps need completed time vite protocol ensures atomicity operation developers need ensure old contract data correctly processed new version contract noted new contract inherit xe2 x80 xa2 xef xbf xbd contracts addresses address old contract quoted address support contract redirection transaction sent old contract order solve problems developer different versions contracts essentially ethereum provided party contract ens 2 completely different contracts modified actual scenario use naming services dynamically depending semantics contracts frequent use party contracts vite systems smart contracts actually divided guarantee global uniqueness naming types background dapp build service vns vitename service vite business logic described second kind users register set names easy remem contract maps real world previous ber resolve actual address vns equivalent application xe2 x80 x99s background service xe2 x80 xa2 xef xbf xbd address identifier 20 bytes meaning unfriendly users inconvenient use 1 ethereum alarm clock party contract schedule execution contracts refer http www ethereum alarm clock com 2 ethereum service party contract resoluton refer https ens domains 3 eip190 ethereum smart contract packaging specification refer https github com ethereum eips issues 190 15 x0cneeds continuously iterated upgrade xe2 x80 xa2 inquire history node needs query equivalent contract comes transaction history transaction involved effect modification breach query tailored contract contract allowed according different usage scenarios node modified decorated keyword static choose combinations clipping stratsolidity example egy important note clipping involves transactions ledgers snapshot chains need kept intact pragma solidity 0 1 0 addition recorded snapshot chain hash contract state account clipped static contract pledge corresponding state snapshot needs kept intact contract change order ensure integrity vite data need retain xe2 x80 x9dfull nodes xe2 x80 x9d network save transaction data snapshot consensus group nodes 7 4 block pruning nodes addition important users exchanges ledger transaction immutable users nodes add new transactions ledger altering deleting historical transactions operation 8 governance system ledgers bigger bigger new node joining network wants restore decentralized application platform efficient goverlatest status starting genesis block redoing nance system essential maintaining healthy ecosysall historical transactions running system tem efficiency fairness considered period time space occupied account designing governance systems book time consumed redoing transactions governance system vite divided parts unacceptable high throughput system chain chain chain voting mechanism vite rate growth higher bitcoin based protocol chain iteration ethereum necessary provide technique protocol clipping blocks ledgers voting mechanism divided types block clipping refers deletion historical transac global voting local voting global voting based tions ledgers affect vite held user calculate rights voting operation transactional state machine weight global voting mainly election transactions safely deleted depends snapshot consensus group proxy node local vote scenario transaction including aimed contract contract deployed token designated basis voting elect agent nodes consensus group contract located verification transactions agent node snapshot consensus group right choose upgrade vite system incompatibility delegated consensus group proxy node right decide allow contract upgraded avoid potential risks arising escalation contracts agent node upgrade decision making power behalf users order improve efficiency decision making avoid failure decision making insufficient participation voting proxy nodes restricted consensus protocol 1 agent nodes passed upgrade effect agents fulfill decision making power according user xe2 x80 x99s expectations users cancel proxy qualification voting governance chain realized community vite community participant propose improvement plan vite protocol related systems called vep vite enhancement proposal vep xe2 x80 xa2 recovery primary role transaction recover status vite snapshot chain stores snapshot information account status nodes recover state snapshot block transactions lasttransaction snapshot block tailored state recovery xe2 x80 xa2 verification transactions verify new transaction needs verify exchange xe2 x80 x99s previous transaction account chain response transaction needs verify corresponding request transaction tailored accounting ledgers transaction retained account chain addition open request transactions tailored hashes referenced subsequent response transactions xe2 x80 xa2 calculate quotas transaction meets quota calculated judging sliding average 10 transaction resources 9 transactions need saved account chain 1 according dpos protocol valid majority 2 3 total agent nodes 16 x0ccan widely discussed community implement solution decided vite ecological participants protocol upgraded implementation vep ultimately decided agent node course differences large start round voting chain collect wide range user opinions proxy node decide upgrade according result vote vite participants vite tokens vote opinions freely submit vep fully express views users right vote account health ecology vite rights views ecological participants seriously 9 tasks future transaction verification snapshot chains major performance bottleneck system vite adopts asynchronous design dag account structure transaction validation executed parallel dependence transactions different accounts degree parallelism greatly restricted improve parallelism transaction verification adopt distributed verification strategy important direction future optimization shortcomings exist current hdpos consensus algorithm optimization direction improve consensus algorithm compatible consensus algorithms delegated consensus group addition optimization virtual machine important reducing system delay improving system throughput simple design evm simplification instruction set necessary design powerful virtual machine future define smart contract programming language ability describe security vulnerabilities finally vite core agreement construction ancillary facilities supporting ecological development important topic addition sdk support dapp developers work dapp foreground ecosystem construction example build dapplet engine based html5 mobile wallet application vite allowing developers develop publish dapp low cost 10 summary xe2 x80 xa2 high throughput vite uses dag ledger structure orthogonal transaction written parallel book addition multiple conconsensus groups depend hdpos consensus algorithm work parallel important thing vite xe2 x80 x99s inter contract communication based asynchronous model message helpful improve throughput system xe2 x80 xa2 low delay vite uses hdpos consensus algorithm collaborate complete rotation production block proxy node need calculate pow block interval reduced 1 second beneficial reduce delay transaction confirmation xe2 x80 xa2 scalability order meet scalability requirements vite makes single degree freedom limit transaction grouping transactions account according account dimension allowing block production different accounts completed different nodes remove acid semantics cross contract calls base semantics based message way nodes longer need save state world data saved entire distributed network sharding mode xe2 x80 xa2 usability improvements vite xe2 x80 x99s usability include providing standard library support solidity dedicated processing message syntax timing scheduling contract vns naming services support contract upgrading xe2 x80 xa2 value circulation vite supports digital asset issuance cross chain value transfer token exchange based loopring protocol forming complete value system user xe2 x80 x99s point view vite fully functional decentralized exchange xe2 x80 xa2 economy vite adopts quota based resource allocation model lightweight users trade frequently pay high fees gas charges users choose variety ways change calculation extra quota transferred users quota leasing agreement improve efficiency system resource utilization 11 thanks sincerely like thank consultants guidance assistance article especially like appreciate contribution loopring team loopring community project compared similar projects characteristics vite include 17 x0creferences 1 daniel wang jay zhou alex wang matthew finestone loopring decentralized token exchange protocol url https github com loopring whitepaper blob master en whitepaper pdf 2 satoshi nakamoto bitcoin peer peer electronic cash system 2008 3 gavin wood ethereum secure decentralised generalised transaction ledger ethereum project yellow paper 151 2014 4 vitalik buterin ethereum generation smart contract decentralized application platform 2013 url http ethereum org ethereum html 2017 5 chris dannen introducing ethereum solidity springer 2017 6 jae kwon ethan buchman cosmos network distributed ledgers url https cosmos network whitepaper 7 anonymous aelf multi chain parallel https grid hoopox com aelf whitepaper en pdf 2018 8 anton churyumov byteball https byteball org byteball pdf computing blockchain framework decentralized system storage transfer value url url 9 serguei popov tangle url https iota org iota whitepaper pdf 10 colin lemahieu raiblocks feeless distributed https raiblocks net media raiblocks whitepaper english pdf cryptocurrency network 11 anonymous delegated proof stake consensus robust flexible consensus protocol https bitshares org technology delegated proof stake consensus url url 12 bernardo david peter gazi aggelos kiayias alexander russell ouroboros praos adaptively secure semisynchronous proof stake blockchain url https eprint iacr org 2017 573 pdf 2017 13 anonymous eos io technical white paper v2 url https github com eosio documentation blob master technicalwhitepa 14 dai patrick neil mahi jordan earls alex norta smart contract value transfer protocols distributed mobile application platform url https qtum org uploads files cf6d69348ca50dd985b60425ccf282f3 pdf 2017 15 ed eykholt lucius meredith joseph denman architecture readthedocs io en latest rchain platform architecture 16 anonymous neo white paper distributed network smart economy index html 17 anonymous byzantine consensus algorithm consensus algorithm url http rchain url http docs neo org en url https github com tendermint tendermint wiki byzantine 18 shapiro marc nuno pregui xc3 xa7a carlos baquero marek zawirski conflict free replicated data types url https hal inria fr inria 00609399v1 2011 19 deshpande jayant v continuity partial order proc amer math soc 19 1968 383 386 1968 20 weisstein eric w hasse diagram url http mathworld wolfram com hassediagram html 21 chunming liu snapshot chain improvement block lattice https medium com chunming vite snapshot chain improvement block lattice 561aaabd1a2b url 22 anonymous problems url https github com ethereum wiki wiki problems 23 dantheman dpos consensus algorithm missing white paper url https steemit com dpos dantheman dposconsensus algorithm missing white paper 24 theo haerder andreas reuter principles transaction oriented database recovery acm comput surv 15 4 287 xe2 x80 x93317 december 1983 18 x0c 25 dan pritchett base acid alternative queue 6 3 48 xe2 x80 x9355 2008 26 jeff hanson event driven services soa services soa html url https www javaworld com article 2072262 soa event driven 27 michael sipser introduction theory computation pws publishing second edition 2006 appendices appendix evm instruction set 0 1 0s stop algebraic operation instruction set words pop push semantics evm semantics vite 0x00 stop 0 0 stop excute sanme semantics 0x01 add 2 1 add operands semantics 0x02 mul 2 1 multiplying operands semantics 0x03 sub 2 1 subtracting operands semantics 0x04 div 2 1 divide operands divisor 0 returns 0 semantics 0x05 sdiv 2 1 divided symbol semantics 0x06 mod 2 1 modulus operation semantics 0x07 smod 2 1 modulus symbol semantics 0x08 addmod 3 1 add operands module 3rd semantics 0x09 mulmod 3 1 mmultiply operands module 3rd semantics 0x0a exp 2 1 square operands semantics 0x0b signextend 2 1 symbol extension semantics 19 x0ca 0 2 10s comparison bit operation instruction set words pop push semantics evm semantics vite 0x10 lt 2 1 semantics 0x11 gt 2 1 greater semantics 0x12 slt 2 1 symbol semantics 0x13 sgt 2 1 greater symbol semantics 0x14 eq 2 1 equal semantics 0x15 iszero 1 1 0 semantics 0x16 2 1 bit semantics 0x17 2 1 bit semantics 0x18 xor 2 1 xor bit semantics 0x19 1 1 bit semantics 0x1a byte 2 1 byte second operands semantics 0 3 20s sha3 instruction set words pop push semantics evm semantics vite 0x20 sha3 2 1 calculate keccak 256 hash semantics 20 x0ca 0 4 30s environmental information instruction set words pop push semantics evm semantics vite 0x30 address 0 1 obtain address current account semantics 0x31 balance 1 1 obtain balance account semantics returned vite balance account 0x32 origin 0 1 obtain sender addresss original transaction different samantics return 0 forever vite doesn xe2 x80 x99t maintain causal relationship internal transaction user transaction 0x33 caller 0 1 obtain address direct caller semantics 0x34 callvalue 0 1 obtain transferred called transaction semantics 0x35 calldataload 1 1 obtain parameter calling semantics 0x36 calldatasize 0 1 obtain size parameter data calling semantics 0x37 calldatacopy 3 0 copy called parameter data memory semantics 0x38 codesize 0 1 obtain size running code current environment semantics 0x39 codecopy 3 0 copy running code current environment memory semantics 0x3a gasprice 0 1 obtain gas price current enviroment different samantics return 0 forever 0x3b extcodesize 1 1 obtain code size account semantics 0x3c extcodecopy 4 0 copy code account memory semantics 0x3d returndatasize 0 1 obtain data size returned previous calling semantics 0x3e returndatacopy 3 0 copy returned data calling previously memory memory semantics 21 x0ca 0 5 40s block info instructions set words pop push semantics evm semantics vite 0x40 blockhash 1 1 obtain hash block different semantic return hash corresponing snapshot block 0x41 coinbase 0 1 obtain address miner beneficiary current block different semantic return 0 forever 0x42 0 timestamp 1 return timestamp current block different semantic return 0 forever 0x43 0 number 1 return number current block different semantic return number responding transaction block account chain 0x44 0 difficulty 1 return difficulty block different semantic return 0 forever 0x45 0 gaslimit 1 return gas limitation block different semantic return 0 forever 0 6 50s stach xef xbf xbdmemory xef xbf xbdstorege xef xbf xbdcontrol stream operation instruction set words pop push semantics evm semantics vite 0x50 pop 1 0 pop data stack semantics 0x51 mload 1 1 load word memory semantics 0x52 mstore 2 0 save word memory semantics 0x53 mstore8 2 0 save byte memory semantics 0x54 sload 1 1 load word storage semantics 0x55 sstore 2 0 save word storage semantics 0x56 jump 1 0 jump instructions semantics 0x57 jumpi 2 0 jump instructions condition semantics 0x58 pc 0 1 obtain program counter xe2 x80 x99s value semantics 0x59 msize 0 1 obtain size memory semantics 0x5a gas 0 1 obtain available gas different semantic return 0 forever 0x5b jumpdest 0 0 mark destination jumping semantics 22 x0ca 0 7 60s 70s stack operation instructions words pop push semantics evm semantics vite 0x60 push1 0 1 push byte object stack semantics 0x61 push2 0 1 push bytes object stack semantics 0x7f push32 0 1 push 32 bytes object word stack semantics 0 8 80s duplication operation instructions words pop push semantics evm semantics vite 0x80 dup1 1 2 duplicate 1st object push stack semantics 0x81 dup2 2 3 duplicate 2nd object push stack semantics 16 17 0x8f dup16 duplicate 16th object push stack semantics 0 9 90s swap operation instructions words pop push semantics evm semantics vite 0x90 swap1 2 2 swap 1st 2nd object stack semantics 0x91 swap2 3 3 swap 1st 3rd object stack semantics 0x9f swap16 17 17 swap 1st 17th object stack semantics 0 10 a0s log operation instructions words pop push semantics evm semantics vite 0xa0 log0 2 0 extend log record scheme semantics 0xa1 log1 3 0 extend log record 1 scheme semantics 6 0 0xa4 log4 extend log record 4 schemes semantics 23 x0ca 0 11 f0s system operation instructions words pop push semantics evm semantics vite 0xf0 create 3 1 create new contract semantics 0xf1 7 1 contract different semantic indicate sending message account returned vale 0 forever 0xf2 callcode 7 1 code contract change status account semantics 0xf3 return 2 0 stop execution return value semantics 0xf4 delegatecall 6 1 code contract change contract change current account status original transaction info semantics 0xfa staticcall 6 1 contract allow change status different semantic represents sending message contract don xe2 x80 x99t change status target contract return 0 forever needed result sending message target contract return 0xfd revert 2 0 stop execution recover status return value semantics semantics returning left gas 0xfe invalid xe2 x88 x85 xe2 x88 x85 invalid instructions semantics 0xff selfdestruct 1 0 stop execution set contract waiting deleting return balance semantics 24 x0c