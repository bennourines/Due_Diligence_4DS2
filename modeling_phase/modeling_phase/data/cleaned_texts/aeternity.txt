b xc3 x86ternity blockchain trustless decentralized purely functional oracle machine january 23 2017 v0 1 zackary hess zack aeternity com yanislav malahov yani aeternity com iii abstract xe2 x80 x94 introduction ethereum 2014 great interest decentralized trustless applications smart contracts consequently tried implement applications real world data blockchain believe storing application xe2 x80 x99s state code chain wrong reasons present highly scalable blockchain architecture consensus mechanism check oracle makes oracle efficient avoids layering consensus mechanism state channels integrated increase privacy scalability tokens channels transferred purely functional smart contracts access oracle answers storing contract code state chain able smart contracts easier analyze faster process substantial loss de facto functionality applications like markets synthetic assets prediction markets efficiently implemented global scale parts proof concept implementations erlang development tools application essentials wallet naming identity system provided applications iii blockchain essentials iii 1 identities iii 2 wallet iii 3 proof existence iii b state channel applications iii b 1 toll api iii b 2 insured crowdfunding iii b 3 cross chain atomic swaps iii b 4 stable value assets portfolio replication iii b 5 event contracts iii b 6 prediction markets iii b 7 market batch trading single price 6 6 6 6 6 7 7 7 7 iv implementation iv virtual machine contract language iv b adoption web integration iv c open source modules iv d usability ux design 8 8 8 8 8 v discussion v limitations tradeoffs v 1 chain state v 2 free option problem v 3 liquidity loss state channel topologies v b future work v b 1 functional contract language v b 2 multi party channels 8 9 9 9 c ontents introduction previous work 1 2 ii xc3 x86ternity blockchain ii tokens accounts blocks ii 1 access token aeon ii 2 accounts ii 3 system ii 4 block contents ii b state channels ii b 1 smart contracts ii b 2 example ii c consensus mechanism ii c 1 oracles ii d governance ii e scalability ii e 1 sharding trees ii e 2 light clients ii e 3 state channels parallelism ii e 4 transactions second given memory requirement 2 2 2 2 3 3 3 3 4 5 5 5 6 6 6 jack pettersson jack aeternity com 7 7 7 7 9 9 9 9 ntroduction intention paper overview xc3 x86ternity blockchain architecture possible applications detailed papers released future specifically consensus governance mechanisms noted architecture holistic components tie synergize modular way rest paper broken parts introduce discuss fundamental theoretical ideas inform architecture second discuss 6 6 1 x0cincluded essential applications possible use cases intuitions use platform developer present current proof concept implementation written erlang conclude discussion including possible future directions comparisons technologies independent processed parallel additionally means contracts write shared state greatly simplifying testing verification believe design emphasizes blockchains financial logic data storage exist decentralized storage solutions complement blockchains perfectly second applications augur attempted bring real world data blockchain decentralized way xe2 x80 x94in process essentially building consensus mechanism inside smart contracts 8 instead utilizing consensus mechanism underlying blockchain leads inefficiencies doesn xe2 x80 x99t increase security natural conclusion generalize blockchain xe2 x80 x99s consensus mechanism provide information internal state state external world argued blockchain xe2 x80 x99s consensus mechanism determines result running complexity theory dubs oracle machine theoretical machine powerful turing machine answers questions xe2 x80 x99t necessarily computed xe2 x80 x9cwho won football game x xe2 x80 x9d need cit natural consensus mechanism determine parameters system allows adapt changing external conditions adopting new research recent developments field rest section introduces xc3 x86ternity blockchain greater detail starting brief overview accounts tokens names structure blocks followed explanation approach state channels smart contracts discussion blockchain xe2 x80 x99s consensus mechanism create efficient oracle mechanism govern system finally discuss scalability different angles previous work blockchains bitcoin shown new way architect value exchange internet 1 followed number promising advances ethereum demonstrated way write turing complete smart contracts secured blockchain architecture 2 truthcoin created tools making oracles blockchains 3 groupgnosis augur showed efficient 4 casey detrio showed markets blockchains 5 namecoin showed distributed equivalent domain server 6 factom showed blockchain stores hashes proof existence digital data 7 technologies great promise comes providing class financial legal services far failed come unified actually fulfills promise specifically solutions far lacking following respects governance scalability scripting safety cheap access real world data need cit xc3 x86ternity aims improve state art respects ii xc3 x86 ternity blockchain believe lack scalability scripting safety cheap access real world data current xe2 x80 x9csmart contract platforms xe2 x80 x9d come core issues currently prevailing stateful design makes smart contracts written platform hard analyze1 statefulness combined sequential transaction ordering complicates scalability need cit second high cost bringing realworld data system decentralized trustless reliable way complicates outright prevents realization promising applications need cit platforms limited abilities update order adapt new technological economical knowledge believe problems clear solution paths explored recent research state channel technology suggests use cases keeping state chain necessary need cit entirely possible store information state channels use blockchain settle economic results information exchange fallback case dispute suggests alternative approach blockchain architecture turing complete smart contracts exist state channels chain increases scalability transactions tokens accounts blocks despite xe2 x80 x9cstateless xe2 x80 x9d contract developer xe2 x80 x99s point view xc3 x86ternity blockchain keeps track predefined state components explain content block simplicity section assumes node keeps track blockchain possible optimizations described section ii e 1 access token aeon use blockchain free requires user spends token called aeon aeon payment resources consumes platform basis financial applications implemented platform distribution aeon genesis block determined smart contract hosted ethereum aeon created mining system fees paid aeon smart contracts settle aeon 2 accounts account address balance aeon nonce increases transaction height update account 1 difficulty analyzing stateful contracts clearly demonstrated entrance bug brought xe2 x80 x9cthe dao xe2 x80 x9d happened despite code having audited ethereum xe2 x80 x99s creators general community need cit 2 x0calso pay small fee time open costs creating keeping accounts prevents spam disincentivizes state bloat reward deleting accounts incentivizes reclaiming space 3 system blockchain systems suffer unreadable addresses users vein aaron swartz xe2 x80 x99 work namecoin xc3 x86ternity features system decentralized secure supporting human friendly names 9 blockchain xe2 x80 x99s state includes mapping unique human friendly strings fixed size byte arrays names point things account addresses xc3 x86ternity hashes e g merkle trees 4 block contents block contains following components xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 1 macro gold f870e8f615b386aad5b953fe089 2 3 4 5 gold oracle 0 1000 0 0 end 0 fig 1 simple contract encoding bet price gold language forth like chalang presented section iv fit transactions related channels processed parallel greatly improving transaction throughput blockchain settle final outcome resolve conflicts arise roughly analogous judicial system blockchain xe2 x80 x99s behavior predictable gain disputing intended result state channel malicious actors incentivized behave correctly settle final state blockchain taken increases transaction speed volume orders magnitude privacy b 1 smart contracts despite state settled chain transfer aeon xc3 x86ternity features turing complete virtual machine run xe2 x80 x9csmart contracts xe2 x80 x9d contracts xc3 x86ternity strictly agreements distribute funds according rules stands stark contrast entity like contracts e g ethereum notable practical differences default involved parties know given contract parties open state channel create valid contract parties agree contract sign copies future reference submitted blockchain outcome disputed case code stored submitted transaction state happens blockchain distributes tokens according contract closes channel example fig 1 shows simple contract encodes bet price gold certain time line 1 macro gold saves identifier oracle question return true price gold $38 g december 1st 2016 body contract displayed lines 2 4 push gold oracle xe2 x80 x99s identifier stack oracle leave oracle xe2 x80 x99s answer stack use conditional branching oracle returns true push 0 1000 stack indicating 0 aeon burned 1000 aeon participant channel push 0 0 second 0 indicating participant receives aeon channel finally push 0 taken nonce channel state actual usage nonce generated deployment important thing note contracts xc3 x86ternity don xe2 x80 x99t maintain state state maintained transacting parties submitted input execution contract essentially pure function takes hash previous block merkle tree transactions merkle tree accounts merkle tree names merkle tree open channels merkle tree oracles haven xe2 x80 x99t answered respective questions merkle tree oracle answers merkle tree merkle proofs current entropy random number generator hash previous block required maintain ordering blockchain transaction tree contains transactions included current block exception consensus vote tree trees fully consensus tree changed block change transaction new block xe2 x80 x99s transaction tree merkle proof update included block xe2 x80 x99s proof tree purpose remaining trees hopefully clear following sections b state channels interesting developments blockchain space lately state channels operate basic principle cases people affected transaction need know essence transacting parties instantiate state blockchain e g ethereum contract bitcoin multisig simply send signed updates state key point use update state blockchain cases don xe2 x80 x99t allows transactions conducted fast information transmitted processed parties instead having wait transaction validated xe2 x80 x94and potentially finalized xe2 x80 x94 blockchain xe2 x80 x99s consensus mechanism xc3 x86ternity state update settled blockchain transfer aeon aeon transferred ones transacting parties deposited channel makes channels independent immediate bene3 x0c1 2 3 4 hashlock swap hash 1 macro commitment a9d7e8023f80ac8928334 2 3 4 5 fig 2 commitment hashlock state33 state32 end simple hashlock fig 4 simplified example hashlock play multi player game channels 1 macro commitment a9d7e8023f80ac8928334 2 3 4 5 commitment hashlock 0 100 0 50 end 1 defined function state32 want trustlessly simultaneously update channels state 33 game manager reveals secret causes channels update time b metered execution contract execution metered way similar ethereum xe2 x80 x99s xe2 x80 x9cgas xe2 x80 x9d xc3 x86ternity uses different resources metering time space paid aeon party requests execution seen undesirable probably party causing need blockchain resolve dispute place long money channel betting effectively nullified contract code ability redistribute funds party fact generally good practice avoid funds channel transact disincentivizes losing party cooperate closing channel b 2 example let xe2 x80 x99s bring ideas earth practice alice bob want transact state channel xc3 x86ternity following procedure fig 3 hashlock trustlessly send tokens middleman input gives new channel state output2 benefits pure functions software development general development financial applications particular extensively documented academia industry decades 10 need cit contract interaction multi step contracts contracts stateless execute independently contract interaction statefulness achieved hashlocking need cit simple hashlock shown fig 2 line 1 define function called hashlock expects stack contain hash h secret s swaps line 2 order hash secret line 3 calling equality operator hash v h line 4 returns true secret preimage hash function predicate execution code branches different contracts existence secret value simple example usage hashlocks possible users don xe2 x80 x99t share state channel trustlessly send aeon long path channels example alice bob channel bob carol channel alice carol transact bob creating copies contract shown fig 3 channel commitment line 1 hash secret alice chooses line 3 push stack hashlock function branch gets executed depends return value hashlock contracts signed parties alice reveals secret allowing bob carol use claim aeon hashlocking e g play multi player games channels shown fig 4 makes channel game manager publishes contract channel game state 32 1 alice bob sign transaction specifies money depositing channel publish blockchain 2 blockchain opened channel create new channel states send sign channel states new distribution funds channel contract determines new distribution channel states increasing nonce signed parties dispute arises latest valid state submitted blockchain enforces 3 channel closed different ways alice bob decide finished transacting agree final balances sign transaction indicating submit blockchain close channel redistribute money channel accordingly b alice refuses sign closing transaction reason bob submit state signed request channel closed state starts countdown alice believes bob dishonest opportunity publish state 2 noted contracts read answers oracles environment parameters aren xe2 x80 x99t completely pure functions oracle answers change xe2 x80 x99ve provided argued computational richness oracle machine impurity environment parameters deemed xe2 x80 x9cnecessary evil xe2 x80 x9d ideally compartmentalized appropriately high level languages 4 x0ca higher nonce signed countdown finishes channel closes immediately closes countdown finished running consensus mechanisms expensive running separately additionally doesn xe2 x80 x99t increase security secure attacked produce xe2 x80 x9cfalse xe2 x80 x9d values propose conflate consensus mechanisms essentially reusing mechanism use agree state system agree state outside world way works follows aeon holder launch oracle committing answering yes noquestion need specify timeframe question answered start time future user launches oracle required deposit aeon proportion length timeframe returned user supplies answer gets accepted truth burned blockchain generates unique identifier oracle retrieve answer available time comes question answered user launched oracle supply answer free oracle launcher supplied answer certain time passed users submit counter claims depositing aeon counter claims submitted end timeframe answer supplied user launched oracle accepted truth deposit returned counter claims submitted consensus mechanism blocks answer oracle expensive know safety deposits use c consensus mechanism xc3 x86ternity uses hybrid proof work proof stake consensus mechanism block order determined proof work certain system variables determined chain prediction market system allows users participate bring knowledge pow algorithm currently favor variant tromp xe2 x80 x99s cuckoo cycle memory bound xe2 x80 x9dindirectly useful proof work xe2 x80 x9d requires electricity run instead limiting factor memory latency availability makes feasible smart phone tromp writes work xe2 x80 x9d cuckoo cycle instantly verifiable memory bound pow unique dominated latency computation sense mining cuckoo cycle form asic mining dram chips serve application randomly reading writing billions bits phones charging overnight orders magnitude loss efficiency mindset profitability playing lottery mining hardware landscape vast expansion benefiting adoption decentralization xe2 x80 x9d preview consensus mechanism somewhat nonstandard role xc3 x86ternity addition agreeing new blocks blockchain agrees answers oracle questions values system xe2 x80 x99s parameters particular consensus mechanism change noted entirely unproblematic example simple proof work mechanism cheap bribe miners corrupt oracle xc3 x86ternity going use novel hybrid proof stake proof work algorithm leveraging benefits independently pow going issue new aeon tokens sidenote originally aeternity intended 100 percent proof stake blockchain don xe2 x80 x99t think anymore decentralized 100 percent pos system possible c 1 oracles crucial feature contracts encoded text code ability refer values environment prices different goods certain event occurred smart contract system ability essentially closed system arguably useful generally accepted fact projects attempt bring external data blockchain decentralized way 8 decide supplied fact true essentially require implementation new consensus mechanism consensus mechanism d governance governance blockchain based systems big problem past system upgrade needs requires hard fork usually leads big discussions value holders simple things like correcting arbitrarily set variable source code seen block size debate bitcoin hard system users xe2 x80 x99 incentives aligned decision makers clear upgrade path seen complicated governance decisions like fixing single smart contract bug xe2 x80 x9cthe dao xe2 x80 x9d required quick intervention system developers primary problem systems easily identifiable xe2 x80 x94the decision making process protocol upgrade change defined lacks transparency xc3 x86ternity xe2 x80 x99s governance system consensus uses prediction markets function efficiently transparently possible consensus mechanism defined number variables determine system functions slightly updated new block costs transactions ask oracle modifications fundamental parameter values like block time 5 x0cby having prediction markets variables define protocol users learn efficiently improve protocol having predictions markets potential hard forks help community come consensus version code use user chooses metric seeks optimize simple default strategy maximize value holdings 2 change 3 4 define following variables following calculations 5 6 7 8 9 b f r t block size bytes blocks till finality time till finality seconds transaction size bytes 10 e scalability 11 transactions second b f t r 12 e 1 sharding trees architecture presented far highly scalable possible run blockchain user keeps track blockchain state care ignores xe2 x80 x99s data copy state needed new users certain substate care shard data arbitrarily nodes node xe2 x80 x99s load arbitrarily small merkle trees prove substate state 11 easy imagine scenario certain nodes specialize keeping track trees paid inserts look ups e 2 light clients light clients don xe2 x80 x99t download entire blocks user gives client hash history fork prefer technique known weak subjectivity 12 client knows download forks include block hash client downloads headers blocks headers smaller blocks transactions processed simplicity mention block headers discussing block structure section ii 4 contain following xe2 x80 xa2 hash previous block xe2 x80 xa2 root hash state trees e 3 state channels parallelism state channels immense throughput transactions inside executed recorded blockchain additionally channels don xe2 x80 x99t write shared state chain transactions actually recorded blockchain processed parallel given consumer hardware sold today processing cores immediate effect transaction throughput multiplied roughly factor 4 furthermore fact complex concurrent interaction suggests sharding blockchain architecture relatively easy blockchain sharding fairly experimental deliberately chosen pursue sharding techniques initial design xc3 x86ternity changes future xc3 x86ternity easiest blockchains shard e 4 transactions second given memory requirement variables define protocol constantly updated consensus initial default values calculate initial default rate transactions second 1 13 14 15 16 17 b f r r t 1000000 bytes 1 megabyte block 24 60 2 blocks day f 30 seconds block 24 3600 seconds day 1000 bytes transaction 18 19 20 21 1000000 24 60 2 1000 24 3600 1000000 1000 30 32 transactions second fast sign human 8 years operate node need copy blocks finality need able record 100 times information case attack estimating finality 2 days 5760 blocks till finality memory requirement 5760 megabyte 100 576000 megabytes 576 gigabytes isn xe2 x80 x99t attack happening need 5 76 gigabytes store blocks iii pplications stateless nature xc3 x86ternity smart contracts makes easy build following applications xc3 x86ternity xe2 x80 x99s blockchain especially suitable high volume usecases blockchain essentials blockchain essentials necessary primitives like aeon wallets names related concepts modularize reusable components application foundations improved 1 identities account associated unique id number users register unique names link names merkle root data structure data structure contain xe2 x80 x99s unique id information xe2 x80 x99s account aim use schema org xe2 x80 x99s json format represent things like persons companies 13 2 wallet wallet piece software interact aeternity wallet manages private keys aeon creates signs transactions use wallet send channel transactions use apps channel network 3 proof existence transaction type allows publishing hash data system participants use headers prove data existed point time note draft likely 6 x0cb state channel applications smart contracts state channels perfect microservices web require high transaction throughput b 1 toll api apis existing today publicly available secured username password xe2 x80 x93scheme unique access tokens payment channels allow new kind api pays api possibly http request paying access api solves ddos problems makes easier build high quality apis available api responses require payment fundamental creation impossible types businesses play important role emergence decentralized economy create incentives information owners private data publicly available b 2 insured crowdfunding implement insured crowdfunding dominant assurance contracts need cit smart contracts raise money public good like new bridge school market dominant assurance contracts differ traditional assurance contracts like kickstarter dominant strategy participate good funded participants aeon plus interest insured reducing liquidity receiving good oracle ensure provider good service gets paid good service actually provided b 3 cross chain atomic swaps cross chain atomic swaps allow trustless exchange aeon bitcoins 14 15 implemented hashlock locks transactions blockchains value b 4 stable value assets portfolio replication use smart contracts program synthetic assets stay nearly price real world asset example asset stays price gold synthetic derivatives created equal opposite pairs user asset moves gold different user asset inversely gold example alice contract bob alice owns 1 gram gold money contract gram gold worth aeon alice leftover money goes bob contract expiration date price gold measured funds distributed alice bob accordingly b 5 event contracts event contracts pay event happens don xe2 x80 x99t pay event happen oracle xe2 x80 x99s telling apart interesting different applications insurances use event contracts implement insurances example expensive music event tickets worthless weather goes bad concert goer receives money oracle decides rained day event investment protected afford find emotionallyadequate alternative slightly seriously farmers interested total number inches rain season insure crops wilting dryness b whistleblowing event contracts incentivize revealing sensitive information example bet event xe2 x80 x9cinformation indicating company illegal pesticides released january 24th 2017 xe2 x80 x9d person access information incentivized bet event happen release b 6 prediction markets prediction market works letting users bet future event happen price bets predict future likelihood 3 8 16 accurate way measure future given price need cit event happened market settled oracle noted section ii d example use prediction markets predict updates software beneficial harmful use estimate candidates election actually able accomplish lies baseless promises detected easily fig 5 multidimensional prediction market multidimensional prediction markets multidimentional prediction markets allow predict correlation possible future events example predict alice elected leader price potatoes bob wins price learn google uses plan 3 months probably earn money uses plan b probably earn fig 5 alice elected president high likelihood price potatoes low b 7 market batch trading single price approaches available attackers want rob aeon market advantage market split time advantage split space xe2 x80 xa2 market split space attacker arbitrage simultaneously makes trades markets risk cancels earns 7 x0c xe2 x80 xa2 iv mplementation profit market split time attacker frontruns market reads transactions coming market creates buy sell orders immediately key concepts proof concept implementations erlang includes blockchain contract language vm oracle governance mechanisms old version consensus mechanism erlang otp makes easy write code respond requests parallel crash servers highest uptime world based erlang industrial applications 30 years proving reliable stable product virtual machine contract language virtual machine stack based similar forth bitcoin xe2 x80 x99 scripting language comparison rich vm supports functions instead gotos making semantics relatively simple analyze list vm xe2 x80 x99s opcodes found github3 additionally exists higher level forth like language called chalang compiles bytecode vm supports macros variable names keeps stack based execution model 17 examples chalang code found github4 fig 6 black line demand curve red line supply curve sells red size buys red vertical line price market maker selected willing buy higher price traded price willing sell lower price traded price b adoption web integration web popular application platform provide easy use web development tools jslibraries json apis core features xc3 x86ternity blockchain combine markets space use market maker combine markets time need trading batches single price market maker needs commit person price decided find contradictory commitments market maker customers able drain channels market maker commits fair price match volume buyers sellers fig 6 shows end situation similar fig 7 taking large risk c open source modules order easily private blockchain consortium use cases software written mit licensed modules consensus module adapted specific needs d usability ux design frictionless human interaction big focus development efforts specifically sure controls identity keys transactions clearly established offering easy access web gateways central focus future development users participating prediction markets tinder like swipe left right mobile interface simple web wallets easily integrated website iframe new norm v d iscussion provided explanation architect fundamentally efficient value transfer system described system fact global oracle machine provide decision making services global scale particular applications proposed section iii built easily efficiently xc3 x86ternity 3 https github com aeternity chalang blob master opcodes md 4 https github com aeternity chalang tree master examples fig 7 black bigger red market maker selling shares buying taking lot risk 8 x0chowever approach fundamental limitations avenues improvement discussed secret hashlock revealed transaction doesn xe2 x80 x99t goes offline possible xe2 x80 x9cnegative xe2 x80 x9d effect transmitter able claim aeon limitations tradeoffs believe tradeoffs architecture reasonable given resulting performance increase areas xc3 x86ternity catch solution decentralized applications viewed synergistic complement existing technologies caveats need aware 1 chain state despite having advantages xc3 x86ternity xe2 x80 x99s lack programmable state makes unfit applications require custom state consensus example includes daos usually conceived custom systems subcurrencies tied value underlying asset 2 free option problem alice bob channel alice signs contract essentially gives bob free option sends bob choose sign return e activate contract time future intended avoid problem channel contracts aren xe2 x80 x99t immediately activated divided time space participants sign contract small intervals user offers large free option example parties want bet 100 aeon sign 1000 steps increase bet 0 1 aeon require 1000 messages pass 500 direction cheap contract submitted blockchain example wanted financial asset 100 days sign 2400 steps hour require 2400 messages pass 1200 direction 3 liquidity loss state channel topologies composing channels hashlocks demonstrated section ii b 1 middlemen lock twice aeon transmitted example alice carol want transact bob bob act carol interacting alice viceversa expensive bob likely earn fee compensation alice carol expect conduct trades avoid creating new channel trustlessly moving active contracts new channel hashlock keeping extra channel open impacts xe2 x80 x99s liquidity negatively going middlemen expected desirable cases especially cases parties don xe2 x80 x99t expect trade lot future channel topology certain rich users money trustlessly transmitting transactions users expected emerge noted constitute single point failure trust transaction transmitters transmitter goes offline b future work possible ways improve current architecture b 1 functional contract language reasonable future direction experiment high level languages adhere closely functional paradigm keeping track implicit stack generally error prone arguably suitable high level developer facing language easy given programs pure functions modulo environment variables greatly simplify development formal verification contracts sense revise vm tightly coupled new language compilation error prone dependent trust developers ideally translation surface language vm code simply direct transcription peer reviewed research pragmatic concessions likely b 2 multi party channels currently channels xc3 x86ternity limited parties multi party channels de facto achieved hashlocking expensive plan investigate possibility adding support n party channels m n settlement mechanism g lossary blockchain distributed tamper proof database metered access database defined growing list hash linked blocks rules appending aeon aeon represents unit account access right xc3 x86ternity blockchain transferable transaction message user blockchain users use currency access blockchain state channel relationship users recorded blockchain enables users send aeon forth create trustless smart contracts enforced settled blockchain hash hash takes input binary size gives fixed sized output input hashes output given output calculate input hashlocking connect pairs channels smart contracts involve 2 people secret referenced xe2 x80 x99s hash secret revealed update multiple channels time governance defined process making decisions future protocol s blockchain 9 x0coracle mechanism tells blockchain facts world live oracles users predict outcome events external blockchain system value holder user owns aeon financial derivative system validator validator user participates consensus mechanism case xc3 x86ternity value holder participate 11 12 13 acknowledgments thanks vlad matt paul dirk martin alistair devon ben proof reading thanks lots people insightful discussions 14 r eferences 15 1 2 3 4 5 6 7 8 9 10 s nakamoto xe2 x80 x9cbitcoin peer peer electronic cash system xe2 x80 x9d 2008 online available https bitcoin org bitcoin pdf v buterin xe2 x80 x9cethereum generation smart contract decentralized application platform xe2 x80 x9d 2014 online available https github com ethereum wiki wiki white paper p sztorc xe2 x80 x9cmarket empiricism xe2 x80 x9d online available http bitcoinhivemind com papers 1 purpose pdf m liston m ko xcc x88ppelmann xe2 x80 x9ca visit oracle xe2 x80 x9d 2016 online available https blog gnosis pm c detrio xe2 x80 x9csmart markets smart contracts xe2 x80 x9d 2015 online available http cdetr io smartmarkets namecoin wiki 2016 online available https wiki namecoin org index php title welcome p snow b deery j lu et al xe2 x80 x9cfactom business processes secured immutable audit trails blockchain xe2 x80 x9d 2014 online available http bravenewcoin com assets whitepapers factom whitepaper pdf j peterson j krug xe2 x80 x9caugur decentralized open source platform prediction markets xe2 x80 x9d 2014 online available http bravenewcoin com assets whitepapers augur decentralized open source platform prediction markets pdf swartz xe2 x80 x9csquaring triangle secure decentralized human readable names xe2 x80 x9d 2011 online available http www aaronsw com weblog squarezooko t hvitved xe2 x80 x9ca survey formal languages contracts xe2 x80 x9d formal languages analysis contract oriented software 2010 pp 29 xe2 x80 x9332 online available http www diku dk hjemmesider ansatte hvitved publications hvitved10flacosb pdf 16 17 10 r c merkle xe2 x80 x9cprotocols public key cryptosystems xe2 x80 x9d ieee symposium security privacy 1980 v buterin xe2 x80 x9cproof stake learned love weak subjectivity xe2 x80 x9d 2014 online available https blog ethereum org 2014 11 25 proof stake learned love weak subjectivity xe2 x80 x9cschema org schemas xe2 x80 x9d 2016 online available http schema org docs schemas html xe2 x80 x9catomic cross chain trading xe2 x80 x9d 2016 online available https en bitcoin wiki atomic%5c cross chain%5c trading xe2 x80 x9cinterledger xe2 x80 x9d 2016 online available https interledger org k j arrow r forsythe m gorham et al xe2 x80 x9cthe promise prediction markets xe2 x80 x9d science 320 2008 online available http mason gmu edu xcb x9crhanson promisepredmkt pdf z hess xe2 x80 x9cchalang xe2 x80 x9d 2016 online available https github com aeternity chalang x0c