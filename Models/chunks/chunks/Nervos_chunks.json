[
  {
    "text": "[Section 1] number category status author organization created 0002 informational draft jan xie nervos foundation 2018 01 02 nervos ckb common knowledge base crypto economy abstract nervos layered crypto economy network nervos separates infrastructure crypto economy layers verification layer layer 1 serves trust root smart custodian generation layer layer 2 high performance transactions privacy protection document provides overview nervos common knowledge base ckb public permissionless blockchain layer 1 nervos ckb generates trust extends trust upper layers making nervos trust network s value store nervos network providing public secure censorship resistant custody services assets identities common knowledge created network contents motivation overview consensus programming model state generation verification cell vm transaction economic model network summary references appendix 1 motivation want peer peer crypto economy network network people collaborate incentives need ability define issue",
    "metadata": {
      "chunk_id": "009447cf9f12ded4f7d0f965d0074115",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [
          "fine"
        ],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 12.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 2] verification cell vm transaction economic model network summary references appendix 1 motivation want peer peer crypto economy network network people collaborate incentives need ability define issue transfer assets peer peer network create incentives blockchain technology brings piece puzzle bitcoin 1 public permissionless blockchain designed solely peer peer cash ethereum 2 extends use case blockchain create general purpose trust computing platform people built kinds decentralized applications booming applications bitcoin ethereum networks proven concept future crypto economy networks suffer notorious scalability problem transaction processing capability scale number participants network severely limits potential blockchain community proposed scalability solutions recent years general divide solutions categories chain scaling chain scaling chain scaling solutions try scale layer consensus runs consensus process core blockchain protocol nodes exchange network messages reach agreement",
    "metadata": {
      "chunk_id": "303a57b95a10915dde284acdba0cc9fe",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [
          "fine"
        ],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 12.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 3] solutions categories chain scaling chain scaling chain scaling solutions try scale layer consensus runs consensus process core blockchain protocol nodes exchange network messages reach agreement eventually consensus slow definition message exchange public open network slow uncertain nodes wait retry reach agreement consensus process scale layer scale increasing processing ability network bandwidth nodes sacrifice decentralization high hardware infrastructure costs scale sharding idea sharding divide nodes small shards ask shard process fraction network transactions sharding widely adopted internet giants face scalability issues serving millions users sharding known complexity shard coordination cross shard transactions trusted environment leads performance degradation number shards grows contrast chain scaling solutions acknowledge inherent complexity consensus process recognize consensus different scopes incur different costs global consensus created public permissionless blockchain",
    "metadata": {
      "chunk_id": "052bf8be526e156d37bb5e40ead5087b",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 4] contrast chain scaling solutions acknowledge inherent complexity consensus process recognize consensus different scopes incur different costs global consensus created public permissionless blockchain expensive consensus hard scale global consensus use wisely transactions parties don t need known node network securely settled words users want turn transactions common knowledge network network scales offloading work upper layers limit scalability processing transactions chain brings additional benefits lower latency higher privacy agree general ideas chain scaling found existing blockchain designed example lightning network earliest explorations chain scaling taken years launch testnet far mass adoption limitations underlying bitcoin protocol ethereum provides powerful programming ability computation oriented economic model doesn t fit chain scaling chain participants handle computation required blockchain assets secure custody assets according final state computation computation",
    "metadata": {
      "chunk_id": "226e2fce48e09543e34071ef114c4124",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 5] computation oriented economic model doesn t fit chain scaling chain participants handle computation required blockchain assets secure custody assets according final state computation computation oriented design ethereum makes difficult execute transactions parallel impediment scalability economic models current blockchains face challenges users applications moving blockchain platforms data stored blockchains increases current blockchain solutions concerned cost consensus computation allow user pay data occupy nodes storage forever cryptocurrency prices highly volatile users find difficult pay high transaction fees price cryptocurrency increases propose nervos ckb public permissionless blockchain designed layered crypto economy network 2 overview nervos ckb common knowledge base layer 1 blockchain decentralized secure layer provides common knowledge custody network common knowledge refers states verified global consensus crypto assets example common knowledge nervos ckb layer 2",
    "metadata": {
      "chunk_id": "fd22bdb3187e41efdf0358c75805590d",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 6] 1 blockchain decentralized secure layer provides common knowledge custody network common knowledge refers states verified global consensus crypto assets example common knowledge nervos ckb layer 2 protocols work serve crypto economy ckb layer 1 state stored defined layer 2 generation layer computation layer terms interchangeable processes transactions generates new states layer 2 participants submit newly generated states ckb eventually time deem necessary states pass corresponding verification performed nodes global network ckb stores peer peer node securely layered architecture separates state computation providing layer flexibility scalability example blockchains generation layer layer 2 use different consensus algorithms ckb lowest layer broadest consensus provides secure consensus nervos network different applications prefer different consensus scopes forcing applications use ckb s consensus inefficient applications choose appropriate generation methods based particular needs",
    "metadata": {
      "chunk_id": "3776532d3d1b3c1d0c580040bf833902",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [
          "fine"
        ],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 12.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 7] nervos network different applications prefer different consensus scopes forcing applications use ckb s consensus inefficient applications choose appropriate generation methods based particular needs time applications need submit states ckb broader agreement need states common knowledge verified ckb s global consensus possible state generation methods include limited following local generators client generators run directly client s devices developers implement generator programming language web services users use traditional web services generate new states current web services work ckb way gain trust liquidity generated states example game companies define game items assets ckb game functions web service generates game data verified stored ckb state channels users use peer peer communication generate new states generation chains generation chain blockchain generates new states stores ckb generation chains permissionless blockchains permissioned blockchains generation chain nodes",
    "metadata": {
      "chunk_id": "7ec9dd7a9a71ebe032717b46e806b5c8",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [
          "fine"
        ],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 12.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 8] generate new states generation chains generation chain blockchain generates new states stores ckb generation chains permissionless blockchains permissioned blockchains generation chain nodes reach consensus smaller scopes providing better privacy performance figure 1 layered architecture figure 1 layered architecture ckb consists proof work based consensus risc v instruction set based virtual machine state model based cells state oriented economic model peer peer network proof work based consensus makes ckb public censorship resistant service combination ckb vm cell model creates stateful turing complete programming model developers making state generation layer 2 ckb practical ckb economic model designed common knowledge custody long term sustainability ckb peer peer network provides secure optimal communication different types nodes 3 consensus ckb consensus improved nakamoto consensus based proof work aims achieve openness correctness high performance distributed environments",
    "metadata": {
      "chunk_id": "a5cde88ee51e0f8293856aeb29d6f762",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 9] secure optimal communication different types nodes 3 consensus ckb consensus improved nakamoto consensus based proof work aims achieve openness correctness high performance distributed environments network delay byzantine node faults permissionless blockchains run open networks nodes join exit freely liveness assumptions severe problems traditional bft consensus algorithms solve satoshi nakamoto introduced economic incentives probabilistic consensus solve problems nakamoto consensus bitcoin uses blocks votes takes longer 10 minutes hour confirm transactions leads inferior user experience ckb consensus nakamoto consensus variant means allows nodes join exit network freely node participate consensus process mining running specific algorithm find proof work produce new blocks verifying new blocks valid ckb uses asic neutral proof work function goals distributing tokens evenly possible making network secure possible correctness includes eventual consistency availability fairness eventual",
    "metadata": {
      "chunk_id": "cab8c8d9b24ee32bcd44da2913df681d",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 10] valid ckb uses asic neutral proof work function goals distributing tokens evenly possible making network secure possible correctness includes eventual consistency availability fairness eventual consistency guarantees node sees identical copy state availability makes sure network responds users requests reasonable time fairness ensures mining nodes fair returns efforts network functioning securely high performance includes transaction latency time submission request confirmation execution results transaction throughput number transactions system capable processing second measures depend block time average time consecutive blocks check ckb consensus rfc details 4 programming model ckb provides stateful turing complete programming model based ckb vm cell model bitcoin ethereum ckb instruction set script evm risc v cryptographic primitive opcode precompile assembly stateful yes yes state type ledger general general state model utxo account cell state verification chain chain chain state",
    "metadata": {
      "chunk_id": "0ff59c2072b42462496610425f8d1201",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 11] set script evm risc v cryptographic primitive opcode precompile assembly stateful yes yes state type ledger general general state model utxo account cell state verification chain chain chain state generation chain chain chain table 1 comparison bitcoin ethereum ckb programming model ckb programming model consists parts state generation chain state verification ckb vm state storage cell model model decentralized application logic split parts generation verification running different places state generation logic runs chain client new states packaged transactions broadcasted entire network ckb transactions inputs outputs based structure like bitcoin transaction inputs references previous outputs proofs unlock client includes generated new states transaction outputs called cells ckb cells primary state storage units ckb assets owned users follow associated application logic specified scripts ckb vm executes scripts verifies proofs included inputs sure user permitted use referenced cells",
    "metadata": {
      "chunk_id": "48d085ef20c57d1b9fea4ec8720b49dc",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 12] state storage units ckb assets owned users follow associated application logic specified scripts ckb vm executes scripts verifies proofs included inputs sure user permitted use referenced cells state transition valid specified application logic way nodes network verify new states valid states custody state ckb class citizen states included transactions blocks synchronized directly nodes programming model stateful scripts running ckb vm pure functions internal state makes ckb scripts deterministic conducive parallel execution easy compose 4 1 state generation verification decentralized applications nervos separate generation verification state processes occur different places ckb provides additional flexibility utilize different algorithms state generation verification utilizing algorithm generation verification sides straightforward choice works general problems model algorithm implementations runs chain execution environment targeted application runs chain ckb vm new states generated",
    "metadata": {
      "chunk_id": "734c18fa20abc46b5834f5679770868e",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 13] verification sides straightforward choice works general problems model algorithm implementations runs chain execution environment targeted application runs chain ckb vm new states generated chain algorithm based previous states user inputs packaged transaction broadcasted network ckb nodes run algorithm chain provide previous states user inputs verify result matches transaction specified outputs advantages separation state generation validation deterministic transactions certainty transaction execution core pursuits decentralized applications transactions include user input new states result computation nodes seen ethereum transaction creator certain chain computation context lead unexpected results ckb users generate new states client confirm new states broadcasting state transition network transaction outcome certain transaction passes chain verification new state accepted transaction deemed invalid state change ckb figure 1 parallelism transactions include user inputs new states",
    "metadata": {
      "chunk_id": "33dcf4059877a39555cfefd8d20ba18d",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 14] transaction outcome certain transaction passes chain verification new state accepted transaction deemed invalid state change ckb figure 1 parallelism transactions include user inputs new states generated nodes nodes know state going accessed verification process determine dependencies transactions ckb transactions explicitly include previous states new states nodes dependencies transactions prior verification process transactions parallel higher resource utilization application logic split run different places network distribute computational workload evenly nodes clients utilize system resources efficiently flexible state generation algorithms developers implement generation validation different ways client flexibility choose programming language provides better performance fast development scenarios state verification utilize different associated algorithm efficient state generation typical example seen bitcoin transactions bitcoin transaction construction consists mainly searching",
    "metadata": {
      "chunk_id": "bfc589b34eaa97f927bcd50cebffac12",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 15] scenarios state verification utilize different associated algorithm efficient state generation typical example seen bitcoin transactions bitcoin transaction construction consists mainly searching process identify appropriate utxos use verification addition numbers simple comparison interesting examples include sorting searching algorithms computational complexity quicksort best sorting algorithms average case o nlog n algorithm verify result o n searching index element sorted array o log n binary search verification takes o 1 complex business rules higher probability asymmetric generation validation algorithms differing computational complexity system throughput improved utlizing asymmetry state generation validation moving details computation client valuable algorithm protection privacy advancement technologies zero knowledge proofs find efficient generation verification solutions general problems ckb natural fit types solutions refer programs generate new states create new cells",
    "metadata": {
      "chunk_id": "2d5094a5c63f99ddc0636fc98752366e",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 16] advancement technologies zero knowledge proofs find efficient generation verification solutions general problems ckb natural fit types solutions refer programs generate new states create new cells generators generators run locally client chain utilize user input existing cells program inputs create new cells new states outputs inputs generators use outputs produce form transaction figure 2 separation state generation verification figure 2 separation state generation verification 4 2 cell cells primary state units ckb users include arbitrary states cell following fields capacity size limit cell cell s size total size fields contained data state data stored cell total bytes cell including data equal capacity type state verification script lock script represents ownership cell owners cells transfer cells cell immutable object modify creation cell input different transactions cell updates mark previous cells history create new cells capacity replace constructing sending transactions users",
    "metadata": {
      "chunk_id": "eb9e8a25d567cc5a9380a8f0c606d881",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 17] cells cell immutable object modify creation cell input different transactions cell updates mark previous cells history create new cells capacity replace constructing sending transactions users provide new cells new states invalidate previous cells store old states atomically set current live cells represents latest version common knowledge ckb set history dead cells represents historical versions common knowledge ckb allows users transfer cell s capacity transfer fraction cell s capacity turn lead cells created e g cell capacity 10 bytes cells capacity 5 bytes kinds scripts type lock executed ckb vm ckb vm executes type script cell created transaction output guarantee state cell valid specific rules ckb vm executes lock script taking proofs arguments cell referenced transaction input sure user appropriate permissions update transfer cell execution lock script returns true user allowed transfer cell update data according validation rules specified type script type lock script pair",
    "metadata": {
      "chunk_id": "7ce89b6665aef8fe1de6ae64bf63c41b",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 18] sure user appropriate permissions update transfer cell execution lock script returns true user allowed transfer cell update data according validation rules specified type script type lock script pair allows kinds possibilities example upgradable cryptography deploy useful cryptography libraries written languages c c use type lock scripts ckb vm hardcoded cryptographic primitives users free choose cryptographic signature scheme d like use sign transactions multisig users easily create m n multisig complex lock scripts lending cell owners lend cells use maintaining ownership cells cell model generic state model compared utxo account model utxo account model express relationships assets owners utxo model defines ownership assets lock script account model defines ownership assets owner account balance utxo model makes ledger history clear lack generic state storage makes inexpressive scripts harder use account model easy understand support authorizations identities presents challenges",
    "metadata": {
      "chunk_id": "209618ca08eebb04c408e237b8af6d07",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [
          "fine"
        ],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 12.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 19] balance utxo model makes ledger history clear lack generic state storage makes inexpressive scripts harder use account model easy understand support authorizations identities presents challenges processing transactions parallel cell model lock type scripts takes best models provide generic state model 4 3 vm ckb vm risc v instruction set based vm executing type lock scripts uses standard risc v instructions maintain standard compliant risc v software implementation embrace broadest industrial support ckb implements cryptographic primitives ordinary assembly running vm instead customized instructions supports syscall scripts read metadata current transaction general blockchain information ckb ckb vm defines cycles instruction provides total cycles executed transaction verification help miners determine transaction fees existing blockchains hardcode cryptographic primitives protocol example bitcoin special cryptographic opcodes op check ethereum uses special precompiled contracts",
    "metadata": {
      "chunk_id": "4b8b67fae28a7b98adc895b6783edae8",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [
          "fine"
        ],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 12.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 20] miners determine transaction fees existing blockchains hardcode cryptographic primitives protocol example bitcoin special cryptographic opcodes op check ethereum uses special precompiled contracts located special address e g 0000000000000000000000000000000000000001 support cryptographic operations ecrecover add new cryptographic primitives blockchains soft fork bitcoin uses opcodes support new primitives hard fork ckb vm crypto agnostic virtual machine special cryptographic instructions hardcoded ckb vm new cryptographic primitives deployed scripts like ordinary library risc v standard compliant implementation means existing cryptographic libraries written c languages easily ported ckb vm cell scripts ckb implements default hash function public key cryptography transaction verification way crypto agnostic allows decentralized application developers nervos use new cryptography schnorr signatures bls signatures zksnarks zkstarks d like affecting users allows ckb users assets secure post",
    "metadata": {
      "chunk_id": "ee6a50396d479edbec30e657e21c5a91",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 21] crypto agnostic allows decentralized application developers nervos use new cryptography schnorr signatures bls signatures zksnarks zkstarks d like affecting users allows ckb users assets secure post quantum era ckb vm chooses hardware targeting isa blockchain hardware like software creation easy software upgrade difficult hardware isa designed chips risc v stable core instruction set implausible change future ability compatibility ecosystem need hard fork key feature blockchain virtual machine like ckb vm simplicity risc v makes runtime cost modeling easy crucial transaction fee calculations check rfc 0003 details ckb vm 4 4 transaction transactions express state transitions resulting cell transfer update single transaction users update data cells transfer cells users state transitions transaction atomic succeed fail transaction includes following deps dependent cell set provides read cells required transaction verification references living cells inputs cell references proofs cell",
    "metadata": {
      "chunk_id": "e17b3f42997bb390c97084672c584fba",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 22] transaction atomic succeed fail transaction includes following deps dependent cell set provides read cells required transaction verification references living cells inputs cell references proofs cell references point live cells transferred updated transaction proofs e g signature prove transaction creator permission transfer update referenced cells outputs new cells created state transition design ckb cell model transactions friendly light clients states blocks block synchronization accomplishes state synchronization light clients need synchronize blocks need additional state synchronization state transition computation events stored blocks nodes required state synchronization state synchronization difficult large networks weak incentives synchronize different block synchronization miners incentivized broadcast blocks widely possible need extra state synchronization protocol makes light nodes nodes equal peers leading robust decentralized system figure 3 transaction parallelism",
    "metadata": {
      "chunk_id": "dcabe630e6e20dcdd4a1320e9ea4b987",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 23] miners incentivized broadcast blocks widely possible need extra state synchronization protocol makes light nodes nodes equal peers leading robust decentralized system figure 3 transaction parallelism conflict detection figure 3 transaction parallelism conflict detection deps inputs ckb transactions easier nodes determine transaction dependencies perform parallel transaction processing figure 3 different types cells mixed included single transaction achieve atomic operation types 5 economic model designed economic model incentivize participants contribute success crypto economy maximize utility blockchain ckb economic model designed motivate users developers node operators work common goal common knowledge custody subject ckb economic model state instead computation cell capacity transaction fees incentives stakeholders check ckb token economics rfc details 5 1 state cost cell capacity creation storage states ckb incur costs creation new states needs verified nodes incur computational",
    "metadata": {
      "chunk_id": "10e11fbf7a44a2c22c27fdba51e71c18",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 24] fees incentives stakeholders check ckb token economics rfc details 5 1 state cost cell capacity creation storage states ckb incur costs creation new states needs verified nodes incur computational costs storage states requires nodes provide disk space ongoing basis current permissionless blockchains charge time transaction fees allow states stored nodes occupying storage space indefinitely ckb cells basic storage units state cell owner use cell store state lend cell s capacity utilized user time owner utilizing capacity opportunity earn interest lending capacity ckb users opportunity cost users pay storage cost proportional space time larger capacity longer time occupy higher opportunity cost incur advantage ckb s implicit state cost model compared upfront payment model storage rent discussed ethereum community avoids problem upfront payments system recycle state break applications contracts depend cell metadata capacity type lock states occupy users cell capacity incur state cost",
    "metadata": {
      "chunk_id": "94848dc3664bd0f98ea67befea584521",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 25] ethereum community avoids problem upfront payments system recycle state break applications contracts depend cell metadata capacity type lock states occupy users cell capacity incur state cost meta cost incentivize users create fewer cells possible increasing capacity efficiency 5 2 computation cost transaction fees updating cell s data transferring cell ownership incurs transaction fees miners set transaction fee level willing accept based ckb vm cycles state changes transaction verification allowing market determine transaction fees programming model described cell owners pay transaction fees behalf users cell capacity native asset ckb convenient asset users use pay transaction fees users use user defined assets long miners accept hard coded payment method ckb transactions allowed ckb economic model native asset center computation states cell capacity means paying transaction fees primary function secure common knowledge storage store state hold long term payment method competition",
    "metadata": {
      "chunk_id": "0830bf694035e7e91ad8cec6c0393c37",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [
          "fine"
        ],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 12.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 26] model native asset center computation states cell capacity means paying transaction fees primary function secure common knowledge storage store state hold long term payment method competition fee market compromise value restricting transaction fee payment method blockchain s native asset significant obstacle preventing blockchains mass adoption requires users acquire native assets blockchain s services raising barrier entry new users allowing cell owners pay fees behalf users allowing payment user defined assets ckb provide better experience users wider choices business models developers check nervos ckb economic paper rfc 0015 details economic model 6 network categorize ckb nodes types mining node participate ckb consensus process mining nodes collect new transactions package blocks produce new blocks found proof work mining nodes store entire transaction history current cell set node verify new blocks transactions relay blocks transactions select chain fork agree nodes verifiers",
    "metadata": {
      "chunk_id": "fa761842d451c8815099c13854947d19",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [
          "fine"
        ],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 12.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 27] new blocks found proof work mining nodes store entire transaction history current cell set node verify new blocks transactions relay blocks transactions select chain fork agree nodes verifiers network light node trust nodes subscribe store subset cells concerned use minimal resources users increasingly rely mobile devices mobile apps access internet light node designed run mobile devices uniform blockchain networks node role performs function currently facing severe challenges nodes validate blocks transaction data requiring minimum external trust incur higher cost inconvenient run light clients trade minimal trust substantial cost reduction transaction verification leading better user experience mature crypto economy network largest group nodes light nodes followed nodes mining nodes light nodes depend nodes state state verification large number light nodes require large number nodes serve ckb s economic model computation storage resources required node kept reasonable level barriers",
    "metadata": {
      "chunk_id": "09ef3a070ccd8df66af8057c3ebb114c",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 28] nodes depend nodes state state verification large number light nodes require large number nodes serve ckb s economic model computation storage resources required node kept reasonable level barriers running node low leading large group service providers light nodes highly decentralized network 7 summary envision layered crypto economy ckb base layer ckb decentralized trust root crypto economy ensures security trustless activities upper layers s common knowledge custody network states verified global consensus stored highly available peer peer network ckb designed scratch meet needs layered architecture design focuses states computation ckb users developers define issue transfer store crypto assets create digital identities utilize identities crypto economy imagination bounds use 8 references satoshi nakamoto bitcoin peer peer electronic cash system 2008 vitalik buterin ethereum generation smart contract decentralized application platform 2014 9 appendix common knowledge knowledge s",
    "metadata": {
      "chunk_id": "7321b0e7e48c0a0333c265e90df88af9",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [
          "fine"
        ],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 12.0,
      "source": "Nervos.txt"
    }
  },
  {
    "text": "[Section 29] satoshi nakamoto bitcoin peer peer electronic cash system 2008 vitalik buterin ethereum generation smart contract decentralized application platform 2014 9 appendix common knowledge knowledge s accepted community participants community accept knowledge know community accept knowledge past common knowledge scattered individual s minds formation required repeated communication confirmation today advancement cryptography distributed ledger technology algorithms machines replacing humans medium formation storage common knowledge piece data blockchain including digital assets smart contracts piece common knowledge blockchains common knowledge bases participating blockchain network implies accepting helping validate common knowledge contained blockchains store transactions proofs users trust validity transactions know users trust ways knowledge people base plan communicated crucial problem theory explaining economic process problem best way utilizing knowledge initially dispersed people",
    "metadata": {
      "chunk_id": "d49ca62d1b492df2f3d3576ae3835123",
      "entities": {
        "email": [],
        "crypto_address": []
      },
      "risk_features": {
        "regulatory": [],
        "technical": [],
        "financial": [],
        "operational": []
      },
      "risk_score": 0.0,
      "source": "Nervos.txt"
    }
  }
]