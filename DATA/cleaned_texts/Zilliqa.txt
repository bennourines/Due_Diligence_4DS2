b z illiqa technical whitepaper version 0 1 august 10 2017 z illiqa team m www zilliqa com b enquiry zilliqa com 7 zilliqa consensus network protocols reengineering parameters existing protocols bitcoin ethereum e g block size block rate speedup support applications need processing thousands tx s requires rethinking underlying protocols scratch present z illiqa xe2 x80 x94 new blockchain platform designed scale transaction rates number miners z illiqa increases transaction rates expected increase specifically z illiqa xe2 x80 x99s design allows transaction rates roughly double nodes added network writing ethereum mining network 30 000 nodes ethereum xe2 x80 x99s present capacity z illiqa expect process thousand times transaction rates ethereum z illiqa redesign scratch research development 2 years cornerstone z illiqa xe2 x80 x99s design idea sharding xe2 x80 x94 dividing mining network smaller consensus groups called shards capable processing transactions parallel mining network z illiqa 8000 miners z illiqa automatically creates 10 sub networks size 800 miners decentralized manner trusted co ordinator sub network agree set 100 transactions time epoch 10 sub networks agree total 1000 transactions aggregate key aggregating securely ensure sub networks process different transactions overlaps double spending assumptions similar existing blockchain based solutions assume mining network fraction malicious nodes identities total computational power fraction 1 4 complete network based standard proof work scheme new layer blockchain structure features highly optimized consensus algorithm processing shards z illiqa comes innovative special purpose smart contract language execution environment leverage underlying architecture provide large scale highly efficient computation platform smart contract language z illiqa follows dataflow programming style smart contract represented directed graph nodes graph operations functions abstract xe2 x80 x94existing cryptocurrencies smart contract platforms known scalability issues e number transactions capable processing second limited usually 10 number applications utilizing public cryptocurrencies smart contract platforms grow demand processing high transaction rates order hundreds thousands tx s increasing work present z illiqa xe2 x80 x94 new blockchain platform designed scale transaction rates number miners z illiqa increases transaction rates expected increase ethereum xe2 x80 x99s present network size 30 000 miners z illiqa expect process thousand times transaction rates ethereum cornerstone z illiqa xe2 x80 x99s design idea sharding xe2 x80 x94 dividing mining network smaller shards capable processing transactions parallel z illiqa proposes innovative special purpose smart contract language execution environment leverages underlying architecture provide large scale highly efficient computation platform smart contract language z illiqa follows dataflow programming style makes ideal running large scale computations easily parallelized examples include simple computations search sort linear algebra computations complex computations training neural nets data mining financial modeling scientific computing general mapreduce task ntroduction cryptocurrencies smart contract platforms shared computational resource view platforms new generation computers synchronize thousands individual computers existing cryptocurrencies smart contract platforms widely recognized limitations scaling average transaction rates bitcoin 1 ethereum 2 related cryptocurrencies limited 10 usually 3 7 transactions second tx s number applications utilizing public cryptocurrencies smart contract platforms grow demand processing high transaction rates order hundreds tx s increasing global payment network likely require tens thousands tx s capacity build decentralized open blockchain platform capable processing scale limitations scaling existing protocols somewhat fundamental xe2 x80 x94 rooted design 1 x0can arc nodes represent output input second node gets activated operational soon inputs valid dataflow contract inherently parallel suitable decentralized systems z illiqa sharded architecture ideal running large scale computations easily parallelized examples include simple computations search sort linear algebra computations complex computations training neural net data mining financial modeling scientific computing general mapreduce task document outlines technical design z illiqa blockchain protocol z illiqa new conceptually clean modular design layers cryptographic layer section iii data layer section iv network layer section v consensus layer section vi smart contract layer section vii incentive layer section viii present different layers discuss system settings underlying assumptions threat model section ii byzantine nodes collude assume total computation power byzantine adversaries confined standard cryptographic assumptions probabilistic polynomial time adversaries assume messages honest nodes absence network partition delivered honest destinations certain bound xce xb4 xce xb4 time varying bound xce xb4 ensure liveness safety 3 case timing connectivity assumptions met possible byzantine nodes delay messages significantly simulating gain computation power worse xe2 x80 x9ceclipse xe2 x80 x9d network 4 event network partition dictated cap theorem choose consistency availability 5 z illiqa choose consistent sacrifice availability iii c ryptographic l ayer cryptographic layer defines cryptographic primitives z illiqa similar blockchain platforms z illiqa relies elliptic curve cryptography digital signatures memory hard hash function proofof work pow whitepaper extensively use sha3 6 hash function present design sha3 originally based keccak 7 widely different blockchain platforms particular ethereum near future switch keccak enable better interoperability platforms ii s ystem s etting ssumptions entities z illiqa main entities z illiqa users miners user external entity uses z illiqa xe2 x80 x99s infrastructure transfer funds run smart contracts miners nodes network run z illiqa xe2 x80 x99s consensus protocol rewarded service rest whitepaper interchangeably use terms miner node z illiqa xe2 x80 x99s mining network divided smaller networks referred shard miner assigned shard set miners called ds nodes set ds nodes referred ds committee shard ds committee leader leaders play important role z illiqa xe2 x80 x99s consensus protocol overall functioning network user public private key pair digital signature scheme miner network associated ip address public key serves identity intrinsic token z illiqa intrinsic token called zillings zils short zillings platform usage rights users terms pay transaction processing run smart contracts whitepaper reference value balance payment assumed counted zil adversarial model assume mining network point time fraction byzantine nodes identities total computational power f n4 complete network 0 xe2 x89 xa4 f 1 n total size network factor 14 arbitrary constant bounded away 31 selected yield reasonable constant parameters assume honest nodes reliable protocol runs failed disconnected nodes counted byzantine fraction byzantine nodes deviate protocol drop modify messages send different messages honest nodes schnorr signature z illiqa employs elliptic curve based schnorr signature algorithm ec schnorr 8 base signing algorithm instantiate scheme secp256k1 curve 9 curve currently bitcoin ethereum different signing algorithm called ecdsa choosing ecschnorr ecdsa benefits discuss 1 non malleability informally non malleability property means given set signatures generated message private key hard adversary produce new signature message valid corresponding public key unlike ecdsa malleable ec schnorr proven nonmalleable 10 2 multisignature multisignature scheme allows multiple signers xe2 x80 x9caggregate xe2 x80 x9d signatures given message single signature authenticated single public key xe2 x80 x9caggregates xe2 x80 x9d keys authorized parties ec schnorr natively multisignature scheme 11 ecdsa allows creating multisignatures flexible way z illiqa uses ec schnorr based multisignatures reduce signature size multiple signatures required message smaller signatures particularly important consensus protocol multiple parties need agree data signing 2 x0c3 speed ec schnorr faster ecdsa requires computing inverse modulo large number inversion required ec schnorr exact ec schnorr key generation signing verification procedures given appendix appendix present ec schnorr multisignature scheme account normal account created generating ecschnorr private key contract account created account account identified address derived differently depending type address normal account derived account xe2 x80 x99s private key given private key sk address anormal 160 bit value computed anormal lsb160 sha3 256 pubkey sk b proof work lsb160 xc2 xb7 returns rightmost 160 bits input pubkey xc2 xb7 returns public key corresponding input secret key address contract account computed address creator transactions creator account sent aka account nonce described z illiqa uses pow prevent sybil attacks generate node identities contrast existing blockchain platforms particular bitcoin 1 ethereum 12 pow reach distributed consensus z illiqa employs ethash 13 pow algorithm ethereum 1 0 ethash memory hard hash function designed easy gpus hard specialized computing hardware asics achieve ethash computation requires considerable memory gbs o bandwidth function invoked parallel specialized computing hardware roughly speaking ethash takes data instance block header nonce 64 bits inputs generates 256bits digest algorithm consists subroutines run given order 1 seed generation seed sha3 256 digest updated 30000 blocks called epoch epoch sha3 256 hash series 32 bytes zeros epoch sha3 256 hash previous seed 2 cache generation seed generate pseudorandom cache sha3 512 size cache linearly increases epoch initial size cache 16 mb 3 dataset generation cache generate dataset xe2 x80 x9citem xe2 x80 x9d dataset depends small number items cache dataset updated epoch miners changes frequently size dataset increases linearly epoch initial size dataset 1 gb 4 mining verification mining involves grabbing random slices dataset hashing verification uses cache regenerate specific pieces dataset needed compute hash acontract lsb160 sha3 256 address nonce address address creator account nonce creator xe2 x80 x99s nonce value account normal contract associated account state account state key value store comprises following keys 1 account nonce 64 bits counter initialized 0 counts number transactions sent normal account case contract account counts number contract creations account 2 balance 128 bits non negative value account receives tokens account received added account xe2 x80 x99s balance account sends tokens account balance reduced appropriate 3 code hash 256 bits stores sha3 256 digest contract code normal account sha3 256 digest string 4 storage root 256 bits account storage key value store 256 bit keys 256 bit values storage root sha3 256 digest represents storage instance storage trie storage root digest root trie global state state z illiqa mapping account addresses account states implemented trie like data structure b transactions transaction sent normal account address updates global state z illiqa transaction following fields 1 version 32 bits current version 2 nonce 64 bits counter equal number transactions sent sender transaction 3 160 bits destination account address case transaction creates new contract account field rightmost 160 bits sha3 256 string 4 128 bits transaction transferred destination address iv data l ayer broadly speaking data layer defines data constitutes global state z illiqa extension defines data needed different entities z illiqa update global state accounts addresses state z illiqa account based system ethereum types accounts normal account contract 3 x0c2 transaction blocks discussed earlier ds block contains information nodes reach consensus transactions tx block stores information transactions agreed nodes ds block ds block linked multiple tx blocks tx block parts header data signature header consists following fields 1 type 8 bits tx block types micro block 0x00 final block 0x01 section v d 2 version 32 bits current version 3 previous hash 256 bits sha3 256 digest parent block header 4 gas limit 128 bits current limit gas expenditure block 5 gas 128 bits total gas transactions block 6 number 256 bits number ancestor blocks genesis block block number 0 7 timestamp 64 bits unix xe2 x80 x99s time time creation block 8 state root 256 bits sha3 256 digest represents global state transactions executed finalized global state stored trie state root digest root trie 9 transaction root 256 bits sha3 256 digest represents root merkle tree stores transactions present block 10 tx hashes 256 bits list sha3 256 digests transactions signature transaction hashed 11 pubkey 264 bits ec schnorr public key leader proposed block 12 pubkey micro blocks unlimited list ecschnorr public keys 264 bits length list contains public keys leaders proposed transactions field present final block 13 parent block hash 256 bits sha3 256 digest previous final block header 14 parent ds hash 256 bits sha3 256 digest parent ds block header 15 parent ds block number 256 bits parent ds block number data tx block contains set transactions following fields 1 tx count 32 bits number transactions block 2 tx list unlimited list transactions signature tx block contains ecschnorr based multisignature following fields 1 signature 512 bits signature ec schnorr based multisignature tx block header signed set nodes signature produced different set nodes depending micro block 5 gas price 128 bits gas defined smallest unit computation gas price sender willing pay unit gas computations incurred transaction processing 6 gas limit 128 bits maximum gas processing transaction 7 code unlimited expandable byte array specifies contract code present transaction creates new contract account 8 data unlimited expandable byte array specifies data process transaction present transaction invokes contract destination address 9 pubkey 264 bits ec schnorr public key verify signature pubkey field determines sending address transaction 10 signature 512 bits ec schnorr signature entire data transaction uniquely identified transaction id xe2 x80 x94 sha3 256 digest transaction data excludes signature field c blocks z illiqa protocol introduces types blocks blockchains transaction blocks tx block directory service blocks ds block tx block contains transactions sent users ds block contains metadata miners participate consensus protocol 1 ds blocks ds block parts header signature header ds block following fields 1 version 32 bits current version 2 previous hash 256 bits sha3 256 digest parent block header 3 pubkey 264 bits public key miner pow block header 4 difficulty 64 bits calculated previous block xe2 x80 x99s difficulty block number stores difficulty pow puzzle 5 number 256 bits number ancestor blocks genesis block block number 0 6 timestamp 64 bits unix xe2 x80 x99s time time creation block 7 mixhash 256 bits digest calculated nonce allows detecting dos attacks 8 nonce 64 bits solution pow signature ds block contains following fields 1 signature 512 bits signature ec schnorr based multisignature ds block header signed ds nodes 2 bitmap 1024 bits records ds nodes participated multisignature denote bitmap bit vector b b 1 th node signed header b 0 ds blocks form ds blockchain 4 x0ca final block details signatories given section v d 2 bitmap 1024 bits records nodes participated multisignature denote bitmap bit vector b b 1 th node signed header b 0 final blocks form transaction blockchain transaction blockchain include micro blocks successful bootstrapping phase time composition ds nodes stipulated predefined window size n0 recent n0 nodes successfully mined ds block form ds committee average time mining consecutive dsblocks referred ds epoch value ds epoch set way minimize chances competing blocks start ds epoch new ds node joins ds committee oldest member ds committee churned fixes size ds committee n0 ds epoch newest member ds committee leader leads consensus protocol epoch section vi consensus protocol induces strict ordering members ds committee ds committee size sufficiently large 800 n0 members committee 31 byzantine high probability 2 resolving conflicts consensus protocol presented section vi permit forks ds blockchain forks occur multiple nodes solve puzzle roughly time order resolve conflict ds node retrieves nonce field received headers sorts increasing order let suppose largest nonce th ds node nimax leader ds committee proposes header corresponds largest nonce seen runs consensus protocol agree ds block header th ds node agrees accept proposed header corresponding nonce larger equal nimax consensus reached signature ds block built agreed winner leader 3 generating shards ds committee elected actual sharding network start order node participate underlying consensus protocol perform proof work pow2 sharding protocol repeated start ds epoch algorithm pow2 given algorithm 2 v n etwork l ayer z illiqa designed scale transaction rates main idea sharding e dividing mining network small shards capable processing transactions parallel section present idea network transaction sharding network sharding network sharding e dividing mining network smaller shards step process dedicated set nodes called directory service committee ds committee elected shard network assign nodes shard present processes detail 1 directory service committee facilitate sharding network elect group nodes called directory service ds nodes ds nodes form ds committee election ds nodes based proof work puzzle refer pow1 algorithm pow1 given algorithm 1 algorithm 1 pow1 ds committee election 1 input current ds epoch dsi xe2 x88 x921 prev ds committee composition output header ds block header competing node epoch randomness ds blockchain dbi xe2 x88 x921 recent ds block start th epoch 2 r1 xe2 x86 x90 getepochrand dbi xe2 x88 x921 epoch randomness transaction blockchain tbj recent tx block start th epoch 3 r2 xe2 x86 x90 getepochrand tbj pk node xe2 x80 x99s public key ip node xe2 x80 x99s ip address 4 5 nonce mixhash xe2 x86 x90 ethash pow pk ip r1 r2 header xe2 x86 x90 buildheader nonce mixhash pk algorithm 2 pow2 shard membership header includes pk nonce fields ip header multicast members ds committee 6 7 multicasttodsi xe2 x88 x921 ip header return header 1 input current ds epoch dsi current ds committee composition output nonce mixhash outputs ethash pow competing node epoch randomness ds blockchain dbi xe2 x88 x921 recent ds block start th epoch node successfully produced valid nonce pow1 earlier nodes proposes header new ds block recall ds block header signature node pow1 generates ds block header header multicast nodes ds committee ds committee runs consensus proposed ds block header builds signature 2f ds nodes signed ds block header committed ds blockchain 2 r xe2 x86 x90 getepochrand dbi pk node xe2 x80 x99s public key ip node xe2 x80 x99s ip address 3 nonce mixhash xe2 x86 x90 ethash pow pk ip r ip header multicast members ds committee 4 5 multicasttodsi nonce mixhash pk ip return nonce mixhash computed valid nonce mixhash pow2 multicast ds committee ds nodes 5 x0cthe sender xe2 x80 x99s address e address account example account address 160 bit integer bounded collectively accept pow solutions sharded l consensus committees shards n0 nodes run consensus number pow2 solutions received leader ds committee initiates consensus protocol agree set valid pow2 solutions end consensus protocol leader generates ec schnorr multisignature signed ds nodes order proceed 2 3 ds nodes agreed set acceptable pow2 solutions sharding leverages deterministic function assign node shard let assume need shards having n0 nodes nonce values sorted increasing order n0 nodes assigned shard n0 shard identity miner proposed largest nonce shard declared leader induces strict ordering members shard n0 sufficiently large 800 shard 13 byzantine high probability blog2 c 1 xe2 x89 xa4 160 practice smaller 100 assigned shard identified transaction multicast nodes shard broadcast transaction reaches leader assigned shard includes tx block runs consensus protocol double spend replay attacks easily detected nonce present transaction recall transaction nonce counts number transactions sent sender xe2 x80 x99s account transaction gets transaction blockchain nonce updated account xe2 x80 x99s state global state transaction nonce value smaller equal current value global state gets rejected miners sharding transactions based sender xe2 x80 x99s account address natively allows shard members detect double spend transaction sender processed shard 2 transaction processing nodes committee propose transactions transactions sent leader run consensus protocol set transactions forms tx block blocks proposed shard called micro block identified type marker 0x00 micro block contains ec schnorr multisignature 23 nodes shard leader builds bitmap b identifies public keys signers b 1 th member shard signed tx block header shard reaches consensus tx block leader multicasts block header signature ds nodes ds nodes broadcast ds committee block reaches leader data block asynchronously sent nodes ds committee aggregates blocks sent shards runs round consensus protocol agree final block final block tx block identified type marker 0x01 final block contains ec schnorr multisignature 2 3 n0 nodes ds committee leader ds committee builds bitmap b identifies public keys signers b 1 th member ds committee signed tx block header final block header signature multicast nodes shard actual tx block data sent ds nodes shard following steps taken process final block 1 node shard verifies ec schnorr multisignature public keys ds nodes signatures valid 32 n0 public keys represented bitmap nodes perform checks b public channel ds nodes publish certain information public channel including identities connection information ds nodes list nodes shard sharding logic transactions explained section v d public channel untrusted assumed accessible nodes implementation broadcast primitive implements public channel user blockchain like submit transaction acceptance check information sharding shard responsible processing transaction information published public channel expected signed 2 3 ds nodes verified node user c new nodes joining z illiqa new node join network attempt solve pow1 ds node pow2 member shard end need obtain information randomness required pow1 pow2 blockchains obtains randomness information new node submit solution ds committee d transaction sharding processing presented section v network sharding creates shards capable processing transactions parallel section present particular transaction gets assigned shard transactions processed n purpose use following abstraction xe2 x88 x92 xe2 x86 x92 b indicate transaction n zil sender xe2 x80 x99s account receiver xe2 x80 x99s account b n 1 transaction assignment transaction xe2 x88 x92 xe2 x86 x92 b gets processed single shard assuming shards numbered 0 xe2 x88 x92 1 transaction assigned shard identified blog2 c 1 rightmost bits 6 x0cpbft relies correct leader begin phase proceed sufficient majority exists case leader byzantine stall entire consensus protocol address challenge pbft offers view change protocol replace byzantine leader nodes progress bounded time independently announce desire change leader quorum 23 n nodes decides leader faulty leader known schedule takes owing multicast node prepare commit phase communication complexity pbft normal case o n2 2 transaction hash included final block header node checks corresponding transaction content available corresponding transaction proposed shard node belongs hash transaction data compared hash contained final block header transaction proposed shard transaction data shared asynchronously shards 3 transaction data available data final block reconstructed tx block appended local transaction blockchain account state global state accordingly updated 4 transaction content available node temporarily invalidates sending account transaction local view accounts pending transactions account rejected local transaction content brought sync global state rejected transactions retried sending node b improving efficiency classical pbft uses message authentication code mac authenticated communication nodes mac requires secret key shared nodes nodes consensus group agree record communication complexity o n2 node quadratic complexity pbft impractical committee 20 nodes improve efficiency use ideas inspired byzcoin 15 1 replace mac digital signatures effectively reduce communication overhead o n 2 meantime allow nodes verify agreement typical way collect signatures honest majority append agreement resulting agreement size linear size consensus group improve employ ec schnorr multisignatures aggregate signatures o 1 size multisignature directly use classical ec schnorr multisignature scheme pbft setting classical setting signers agree signing given message signature valid signers signed message pbft setting require message signed 23 n nodes consensus group main modification required maintain bitmap b signers participate signing process th node participated process b 1 0 bitmap build leader bitmap verifier validate signature resulting protocol left appendix b vi c onsensus l ayer mentioned earlier shard ds committee run consensus protocol micro blocks final blocks respectively section present consensus layer defines consensus protocol run shard ds committee rest discussion refer shards ds committees collectively consensus group practical byzantine fault tolerance core z illiqa xe2 x80 x99s consensus protocol relies practical byzantine fault tolerance pbft protocol proposed castro liskov 3 improve efficiency idea employing ec schnorr multisignature pbft protocol developed 14 15 use ec schnorr multisignature lowers normal case communication latency o n2 o n reduces signature size o n o 1 n size consensus group section present overview pbft pbft nodes consensus group ordered sequence primary node leader referred backup nodes round pbft phases discussed 1 pre prepare phase phase leader announces record tx block case group agree 2 prepare phase receiving pre prepare message node validates correctness multicasts prepare message nodes 3 commit phase receiving 23 n prepare messages node multicasts commit message group finally node waits 23 commit messages ensure sufficient number nodes decision honest nodes accept valid record c z illiqa consensus z illiqa use pbft basis consensus protocol employ rounds ec schnorr multisignatures replace prepare commit phases pbft different modifications pbft phases explained 1 pre prepare phase standard pbft leader distributes tx block statement signed leader nodes consensus group 2 prepare phase honest nodes check validity tx block leader collects responses 2n 3 nodes guarantees statement 7 x0cproposed leader safe consistent previous histories signature generated ecschnorr multisignature leader builds bitmap nodes signed tx block 3 commit phase ensure 2n 3 nodes know fact 2n nodes verified 3 tx block perform second round ec schnorr multisignature statement signed multisignature generated round end phases consensus reached tx block proposed leader computations training neural net data mining financial modeling etc z illiqa xe2 x80 x99s computational sharding approach relies new smart contract language turing complete scales better multitude applications smart contract language z illiqa follows dataflow programming style 16 17 dataflow execution model contract represented directed graph nodes graph primitive instructions operations directed arcs nodes represent data dependencies operations e output input second node gets activated operational soon inputs available stands contrast classical von neumann execution model employed ethereum instruction executed program counter reaches regardless executed earlier key advantage employing dataflow approach instruction executed nodes graph activated time executed parallel simple principle provides potential massive parallel execution present simple sequential program figure 1a instructions figure 1b present dataflow variant von neumann execution model program run time units computing b finally c model capture fact b independently computed dataflow program hand compute values parallel node performs addition gets activated soon b available d leader change consensus protocol leader honest drive nodes consensus group reach agreements new sets transactions continuously leader byzantine intentionally delay drop messages honest nodes slow protocol penalize malicious leaders protocol changes leader shard ds committee periodically prevents byzantine leader stall consensus protocol infinite time nodes ordered leader chosen round robin manner fact leader shard changed micro block leader ds committee changed final block let assume size consensus group n ds epoch allow maximum n final blocks final block aggregating maximum 1 micro block shard vii s mart c ontract l ayer z illiqa comes innovative special purpose smart contract language execution environment leverages underlying architecture provide large scale highly efficient computation platform section present smart contract layer employs dataflow programming architecture y x 20 xe2 x88 x97 computational sharding dataflow paradigm z illiqa xe2 x80 x99s smart contract language execution platform designed leverage underlying network transaction sharding architecture sharded architecture ideal running computation intensive tasks efficient manner key idea following subset network shard perform computation refer approach computational sharding contrast existing smart contract architectures ethereum computational sharding z illiqa takes different approach process contracts ethereum node required perform computation validate outcome computation update global state albeit secure fully redundant programming model prohibitively expensive running large scale computations easily parallelized examples include simple computations search sort linear algebra computations complex b x xe2 x88 x97y b y 20 c b c simple program b dataflow program fig 1 simple sequential program instructions b dataflow variant run z illiqa xe2 x80 x99s sharded network node dataflow program eventually attributed single shard small subset nodes shard architecture ideal mapreduce style computational tasks node perform mapping task node work reducer aggregate work mapper order facilitate execution dataflow program z illiqa xe2 x80 x99s smart contract language following features 1 operating virtual memory space shared globally entire blockchain 8 x0c2 locking intermediate cells virtual shared memory space execution 3 checkpointing intermediate results execution committed blockchain learning imperative infrastructure allows deep learning models train large datasets known training large datasets crucial model xe2 x80 x99s accuracy end z illiqa xe2 x80 x99s computational sharding dataflow language particularly useful build machine learning applications serve infrastructure run tools like tensorflow1 tasking groups z illiqa nodes independently perform different computations computing gradients apply activation function compute training loss etc 3 application high complexity high precision algorithms different applications mentioned applications computations financial models require high precision minor deviation computation incur heavy losses investments applications task consensus groups larger number nodes z illiqa allow cross check computational results key challenge offloading computational tasks financial modeling algorithms public platform z illiqa concern data privacy intellectual property algorithms begin envision certain known portion computation placed z illiqa efficient secure computation future research development z illiqa strengthen protection data privacy intellectual property applications b smart security budgeting apart form benefits parallelization offered dataflow computation model z illiqa provides flexible security budgeting mechanism computational sharding feature enabled sharding computational resources blockchain network overlay consensus process computational sharding allows users z illiqa applications running z illiqa specify sizes consensus groups compute subtasks consensus group tasked compute subtask produce results user specifies condition acceptance results e g consensus group produce results 3 4 produce results etc user application running z illiqa budget wants spend computing security respectively particular user running particular deep learning application spend gas fee running different neural network tasks letting nodes repeating computation case specify smaller consensus group running neural network computation hand sophisticated financial modeling algorithm requires greater precision task consensus groups larger number nodes compute critical portions algorithm resilient potential tampering manipulation results viii ncentive l ayer token supply z illiqa finite supply 21 billion zils smallest unit 10 xe2 x88 x9212 zil final tx block comes block reward generates new tokens block reward spread period 10 years decreasing time aim roughly 80% tokens 4 years remaining 20% 6 years token emission xe2 x80 x9csmooth xe2 x80 x9d sense block reward reduce drastically certain number blocks smooth reduction block reward means network hashrate expected stable reward reduces gradually time 10 years expect reached significant scale terms number nodes network users executing transactions expect market stabilized certain rates transaction fees fully sustain running network need new tokens entering system rewards c scalable applications examples z illiqa aims provide platform run highly scalable computations multitude fields data mining machine learning financial modeling supporting efficient sharding turing complete programs challenging exist public blockchains support turing complete smart contracts e g ethereum z illiqa focuses specific applications requirements met today 1 computation parallelizable computation load scientific computing large data typical example requires large distributed computing power computations highly parallelizable examples include linear algebra operations large matrices search sea huge data simulation large dataset z illiqa provides computing tasks inexpensive short turnaround alternative right incentive place computational sharding security budgeting z illiqa leveraged readily available highly reliable resource heavy computation load 2 train neural nets growing popularity use cases machine learning particular deep b incentivizing miners miners reach consensus transactions process perform computations smart contract update global state miners incentivized requiring sender transaction pay gas upfront 1 https www tensorflow org 9 x0crecall final tx block aggregates micro block shard micro tx block contains gas field stores total gas transactions block final tx block gas field sum gas field micro txblock tx block proposed corresponding gas block reward equitably distributed 1 leaders shards proposed micro block 2 leader ds committee proposed final case equitable distribution possible distribution slightly biased leader ds committee reward m total number stake holders reward n leader shard gets b m n c leader ds committee gets m xe2 x88 x92 n xc2 xb7 bm c n leader shard changed new micro block proposed member shard gets rewarded similarly leader ds committee changed final block member ds committee rewarded z illiqa proposes smart contract platform available byzcoin omniledger z illiqa xe2 x80 x99s smart contract platform takes different approach compared ethereum z illiqa xe2 x80 x99s smart contract platform leverages underlying sharding architecture based dataflow programming advantages dataflow programs inherent concurrency parallelism easy reason correctness natural composability functions programs etc x f uture r esearch d irections discuss ongoing future directions research improve z illiqa state sharding increase z illiqa xe2 x80 x99s user base high transaction throughput come following challenge efficiently handle continuous influx blocks modify global state referred state sharding literature essence state sharding alleviate nodes storing receiving blocks transactions way reduce storage communication load nodes constitute scaling factor throughput non trivial design secure efficient state sharding scheme cross shard communications arising state sharding outweigh performance gains research needs address additional complexities secure proof stake spos best knowledge literature proposes secure pos scheme base z illiqa xe2 x80 x99s building blocks pow scheme given significant performance gain pos consensus algorithms worthwhile investigating pos paradigm search secure efficient pos scheme z illiqa storage pruning currently exploring ways securely prune dated blocks stored blockchain reduce storage requirements ease joining process new nodes consider multi grade storage compression blocks transactions possible solutions cross chain support z illiqa intention complement public blockchains build healthy ecosystem provide end users broad spectrum platforms choice applications end z illiqa seek technical solutions support gradual cross chain communication potentially enable cross chain applications privacy preserving computation desirable applications particular financial modeling applications strong privacy intellectual property protection running z illiqa solutions based oblivious ram hide access pattern encrypted data 21 zksnark 22 hide input program private function evaluation 23 hide contract xe2 x80 x99s business logic investigated ix r elated w ork z illiqa developed ideas bitcoin ng 18 collective signing cosi 14 byzcoin 15 elastico 19 omniledger 20 bitcoin ng proposed idea decouple leader election block proposals bitcoin leader elected mining keyblock mint microblocks 10 minute block interval idea byzcoin 15 idea network transaction sharding bitcoin like system proposed 19 network transaction sharding solve scalability issues shard needs sign tx block makes total number signatures linear number signers eventually results large block size bottleneck broadcast multi cast multisignatures 11 provides solution problem cosi 14 uses ec schnorr multisignature scheme design protocol collective signing cosi proposed work hostile environment public blockchain byzantine nodes significant enhancements develop cosi scheme derive secure scheme apply z illiqa proposals surfaced sidestep inherent scalability limitation existing blockchain protocols instance parameterizing original bitcoin protocol e g increasing block sizes moving computation offchain e g micropayment channels lightening networks creating hierarchy blockchains e g sidechains protocols directly blockchain protocol scalable z illiqa targets heart scalability problem xe2 x80 x93 blockchain z illiqa seen extension byzcoin omniledger security performance optimizations xi conclusion whitepaper presented z illiqa xe2 x80 x99s sharding architecture allows mining network process transactions parallel reach high throughput z illiqa 10 x0ccomes unique smart contract platform leverages underlying sharing architecture follows dataflow programming paradigm new smart contract language ideal running computation intensive task efficient manner 21 e stefanov m van dijk e shi c w fletcher l ren x yu s devadas xe2 x80 x9cpath oram extremely simple oblivious ram protocol xe2 x80 x9d 2013 acm sigsac conference computer communications security ccs xe2 x80 x9913 berlin germany november 4 8 2013 2013 pp 299 xe2 x80 x93310 22 e ben sasson chiesa e tromer m virza xe2 x80 x9csuccinct noninteractive zero knowledge von neumann architecture xe2 x80 x9d proceedings 23rd usenix security symposium san diego usa august 20 22 2014 2014 pp 781 xe2 x80 x93796 23 p mohassel s s sadeghian n p smart xe2 x80 x9cactively secure private function evaluation xe2 x80 x9d advances cryptology asiacrypt 2014 20th international conference theory application cryptology information security kaoshiung taiwan r o c december 7 11 2014 proceedings ii 2014 pp 486 xe2 x80 x93505 24 bsi xe2 x80 x9ctechnical guideline tr 03111 elliptic curve cryptography xe2 x80 x9d federal office information security tech rep 01 2012 25 d j bernstein xe2 x80 x9cmulti user schnorr security revisited xe2 x80 x9d iacr cryptology eprint archive vol 2015 p 996 2015 online available http eprint iacr org 2015 996 26 m michels p horster xe2 x80 x9con risk disruption multiparty signature schemes xe2 x80 x9d proceedings international conference theory applications cryptology information security advances cryptology ser asiacrypt xe2 x80 x9996 london uk uk springer verlag 1996 pp 334 xe2 x80 x93345 r eferences 1 s nakamoto xe2 x80 x9cbitcoin peer peer electronic cash system http bitcoin org bitcoin pdf xe2 x80 x9d 2008 2 e foundation xe2 x80 x9cethereum xe2 x80 x99s white paper xe2 x80 x9d https github com ethereum wiki wiki white paper 2014 3 m castro b liskov xe2 x80 x9cpractical byzantine fault tolerance xe2 x80 x9d proceedings symposium operating systems design implementation ser osdi xe2 x80 x9999 berkeley usa usenix association 1999 pp 173 xe2 x80 x93186 4 e heilman kendler zohar s goldberg xe2 x80 x9ceclipse attacks bitcoin xe2 x80 x99s peer peer network xe2 x80 x9d 24th usenix security symposium usenix security 15 washington d c usenix association 2015 pp 129 xe2 x80 x93144 5 s gilbert n lynch xe2 x80 x9cbrewer xe2 x80 x99s conjecture feasibility consistent available partition tolerant web services xe2 x80 x9d acm sigact news 2002 p 2002 6 nist xe2 x80 x9csha 3 standard permutation based hash extendable output functions xe2 x80 x9d 2015 7 b guido d joan p michae xcc x88l v gilles xe2 x80 x9cthe keccak reference xe2 x80 x9d 2011 8 c schnorr xe2 x80 x9cefficient signature generation smart cards xe2 x80 x9d j cryptology vol 4 3 pp 161 xe2 x80 x93174 1991 9 c research xe2 x80 x9csec 2 recommended elliptic curve domain parameters xe2 x80 x9d 2000 online available http www secg org download aid 386 sec2 final pdf 10 poelstra xe2 x80 x9cschnorr signatures non malleable random oracle model xe2 x80 x9d 2014 11 s micali k ohta l reyzin xe2 x80 x9caccountable subgroup multisignatures extended abstract xe2 x80 x9d proceedings 8th acm conference computer communications security ser ccs xe2 x80 x9901 new york ny usa acm 2001 pp 245 xe2 x80 x93254 12 g wood xe2 x80 x9cethereum secure decentralised generalised transaction ledger xe2 x80 x9d http gavwood com paper pdf 2014 13 xe2 x80 x9cethash xe2 x80 x9d https github com ethereum wiki wiki ethash accessed june 27 2017 version 23 14 e syta tamas d visher d wolinsky p jovanovic l gasser n gailly khoffi b ford xe2 x80 x9ckeeping authorities xe2 x80 x9dhonest bust xe2 x80 x9d decentralized witness cosigning xe2 x80 x9d ieee symposium security privacy sp 2016 san jose usa 22 26 2016 2016 pp 526 xe2 x80 x93545 15 e kokoris kogias p jovanovic n gailly khoffi l gasser b ford xe2 x80 x9cenhancing bitcoin security performance strong consistency collective signing xe2 x80 x9d 25th usenix security symposium usenix security 16 austin tx usa august 10 12 2016 2016 pp 279 xe2 x80 x93296 16 arvind d e culler xe2 x80 x9cannual review computer science vol 1 1986 xe2 x80 x9d j f traub b j grosz b w lampson n j nilsson eds palo alto usa annual reviews inc 1986 ch dataflow architectures pp 225 xe2 x80 x93253 17 l davis r m keller xe2 x80 x9cdata flow program graphs xe2 x80 x9d computer vol 15 2 pp 26 xe2 x80 x9341 feb 1982 18 eyal e gencer e g sirer r van renesse xe2 x80 x9cbitcoinng scalable blockchain protocol xe2 x80 x9d 13th usenix symposium networked systems design implementation nsdi 2016 santa clara usa march 16 18 2016 2016 pp 45 xe2 x80 x9359 19 l luu v narayanan c zheng k baweja s gilbert p saxena xe2 x80 x9ca secure sharding protocol open blockchains xe2 x80 x9d proceedings 2016 acm sigsac conference computer communications security vienna austria october 24 28 2016 2016 pp 17 xe2 x80 x9330 20 e kokoris kogias p jovanovic l gasser n gailly b ford xe2 x80 x9comniledger secure scale decentralized ledger xe2 x80 x9d iacr cryptology eprint archive vol 2017 p 406 2017 ppendix s chnorr d igital s ignature lgorithm ec schnorr single signer scheme ec schnorr works group discrete logarithm hard 8 24 25 z illiqa uses elliptic curve group defined popular secp256k1 curve denote c p g n set parameters define group p prime number specifies underlying field fp g base point curve n prime order g ec schnorr requires cryptographic hash function h instantiate sha3 256 6 ec schnorr set algorithms keygen sign verify present section algorithms scalar x point q denote scalar multiplication x q 1 keygen c algorithm takes curve parameters c returns pair public pk private sk keys keygen c p g n $ 1 choose sk xe2 x86 x90 1 n xe2 x88 x92 1 2 set pk xe2 x86 x90 sk g 3 return pk sk 2 sign c pk sk m algorithm run signer takes curve parameters c public key private key pair pk sk message sign m xe2 x88 x88 0 1 xe2 x88 x97 returns signature xcf x83 sign c pk sk m 1 2 3 4 5 6 7 8 11 $ choose k xe2 x86 x90 1 n xe2 x88 x92 1 set q xe2 x86 x90 k g set r xe2 x86 x90 h q pk m mod n r 0 goto 1 set s xe2 x86 x90 k xe2 x88 x92 r xc2 xb7 sk mod n s 0 goto 1 set xcf x83 xe2 x86 x90 r s return xcf x83 x0c3 verify c xcf x83 pk m algorithm run verifier wishes check validity signature takes curve parameters c signature xcf x83 public key pk message m returns 1 signature valid m pk returns 0 2 commitment generation signer pi choses $ random ki xe2 x86 x90 1 n xe2 x88 x92 1 computes qi ki g recall g base point elliptic curve n order g pi sends qi aggregator 3 challenge generation p aggregator computes aggregated keys pk p pki xe2 x88 x88p pki keys p computes q qi qi xe2 x80 x99s received previous step computes r xe2 x86 x90 h q pk m mod n sends r q pk pi 4 response generation signer pi checks integrity r received previously recomputing h q pk m checking equal received r check fails pi aborts protocol generates si xe2 x86 x90 ki xe2 x88 x92 r xc2 xb7 ski mod n sends si aggregator 5 response aggregation aggregator computes agp gregated response s s mod n builds aggregated signature xcf x83 r s sends m xcf x83 verifier 6 signature verification verifier checks signature valid performs following steps aggregate public keys p pk 0 b check xcf x83 valid ec schnorr signature m public key pk 0 invoking verify c xcf x83 pk 0 m returns output verify verify c xcf x83 pk m 1 2 3 4 5 6 parse r s xe2 x86 x90 xcf x83 r s xe2 x88 x88 1 n xe2 x88 x92 1 return 0 set q xe2 x86 x90 s g r pk q o neutral point return 0 set v xe2 x86 x90 h q pk m mod n v r return 1 return 0 b ec schnorr multisignature scheme 1 setting assumptions ec schnorr multisignature scheme 11 multisignature scheme t signers p1 pt aggregator verifier signers wish jointly sign message m aggregator plays role facilitator aggregates signatures sent individual signer verifier verifies aggregated signature role aggregator verifier played entity signer pi public private key pair pki ski ec schnorr single signer scheme denote p pk1 pkt set public keys assume public message mp known entity message mp specific application scenario following form know private key public key session id xxxx purpose message defeat certain known attacks scheme 26 2 multisignature protocol multisignature interactive protocol signers aggregator verifier figure 2 schematic representation protocol steps described ppendix b m ultisignature pbft classical ec schnorr multisignature protocol described appendix requires participation participants directly use pbft setting require message signed 23 n 1 nodes committee section present tweak protocol inspired 14 tweak consists maintaining bitmaps record participation protocol modified protocol given figure 3 briefly present protocol 1 time identity setup step exactly classical ec schnorr multisignature protocol presented appendix set successfully terminates steps protocol start 2 commitment generation step similar classical ec schnorr multisignature protocol difference participant pi sends public key pki qi aggregator 3 challenge generation step aggregator maintains bitmap bq 1 p initialized 0 qi pki received previous step aggregator sets bq 1 aggregator waits stipulated time handle network propagation delay computes following p aggregated keys pk xe2 x86 x90 pki xe2 x88 x88p pki xc2 xb7 bq e adds public keys p received qi b computes q xe2 x86 x90 bq 1 qi qi xe2 x80 x99s received previous step 1 time identity setup step run participant verifier start protocol signer pi currently involved signing protocol generates ec schnorr signature xcf x83i message mp pi sends xcf x83i pki verifier verifier performs following checks check pki xe2 x88 x88 p check fails verifier aborts b check xcf x83i valid ec schnorr signature mp pki invoking verify c xcf x83i pki mp verifier aborts signature verifications returns 0 signatures valid protocol proceeds step verifier receive xcf x83i pki p aborts record received signature pi uses bitmap z 1 p identity setup time process followed number steps set successfully terminates steps protocol start 12 x0cpi c mp m pki ski verifier c mp p z aggregator c m p xcf x83i xe2 x86 x90 sign c pki ski mp xcf x83i pki pki xe2 x88 x88 p abort xc2 xacverify c xcf x83i pki mp abort z 1 end setup phase xc2 xacz abort $ ki xe2 x86 x90 1 n xe2 x88 x92 1 qi xe2 x86 x90 ki g qi r q pk r0 xe2 x86 x90 h q pk m r0 6 r abort si xe2 x86 x90 ki xe2 x88 x92 r xc2 xb7 ski mod n p pk xe2 x86 x90 pki xe2 x88 x88p pki p q xe2 x86 x90 qi r xe2 x86 x90 h q pk m si p s xe2 x86 x90 si mod n xcf x83 xe2 x86 x90 r s m xcf x83 p pk 0 xe2 x86 x90 pki xe2 x88 x88p pki return verify c xcf x83 pk 0 m fig 2 multisignature ec schnorr verifier stores bit map z 1 p entry initialized 0 c computes r xe2 x86 x90 h q pk m mod n sends r q pk pi 4 response generation step similar classical ec schnorr multisignature protocol difference participant pi sends public key pki si aggregator 5 response aggregation step aggregator maintains bitmap bs 1 p initialized 0 si pki received previous step aggregator checks received si valid computing q0i xe2 x86 x90 si g r pki verifying q0i equal received qi values equal sets bs 1 step allows detect participants send arbitrary value si attempt mount dos attack aggregator waits stipulated time handle network propagation delay computes following bitmaps bq bs equal means set participants sent messages aggregator commitment generation response generation steps p aggregator computes aggregated response s si mod n builds aggregated signature xcf x83 r s sends xcf x83 m bq verifier b bitmaps equal means participant sent qi corresponding si aggregator computes set theoretic difference bq bs e set public keys pki xe2 x88 x88 p aggregator received qi corresponding si corresponding set public keys blacklisted aggregator initializes bs 0 computes intersection bq bs stores bq finally repeats protocol starting challenge generation step 6 signature verification verifier checks signature generated 23 p 1 participants checks multisignature valid rest steps classical ec schnorr multisignature protocol 13 x0cpi c mp pki ski aggregator c m bq bs p verifier c mp p z xcf x83i xe2 x86 x90 sign c pki ski mp xcf x83i pki $ ki xe2 x86 x90 1 n xe2 x88 x92 1 qi xe2 x86 x90 ki g pki xe2 x88 x88 p abort xc2 xacverify c xcf x83i pki mp abort z 1 end setup phase xc2 xacz abort qi pki pki xe2 x88 x88 p bq xe2 x86 x90 1 1 certain stipulated time p pk xe2 x86 x90 pki xe2 x88 x88p pki xc2 xb7 bq p q xe2 x86 x90 bq 1 qi r xe2 x86 x90 h q pk m mod n r q pk r0 xe2 x86 x90 h q pk m r0 6 r abort si xe2 x86 x90 ki xe2 x88 x92 r xc2 xb7 ski mod n si pki q0i xe2 x86 x90 si g r pki q0i qi bs xe2 x86 x90 1 certain stipulated time bs b pq s xe2 x86 x90 bs 1 si mod n xcf x83 xe2 x86 x90 r s blacklist bq bs bq xe2 x86 x90 bq xe2 x88 xa7 bs bs xe2 x86 x90 0 p goto 1 xcf x83 m bq p bq 2 p 3 1 return p0 pk 0 xe2 x86 x90 pki xe2 x88 x88p pki xc2 xb7 bq return verify c xcf x83 pk 0 m fig 3 ec schnorr multisignature variant pbft leader committee plays role aggregator aggregator maintains bitmaps bq 1 p bs 1 p verifier stores bit map z 1 p entries bitmaps initialized 0 bq bs returns bitmap represents set theoretic difference bq bs e represents set public keys pki xe2 x88 x88 p aggregator received qi corresponding si 14 x0c