b gr xc3 xb8stl implementation guide krystian matusiewicz1 martin schla xcc x88ffer2 s xc3 xb8ren s thomsen3 1 intel technology poland iaik graz university technology 3 dtu mathematics technical university denmark 2 march 9 2012 current version downloaded http www groestl info groestl implementation guide pdf abstract gr xc3 xb8stl hash function finalist sha 3 competition organized nist paper describe number implementation techniques tricks gr xc3 xb8stl allow develop range efficient implementations platforms 8 bit microcontrollers modern desktop processors 256 bit avx instructions results demonstrate implementation flexibility algorithm hope inspire optimizations ports platforms information paper useful developers planning implement gr xc3 xb8stl efficiently platform choice furthermore believe hardware implementations benefit optimization techniques presented paper 1 introduction hash function gr xc3 xb8stl designed 2008 candidate sha 3 competition 18 organized national institute standards technology nist 2010 gr xc3 xb8stl selected finalists competition gr xc3 xb8stl borrows components aes block cipher united states federal government standard 2001 17 aes known good performance wide variety platforms large flexibility choice implementation methods recently intel introduced instruction set extension computing aes rounds 9 makes encryption aes cpus implementing instruction set efficient underlying components gr xc3 xb8stl differ ones aes gr xc3 xb8stl enjoys implementation benefits aes aes instruction set extension significantly speed gr xc3 xb8stl paper describe software implementation techniques gr xc3 xb8stl suitable platforms ranging 8 bit microcontrollers processors simd aes instruction set extensions implementations downloaded http www groestl info 2 description gr xc3 xb8stl gr xc3 xb8stl hash function iterates underlying compression function variant merkle damga xcc x8ard construction 7 15 size state chaining value passed iteration twice large final hash value final hash value computed chaining value output transformation gr xc3 xb8stl known wide pipe design compression function output transformation based permutations round transformations similar aes 16 final round competition gr xc3 xb8stl tweaked 1 x0corder increase security margin initial submission called gr xc3 xb8stl 0 following describe components tweaked gr xc3 xb8stl hash function detail 2 1 hash function gr xc3 xb8stl comes variants different output sizes denote n number bits output variant returning n bits denoted gr xc3 xb8stl n focus gr xc3 xb8stl 256 gr xc3 xb8stl512 variants returning 256 bits differ gr xc3 xb8stl 256 initial value final truncation produce hash value similarly variants returning 256 bits differ gr xc3 xb8stl 512 respects input message m padded split blocks m1 m2 mt bits 512 gr xc3 xb8stl256 1024 gr xc3 xb8stl 512 initial value iv intermediate hash values hi permutations p q size bits exact definition iv found 8 message blocks processed compression function f hi xe2 x88 x921 mi accepts bit inputs outputs bit value t message blocks processed output transformation xe2 x84 xa6 ht applied outputs final n bit hash value h h0 iv hi f hi xe2 x88 x921 mi 1 xe2 x89 xa4 xe2 x89 xa4 t h xe2 x84 xa6 ht variants twice large n 2 2 compression function compression function f based bit permutations p q compression function defined follows f hi xe2 x88 x921 mi p hi xe2 x88 x921 xe2 x8a x95 mi xe2 x8a x95 q mi xe2 x8a x95 hi xe2 x88 x921 construction compression function gr xc3 xb8stl shown figure 1 f mi hi xe2 x88 x921 q p hi figure 1 compression function f gr xc3 xb8stl permutations p q size xe2 x89 xa5 2n bits 2 3 output transformation compression function output transformation xe2 x84 xa6 applied ht final hash value size n xe2 x84 xa6 ht truncn p ht xe2 x8a x95 ht truncn x discards significant n bits x output transformation shown figure 2 2 x0cht p n figure 2 output transformation xe2 x84 xa6 gr xc3 xb8stl permutation p size xe2 x89 xa5 2n bits n bits returned 2 4 permutations permutations p q defined gr xc3 xb8stl distinguish permutations gr xc3 xb8stl 256 gr xc3 xb8stl 512 write p q size permutations permutation aes like round transformations addroundconstant ac subbytes sb shiftbytes sh mixbytes mb applied state given order permutations differ constants addroundconstant shiftbytes number rounds gr xc3 xb8stl 256 10 rounds 512 bit state permutation p512 q512 viewed 8 xc3 x978 matrix bytes round permutation gr xc3 xb8stl 256 shown figure 3 gr xc3 xb8stl 512 14 rounds 1024 bit state permutations p1024 q1024 viewed 8 xc3 x97 16 matrix bytes ac sb sh mb ac sb sh mb gr xc3 xb8stl 256 b gr xc3 xb8stl 512 figure 3 round permutation gr xc3 xb8stl 256 gr xc3 xb8stl 512 hash function 2 4 1 addroundconstant addroundconstant ac transformation xors round dependent constant row state constant row different p q additionally round independent constant ff xored byte q denote hexadecimal byte values character values sans serif font xor constants round viewed hexadecimal digit xcc x84 denotes bit wise complement shown figure 4 2 4 2 subbytes subbytes sb transformation applies aes s box byte state definition s box found 8 2 4 3 shiftbytes shiftbytes sh cyclically rotates bytes row r left xcf x83 r positions different values p q gr xc3 xb8stl 256 gr xc3 xb8stl 512 following rotation values xcf x83 0 1 2 3 4 5 6 7 p gr xc3 xb8stl 256 xcf x83 1 3 5 7 0 2 4 6 q gr xc3 xb8stl 256 xcf x83 0 1 2 3 4 5 6 11 p gr xc3 xb8stl 512 xcf x83 1 3 5 11 0 2 4 6 q gr xc3 xb8stl 512 3 x0c0i 1i 2i 3i 4i 5i 6i 7i 0i 1i 2i 3i 4i 5i 6i 7i 8i 9i ai bi ci di ei fi p512 b p1024 ff ff ff ff ff ff ff fi ff ff ff ff ff ff ff ei ff ff ff ff ff ff ff di ff ff ff ff ff ff ff ci ff ff ff ff ff ff ff bi ff ff ff ff ff ff ff ai ff ff ff ff ff ff ff 9i ff ff ff ff ff ff ff 8i ff ff ff ff ff ff ff fi ff ff ff ff ff ff ff ei ff ff ff ff ff ff ff di ff ff ff ff ff ff ff ci c q512 ff ff ff ff ff ff ff bi ff ff ff ff ff ff ff ai ff ff ff ff ff ff ff 9i ff ff ff ff ff ff ff 8i ff ff ff ff ff ff ff 7i ff ff ff ff ff ff ff 6i ff ff ff ff ff ff ff 5i ff ff ff ff ff ff ff 4i ff ff ff ff ff ff ff 3i ff ff ff ff ff ff ff 2i ff ff ff ff ff ff ff 1i ff ff ff ff ff ff ff 0i d q1024 figure 4 xor constants added addroundconstant transformation s x figure 5 subbytes substitutes byte state aes s box 2 4 4 mixbytes mixbytes mb linear diffusion layer multiplies column state constant circulant 8 xc3 x97 8 matrix b xe2 x86 x90b xc2 xb7a xef xa3 xae xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf b xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xb0 02 07 05 03 05 04 03 02 02 02 07 05 03 05 04 03 03 02 02 07 05 03 05 04 04 03 02 02 07 05 03 05 05 04 03 02 02 07 05 03 03 05 04 03 02 02 07 05 05 03 05 04 03 02 02 07 07 05 03 05 04 03 02 02 xef xa3 xb9 xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xbb 1 matrix b constants elements finite field gf 28 defined polynomial xce xb88 xe2 x8a x95 xce xb84 xe2 x8a x95 xce xb8 xe2 x8a x95 xce xb8 xe2 x8a x95 1 8 bit value x binary representation 3 x x7 xc2 xb7 27 x6 xc2 xb7 26 x5 xc2 xb7 25 x4 xc2 xb7 24 x3 xc2 xb7 23 x2 xc2 xb7 22 x1 xc2 xb7 21 x0 xc2 xb7 20 represented following polynomial finite field gf 28 p x x7 xc2 xb7 xce xb87 x6 xc2 xb7 xce xb86 x5 xc2 xb7 xce xb85 x4 xc2 xb7 xce xb84 x3 xc2 xb7 xce xb83 x2 xc2 xb7 xce xb82 x1 xc2 xb7 xce xb81 x0 multiplication x xc2 xb7 y field gf 28 defined polynomial multiplication modulo polynomial defining field x xc2 xb7 y p x xc2 xb7 p y mod xce xb88 xe2 x8a x95 xce xb84 xe2 x8a x95 xce xb83 xe2 x8a x95 xce xb8 xe2 x8a x95 1 section 4 4 describes multiplications field carried efficiently practice 4 x0c p512 b p1024 c q512 d q1024 figure 6 shift values shiftbytes transformation b figure 7 mixbytes transformation multiplies column state constant matrix b 3 introduction efficient implementation techniques section high level overview common efficient implementation techniques gr xc3 xb8stl gr xc3 xb8stl aes based hash function implementation techniques developed aes applied gr xc3 xb8stl main implementation techniques gr xc3 xb8stl t table implementation bit slicing byte slicing parallel byte slice implementation intel aes ni instruction vperm technique compute aes s box table 1 list benchmark results gr xc3 xb8stl current desktop processors details processors refer ebash 3 additionally byte slice implementation technique efficient 8 bit implementations gr xc3 xb8stl table 2 shows time memory trade offs 8 bit avr implementations 3 1 t table implementation daemen rijmen presented table based approach aes 6 efficiently computes combined subbytes mixcolumns transformation approach applied gr xc3 xb8stl technique table lookup needed s box mixbytes transformation computed parallel rows state combined s box lookup approach efficient column size matches register size case 32 bit platforms aes 64 bits platforms gr xc3 xb8stl current future small scale 32 bit processors provide 64 bit instructions mmx neon gr xc3 xb8stl implemented efficiently platforms t table approach t table implementations state gr xc3 xb8stl stored 64 bit registers column ordering figure 8 addroundconstant transformation computed separately 64 bit xors computation subbytes shiftbytes mixbytes transformations combined efficiently compute 5 x0ctable 1 gr xc3 xb8stl software performance current desktop processors sorted speed cycles byte c b byte slice implementations aes ni vperm outperform table based implementations processors 128 bit registers hash function gr xc3 xb8stl 256 gr xc3 xb8stl 0 256 gr xc3 xb8stl 512 processor intel core i7 2600k amd phenom ii x6 intel core2 duo l9400 intel core i7 620lm intel pentium m intel core2 duo l9400 intel core i7 2600k intel core2 duo l9400 amd phenom ii x6 intel core i7 620lm intel pentium m speed c b 11 5 19 4 20 4 22 5 23 3 24 0 38 8 29 7 15 6 28 9 37 4 31 7 33 4 37 7 76 1 technique aes ni t tables vperm t tables vperm t tables t tables bit slicing aes ni vperm t tables t tables vperm t tables t tables table 2 speed different gr xc3 xb8stl 256 8 bit avr implementations cycles byte atmega163 gr xc3 xb8stl gr xc3 xb8stl 0 ram highspeed 469 456 994 balanced 530 517 226 lowmem 738 164 64 bit column e g column 0 gr xc3 xb8stl follows xef xa3 xae xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xb0 b00 b10 b20 b30 b40 b50 b60 b70 xef xa3 xb9 xef xa3 xae xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xbb xef xa3 xb0 02 07 05 03 05 04 03 02 02 02 07 05 03 05 04 03 03 02 02 07 05 03 05 04 04 03 02 02 07 05 03 05 05 04 03 02 02 07 05 03 03 05 04 03 02 02 07 05 05 03 05 04 03 02 02 07 07 05 03 05 04 03 02 02 xef xa3 xb9 xef xa3 xae xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xc2 xb7 xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xbb xef xa3 xb0 s a00 s a11 s a22 s a33 s a44 s a55 s a66 s a77 xef xa3 xb9 xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xbb b0 b00 b10 xc2 xb7 xc2 xb7 xc2 xb7 b70 t resulting 64 bit value column computation input bytes aij extracted state according shiftbytes transformation s box s x applied bytes prior matrix multiplication mixbytes expanding matrix multiplication gives xef xa3 xae xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xb0 b00 b10 b20 b30 b40 b50 b60 b70 xef xa3 xb9 xef xa3 xae xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xbb xef xa3 xb0 xef xa3 xae xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xaf xef xa3 xb0 02 xc2 xb7 s a00 07 xc2 xb7 s a00 05 xc2 xb7 s a00 03 xc2 xb7 s a00 05 xc2 xb7 s a00 04 xc2 xb7 s a00 03 xc2 xb7 s a00 02 xc2 xb7 s a00 xef xa3 xb9 05 xc2 xb7 s a44 04 xc2 xb7 s a44 03 xc2 xb7 s a44 02 xc2 xb7 s a44 02 xc2 xb7 s a44 07 xc2 xb7 s a44 05 xc2 xb7 s a44 03 xc2 xb7 s a44 xef xa3 xb9 xef xa3 xae xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xe2 x8a x95 xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xbb xef xa3 xb0 xef xa3 xae xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xe2 x8a x95 xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xbb xef xa3 xb0 02 xc2 xb7 s a11 02 xc2 xb7 s a11 07 xc2 xb7 s a11 05 xc2 xb7 s a11 03 xc2 xb7 s a11 05 xc2 xb7 s a11 04 xc2 xb7 s a11 03 xc2 xb7 s a11 xef xa3 xb9 03 xc2 xb7 s a55 05 xc2 xb7 s a55 04 xc2 xb7 s a55 03 xc2 xb7 s a55 02 xc2 xb7 s a55 02 xc2 xb7 s a55 07 xc2 xb7 s a55 05 xc2 xb7 s a55 xef xa3 xb9 6 xef xa3 xae xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xe2 x8a x95 xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xbb xef xa3 xb0 xef xa3 xae xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xe2 x8a x95 xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xbb xef xa3 xb0 03 xc2 xb7 s a22 02 xc2 xb7 s a22 02 xc2 xb7 s a22 07 xc2 xb7 s a22 05 xc2 xb7 s a22 03 xc2 xb7 s a22 05 xc2 xb7 s a22 04 xc2 xb7 s a22 xef xa3 xb9 05 xc2 xb7 s a66 03 xc2 xb7 s a66 05 xc2 xb7 s a66 04 xc2 xb7 s a66 03 xc2 xb7 s a66 02 xc2 xb7 s a66 02 xc2 xb7 s a66 07 xc2 xb7 s a66 xef xa3 xb9 xef xa3 xae xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xe2 x8a x95 xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xbb xef xa3 xb0 xef xa3 xae xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xe2 x8a x95 xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xba xef xa3 xaf xef xa3 xbb xef xa3 xb0 04 xc2 xb7 s a33 03 xc2 xb7 s a33 02 xc2 xb7 s a33 02 xc2 xb7 s a33 07 xc2 xb7 s a33 05 xc2 xb7 s a33 03 xc2 xb7 s a33 05 xc2 xb7 s a33 xef xa3 xb9 07 xc2 xb7 s a77 05 xc2 xb7 s a77 03 xc2 xb7 s a77 05 xc2 xb7 s a77 04 xc2 xb7 s a77 03 xc2 xb7 s a77 02 xc2 xb7 s a77 02 xc2 xb7 s a77 xef xa3 xb9 xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xe2 x8a x95 xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xbb xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xba xef xa3 xbb x0cwhich simplifies b0 t0 a00 xe2 x8a x95 t1 a11 xe2 x8a x95 t2 a22 xe2 x8a x95 t3 a33 xe2 x8a x95 t4 a44 xe2 x8a x95 t5 a55 xe2 x8a x95 t6 a66 xe2 x8a x95 t7 a77 tables y ti x contain 8 64 bit lookups s box 8 multipliers q mmx0 mmx1 mmx2 mmx3 mmx4 mmx5 mmx6 mmx7 mmx0 mmx1 mmx2 mmx3 mmx4 mmx5 mmx6 mmx7 p figure 8 t table approach gr xc3 xb8stl 256 state stored column wise 64 bit registers mixbytes example table t0 t0 x 02 xc2 xb7 s x k 07 xc2 xb7 s x k 05 xc2 xb7 s x k 03 xc2 xb7 s x k 05 xc2 xb7 s x k 04 xc2 xb7 s x k 03 xc2 xb7 s x k 02 xc2 xb7 s x extracting single byte word implemented bit shift masking logical instruction computation column consists 8 table lookups 8 xor 7 xor mb 1 xor ac 8 shift 8 instructions platforms single bytes aij extracted 64 bit column words aj a00 a10 a70 t cost case save shift instructions t table approach efficient implementations 32 bit processors case split computation upper lower need split tables ti table ti0 storing upper 32 bits table ti00 storing lower 32 bits cyclic structure mixbytes transformation matrix tables ti0 reused lookup lower 32 bits 0 ti00 t 4 mod 8 b00 t00 a00 xe2 x8a x95 t10 a11 xe2 x8a x95 t20 a22 xe2 x8a x95 t30 a33 xe2 x8a x95 t40 a44 xe2 x8a x95 t50 a55 xe2 x8a x95 t60 a66 xe2 x8a x95 t70 a77 b000 t40 a00 xe2 x8a x95 t50 a11 xe2 x8a x95 t60 a22 xe2 x8a x95 t70 a33 xe2 x8a x95 t00 a44 xe2 x8a x95 t10 a55 xe2 x8a x95 t20 a66 xe2 x8a x95 t30 a77 b0 b00 kb000 3 2 byte slice implementation option implement gr xc3 xb8stl byte wise parallel computation columns round transformations shiftbytes addroundconstant apply exactly computation column gr xc3 xb8stl state independently use single instruction multiple data simd approach compute identical operations column time byte slice implementation 1 gr xc3 xb8stl state cut column slices bytes state stored row ordering w bit registers w 8 columns computed parallel figure 9 approach efficient small 8 bit large register sizes 128 bit requirement approach efficient round transformations gr xc3 xb8stl parallelised w bit simd instructions addroundconstant mixbytes computed parallel simply basic alu instructions shiftbytes need byte shuffling instruction mask rotate instructions difficult round transformation parallelise 8 bit table lookup subbytes intel aes new instructions extension aes ni 12 vector permute 7 x0cq p xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7 figure 9 simd implementation gr xc3 xb8stl 256 state stored row wise xmm registers compute column 16 times parallel vperm approach hamburg 10 parallel aes s box table lookups performed efficiently fastest gr xc3 xb8stl implementation 3 byte slice implementation aes ni details round transformations implemented refer section 4 byte slice implementation need use row ordering gr xc3 xb8stl state input bytes message mapped gr xc3 xb8stl state column ordering column ordering benefit t table based implementations drawback byte slice implementations reduce state transformation costs internal state kept row ordering computation need transform input message block hash function output end iv stored row ordering transforming input message column ordering row ordering corresponds transposing state matrix input message block algorithms transposing matrix known square matrix transposed instructions 3 3 bit slice implementation fastest aes software implementations bit slice implementations running 7 6 cycles byte intel core2 multiple blocks encrypted parallel counter mode 14 hash function whirlpool shares similarities gr xc3 xb8stl implemented efficiently bit slicing techniques 20 preliminary assembly implementations gr xc3 xb8stl 0 speed 29 7 cycles byte intel core2 duo processor computation hash single message 21 additionally bit slice implementations gr xc3 xb8stl 0 efficient messages hashed parallel 4 4 implementing gr xc3 xb8stl round transformations section list common techniques efficiently implement individual gr xc3 xb8stl round transformations listed techniques platforms different word sizes hardware software cases special optimization techniques combine round transformations lead better results platforms sections 5 3 2 3 3 4 1 addroundconstant addroundconstant transformation consists xors bytes state constants cases constants stored data structures ordering conventions state case xors simply carried word word exploit fact constants q correspond complementation byte followed xor constants p note q constants xored row instead row p 4 2 subbytes subbytes transformation simply implemented 8 bit table lookup 8 x0chowever transformation corresponds inversion finite field gf 28 followed affine transformation scenarios efficient implement computation efficient known way compute aes s box formulas canright 5 originally developed compact hardware implementations canright xe2 x80 x99s formulas efficient computation aes s box software fastest known aes implementation uses formulas compute s box bit slice mode 14 second efficient method compute aes s box proposed hamburg 10 approach inverse gf 28 aes s box computed small log tables finite field gf 24 small log tables efficiently implemented byte shuffling instructions registers containing 16 bytes 4 8 bit table lookup performed details implementation refer original publication 10 possibility compute subbytes intel aes new instructions extension aes ni x86 instruction set 9 extension includes number instructions computing aes rounds instruction aesenclast example computes round aes key additions means computes transformations subbytes shiftrows instruction available compute parallel aes s box lookups reduce number byte shuffling instructions computation shiftrows aesenclast combined computation shiftbytes 4 3 shiftbytes shiftbytes transformation simply moves bytes row transformation computed implicitly simply changing addressing bytes implementation modern desktop processor store rows state 64 bit 128 bit word case shiftbytes transformation implemented simple byte shuffling instruction 4 4 mixbytes mixbytes consists multiplication column state constant 8 xc3 x97 8 matrix b multiplications additions needed compute transformation finite field gf 28 defined polynomial xce xb88 xe2 x8a x95 xce xb84 xe2 x8a x95 xce xb83 xe2 x8a x95 xce xb8 xe2 x8a x95 1 11b hexadecimal notation ways compute mixbytes depends hardware cpu features variant efficient following explain important techniques 4 4 1 table based implementation efficient way implement mixbytes precomputed t tables section 5 especially case table lookups mixbytes combined s box t table approach effect state byte column 8 bytes precomputed stored table 256 64 bit entries input byte column need separate table e g column computed follows b0 t0 a00 xe2 x8a x95 t1 a11 xe2 x8a x95 t2 a22 xe2 x8a x95 t3 a33 xe2 x8a x95 t4 a44 xe2 x8a x95 t5 a55 xe2 x8a x95 t6 a66 xe2 x8a x95 t7 a77 tables y ti x contain 8 64 bit lookups s box 8 multipliers mixbytes table t0 precomputed follows t0 x 02 xc2 xb7 s x k 07 xc2 xb7 s x k 05 xc2 xb7 s x k 03 xc2 xb7 s x k 05 xc2 xb7 s x k 04 xc2 xb7 s x k 03 xc2 xb7 s x k 02 xc2 xb7 s x method column mixbytes including column subbytes computed 8 table lookups 7 64 bit xor operations need instructions shiftbytes byte values extracted 64 bit words furthermore t table approach resistant cache timing table lookups bottleneck current processors 9 x0c4 4 2 double add mixbytes computed repeated double add operations need xor efficiently multiply 02 section 4 4 3 example multiplication 05 carried performing 02 xc2 xb7 02 xc2 xb7 x x double add operations following formulas compute output byte bi given input bytes ai single column bi 02 xc2 xb7 02 xc2 xb7 ai 3 xe2 x8a x95 ai 4 xe2 x8a x95 ai 6 xe2 x8a x95 ai 7 xe2 x8a x95 ai xe2 x8a x95 ai 1 xe2 x8a x95 ai 2 xe2 x8a x95 ai 5 xe2 x8a x95 ai 7 xe2 x8a x95 2 ai 2 xe2 x8a x95 ai 4 xe2 x8a x95 ai 5 xe2 x8a x95 ai 6 xe2 x8a x95 ai 7 0 7 indices taken modulo 8 simply implementing formula require 8 xc2 xb7 2 16 multiplications 02 8 xc2 xb7 13 104 xors number xors significantly reduced 48 section 4 4 4 section 4 4 5 4 4 3 multiplication 02 finite field gf 28 doubling operation 02 xc2 xb7 x x 8 bit value implemented left shift x followed conditional xor irreducible polynomial 11b overflow occurs operating bytes msb usually discarded shift check msb set conditionally xor constant 1b shift worth note cases condition checked efficiently treating byte signed value comparing zero xe2 x80 x99s complement representation significant bit set value x negative 4 4 4 minimising number xors taking look equation 2 observe terms form ai xe2 x8a x95ai 1 repeatedly computing temporary results tree based form optimised way computing mixbytes following set formulas xi ai xe2 x8a x95 ai 1 yi xi xe2 x8a x95 xi 3 zi xi xe2 x8a x95 xi 2 xe2 x8a x95 ai 6 3 bi 02 xc2 xb7 02 xc2 xb7 yi 3 xe2 x8a x95 zi 7 xe2 x8a x95 zi 4 formulas contain minimum number 16 multiplications 02 8 xc2 xb7 6 48 xor operations furthermore computations independent allows better parallelism superscalar cpus example computing xi independent xj 6 j true remaining temporary final values 4 4 5 computing multiplication 02 section 6 3 efficient compute multiplication 02 04 input values ai bi ai 2 xe2 x8a x95 ai 4 xe2 x8a x95 ai 5 xe2 x8a x95 ai 6 xe2 x8a x95 ai 7 xe2 x8a x95 02 xc2 xb7 ai xe2 x8a x95 02 xc2 xb7 ai 1 xe2 x8a x95 02 xc2 xb7 ai 2 xe2 x8a x95 02 xc2 xb7 ai 5 xe2 x8a x95 02 xc2 xb7 ai 7 xe2 x8a x95 4 04 xc2 xb7 ai 3 xe2 x8a x95 04 xc2 xb7 ai 4 xe2 x8a x95 04 xc2 xb7 ai 6 xe2 x8a x95 04 xc2 xb7 ai 7 case previous optimization applied possible minimize number xor operations case terms ai 02 xc2 xb7 ai 04 xc2 xb7 ai computation added result save xors computing temporary results example term t 02 xc2 xb7 a0 xe2 x8a x95 02 xc2 xb7 a2 xe2 x8a x95 a5 xe2 x8a x95 04 xc2 xb7 a7 xe2 x8a x95 a7 5 added b0 b1 b3 save xor operations computing temporary results 1 reuse temporary results optimized table 3 equations result 16 multiplications 02 58 xor operations 10 x0ctable 3 mixbytes computation 58 xors xe2 x80 x9c xe2 x80 xa2 xe2 x80 x9d denotes inputs ai 02 xc2 xb7 ai 04 xc2 xb7 ai added results bi superscripts denote order temporary results computed 1 corresponds temporary results equation 5 b0 b1 b2 b3 b4 b5 b6 b7 4 4 6 04 xe2 x88 x92 xe2 x80 xa25 xe2 x80 xa25 xe2 x88 x92 xe2 x80 xa2d xe2 x80 xa2d xe2 x88 x92 xe2 x88 x92 a0 02 xe2 x80 xa21 xe2 x80 xa21 xe2 x88 x92 xe2 x80 xa21 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa28 xe2 x80 xa28 01 xe2 x88 x92 xe2 x80 xa25 xe2 x80 xa25 xe2 x80 xa23 xe2 x80 xa23 xe2 x88 x92 xe2 x80 xa23 xe2 x88 x92 04 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa27 xe2 x80 xa27 xe2 x88 x92 xe2 x80 xa26 xe2 x80 xa26 xe2 x88 x92 a1 02 xe2 x80 xa22 xe2 x80 xa2a xe2 x80 xa22 xe2 x88 x92 xe2 x80 xa2a xe2 x88 x92 xe2 x88 x92 xe2 x80 xa22 01 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa27 xe2 x80 xa27 xe2 x80 xa24 xe2 x80 xa24 xe2 x88 x92 xe2 x80 xa24 04 xe2 x88 x92 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa23 xe2 x80 xa23 xe2 x80 xa2d xe2 x80 xa23 xe2 x88 x92 a2 02 xe2 x80 xa21 xe2 x80 xa21 xe2 x80 xa2c xe2 x80 xa21 xe2 x88 x92 xe2 x80 xa2c xe2 x88 x92 xe2 x88 x92 01 xe2 x80 xa29 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa23 xe2 x80 xa23 xe2 x80 xa29 xe2 x80 xa23 xe2 x88 x92 04 xe2 x80 xa2d xe2 x88 x92 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa24 xe2 x80 xa24 xe2 x88 x92 xe2 x80 xa24 a3 02 xe2 x88 x92 xe2 x80 xa25 xe2 x80 xa25 xe2 x80 xa23 xe2 x80 xa23 xe2 x88 x92 xe2 x80 xa23 xe2 x88 x92 01 xe2 x88 x92 xe2 x80 xa2b xe2 x88 x92 xe2 x88 x92 xe2 x80 xa24 xe2 x80 xa24 xe2 x80 xa2b xe2 x80 xa24 04 xe2 x80 xa2d xe2 x80 xa2d xe2 x88 x92 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa26 xe2 x80 xa26 xe2 x88 x92 a4 02 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa27 xe2 x80 xa27 xe2 x80 xa24 xe2 x80 xa24 xe2 x88 x92 xe2 x80 xa24 01 xe2 x80 xa22 xe2 x88 x92 xe2 x80 xa22 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa26 xe2 x80 xa26 xe2 x80 xa22 04 xe2 x88 x92 xe2 x80 xa25 xe2 x80 xa25 xe2 x88 x92 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa28 xe2 x80 xa28 a5 02 xe2 x80 xa29 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa23 xe2 x80 xa23 xe2 x80 xa29 xe2 x80 xa23 xe2 x88 x92 01 xe2 x80 xa21 xe2 x80 xa21 xe2 x88 x92 xe2 x80 xa21 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa28 xe2 x80 xa28 04 xe2 x80 xa22 xe2 x88 x92 xe2 x80 xa22 xe2 x80 xa2d xe2 x88 x92 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa22 a6 02 xe2 x88 x92 xe2 x80 xa2b xe2 x88 x92 xe2 x88 x92 xe2 x80 xa24 xe2 x80 xa24 xe2 x80 xa2b xe2 x80 xa24 01 xe2 x80 xa22 xe2 x80 xa2a xe2 x80 xa22 xe2 x88 x92 xe2 x80 xa2a xe2 x88 x92 xe2 x88 x92 xe2 x80 xa22 04 xe2 x80 xa21 xe2 x80 xa21 xe2 x88 x92 xe2 x80 xa21 xe2 x80 xa2d xe2 x88 x92 xe2 x88 x92 xe2 x88 x92 a7 02 xe2 x80 xa22 xe2 x88 x92 xe2 x80 xa22 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa26 xe2 x80 xa26 xe2 x80 xa22 01 xe2 x80 xa21 xe2 x80 xa21 xe2 x80 xa2c xe2 x80 xa21 xe2 x88 x92 xe2 x80 xa2c xe2 x88 x92 xe2 x88 x92 possible optimisations possibility reduce computation costs mixbytes use different basis multipliers instead 01 02 04 c xcc xa7alik implementation basis 03 05 07 4 case hamming weight multiplication constants reduces significantly unfortunately basis result 58 xors needs 16 multiplications 02 platforms registers available multiplications 02 cheap advantage compute results multiplier separately 1 case results bi 1 multiplier 01 reused compute multiplier 02 bi 2 02 xc2 xb7 bi 3 mod 8 1 table 5 multipliers 01 04 bi 4 temporary results minimize number xors approach results 24 multiplications 2 48 xors 5 t table implementations section present example implementations use t table approach gr xc3 xb8stl implementation technique efficient 64 bit platforms 32 bit platforms number necessary instructions double following listing provide unoptimized c code segment computation round permutation p gr xc3 xb8stl 256 a0 a1 a2 a3 a4 a5 a6 a7 b0 b0 b0 b0 b0 b0 b0 b0 b1 ac b0 c0 b1 c1 b2 c2 b3 c3 b4 c4 b5 c5 b6 c6 b7 c7 sb sh mb column t0 a0 0 t1 a1 8 t2 a2 16 t3 a3 24 t4 a4 32 t5 a5 40 t6 a6 48 t7 a7 56 sb sh mb column t0 a0 8 0 p 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 1 p 0xff b1 b1 b1 b1 b1 b1 b1 b2 b2 b2 b2 b2 b2 b2 b2 b3 b3 b3 t1 a1 16 t2 a2 24 t3 a3 32 t4 a4 40 t5 a5 48 t6 a6 56 t7 a7 0 sb sh mb column t0 a0 16 t1 a1 24 t2 a2 32 t3 a3 40 t4 a4 48 t5 a5 56 t6 a6 0 t7 a7 8 sb sh mb column t0 a0 24 t1 a1 32 t2 a2 40 11 0xff 0xff 0xff 0xff 0xff 0xff 0xff 2 p 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 3 p 0xff 0xff 0xff b3 b3 b3 b3 b3 b4 b4 b4 b4 b4 b4 b4 b4 b5 b5 b5 b5 b5 t3 a3 48 t4 a4 56 t5 a5 0 t6 a6 8 t7 a7 16 sb sh mb column t0 a0 32 t1 a1 40 t2 a2 48 t3 a3 56 t4 a4 0 t5 a5 8 t6 a6 16 t7 a7 24 sb sh mb column t0 a0 40 t1 a1 48 t2 a2 56 t3 a3 0 t4 a4 8 0xff 0xff 0xff 0xff 0xff 4 p 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 5 p 0xff 0xff 0xff 0xff 0xff x0cb5 b5 b5 b6 b6 b6 t5 a5 16 t6 a6 24 t7 a7 32 sb sh mb column t0 a0 48 t1 a1 56 t2 a2 0 0xff 0xff 0xff 6 p 0xff 0xff 0xff b6 b6 b6 b6 b6 b7 t3 a3 8 t4 a4 16 t5 a5 24 t6 a6 32 t7 a7 40 sb sh mb column t0 a0 56 0xff 0xff 0xff 0xff 0xff 7 p 0xff b7 b7 b7 b7 b7 b7 b7 t1 a1 0 t2 a2 8 t3 a3 16 t4 a4 24 t5 a5 32 t6 a6 40 t7 a7 48 0xff 0xff 0xff 0xff 0xff 0xff 0xff number optimized c implementations published gr xc3 xb8stl important ones implementations submitted nist designers 8 crypto library sphlib3 0 19 sphlib fully optimized e g round constants added byte byte good performance constrained 32 bit devices following present optimized assembly implementations example platforms serve reference t table optimizations 5 1 64 bit processors t table implementation gr xc3 xb8stl 64 bit processors needs 8 table lookups 8 xor 8 shift 8 instructions column computation section 5 x86 cpus reduce alu instructions 8 xor 8 mov 3 shift instructions column follows let rax contain column 0 significant 8 bits correspond byte following instructions extract byte rax movzbl edi al movzbl esi ah sig byte row 0 edi second sig byte row 1 esi edi index lookup table t0 esi index lookup table t7 shiftbytes column 7 results stored xored subsequent bytes new columns 0 7 register rax shifted 16 bits right time carry instructions edi contain byte row 2 esi contain byte row 3 note work columns time order maximize instruction level parallelism intel desktop processors prior sandy bridge architecture memory load store units arithmetic logic units alus implies load instructions dominant maximal throughput 1 cycle byte round gr xc3 xb8stl results 20 cycles byte gr xc3 xb8stl 256 28 cycles byte gr xc3 xb8stl 512 results given table 1 speed gr xc3 xb8stl close bound intel core2 duo processor amd opteron intel sandy bridge processors memory load units parallel table lookups possible cpu cycle assuming single bytes extracted efficiently instruction 0 5 cycles byte loads 8 8 3 8 3 0 79 cycles byte alu instructions alu instructions dominant lower bound 15 8 cycles byte gr xc3 xb8stl 256 22 1 cycles byte gr xc3 xb8stl 512 ideal results difficult achieve practice implementations approaching theoretical lower bounds table 1 5 2 32 bit processors number table lookups xors double 32 bit t table implementation lower bound 40 cycles byte gr xc3 xb8stl 256 56 cycles byte gr xc3 xb8stl 512 parallel table lookups possible current future 32 bit processors 64 bit instruction set extensions mmx intel amd processors 13 neon arm processors 2 extended instructions speed close 20 cycles byte 32 bit x86 cpus similar improvement expected new neon implementations 6 simd based byte slicing implementations section describe concrete examples byte slicing implementation gr xc3 xb8stl chose present implementation intel 64 platform ssse3 instruction set example popular 12 x0cmodern desktop class cpu implementation taking advantage aes ni instruction set present intel core ix sandy bridge processors byte sliced implementation aes ni instructions currently fastest gr xc3 xb8stl implementation 3 intel platforms discuss vperm implementation alternative processors equipped aes ni instructions case subbytes transformation implemented efficiently generic ssse3 instructions 6 1 transposing input message transforming input message column ordering row ordering corresponds transposing input message block algorithms transposing matrix known square matrix transposed punpck instructions 11 store gr xc3 xb8stl 256 state p q 128 bit registers 8x16 rectangular matrix additional byte shuffling pshufb mov instructions needed transpose input message 1 6 2 aes ni section describe details fastest known gr xc3 xb8stl implementation intel aes ni extension intel avx instructions speed 10 cycles byte reached ac pxor xmm0 const0 pxor xmm1 const1 pxor xmm2 const2 pxor xmm3 const3 pxor xmm4 const4 pxor xmm5 const5 pxor xmm6 const6 pxor xmm7 const7 sh aes shiftrowsinv pshufb xmm0 sigma0 pshufb xmm1 sigma1 pshufb xmm2 sigma2 pshufb xmm3 sigma3 pshufb xmm4 sigma4 pshufb xmm5 sigma5 pshufb xmm6 sigma6 pshufb xmm7 sigma7 sb aes shiftrows pxor xmm8 xmm8 aesenclast xmm0 xmm8 aesenclast xmm1 xmm8 aesenclast xmm2 xmm8 aesenclast xmm3 xmm8 aesenclast xmm4 xmm8 aesenclast xmm5 xmm8 aesenclast xmm6 xmm8 aesenclast xmm7 xmm8 mb y 6 movdqa xmm14 xmm0 movdqa xmm15 xmm1 movdqa xmm8 xmm2 movdqa xmm9 xmm3 movdqa xmm10 xmm4 movdqa xmm11 xmm5 movdqa xmm12 xmm6 movdqa xmm13 xmm7 mb t 1 pxor xmm0 xmm1 pxor xmm1 xmm2 pxor xmm2 xmm3 pxor xmm3 xmm4 pxor xmm4 xmm5 pxor xmm5 xmm6 pxor xmm6 xmm7 pxor xmm7 xmm14 mb y 6 t pxor xmm8 xmm4 pxor xmm9 xmm5 pxor xmm10 xmm6 pxor xmm11 xmm7 pxor xmm12 xmm0 pxor xmm13 xmm1 pxor xmm14 xmm2 pxor xmm15 xmm3 mb y y t 2 pxor xmm14 xmm4 pxor xmm15 xmm5 pxor xmm8 xmm6 pxor xmm9 xmm7 pxor xmm10 xmm0 pxor xmm11 xmm1 pxor xmm12 xmm2 pxor xmm13 xmm3 movaps tmp y4 xmm8 movaps tmp y5 xmm9 mb x t t 3 movdqa xmm8 xmm0 movdqa xmm9 xmm1 movaps tmp t2 xmm2 pxor xmm0 xmm3 pxor xmm1 xmm4 pxor xmm2 xmm5 pxor xmm3 xmm6 13 pxor xmm4 xmm7 pxor xmm5 xmm8 pxor xmm6 xmm9 pxor xmm7 tmp t2 mb z 02 x movaps xmm9 1b mul2 a0 b0 b1 mul2 a1 b0 b1 mul2 a2 b0 b1 mul2 a3 b0 b1 mul2 a4 b0 b1 mul2 a5 b0 b1 mul2 a6 b0 b1 mul2 a7 b0 b1 mb w z y 4 pxor xmm0 tmp y4 pxor xmm1 tmp y5 pxor xmm2 xmm10 pxor xmm3 xmm11 pxor xmm4 xmm12 pxor xmm5 xmm13 pxor xmm6 xmm14 pxor xmm7 xmm15 mb v 02 w mul2 a0 b0 b1 mul2 a1 b0 b1 mul2 a2 b0 b1 mul2 a5 b0 b1 mul2 a6 b0 b1 mul2 a7 b0 b1 mul2 a3 b0 b1 mul2 a4 b0 b1 mb b v 3 y 4 pxor xmm13 xmm0 pxor xmm14 xmm1 pxor xmm15 xmm2 pxor xmm10 xmm5 x0cpxor xmm11 xmm6 pxor xmm12 xmm7 6 2 1 movaps xmm8 tmp y4 movaps xmm9 tmp y5 pxor xmm8 xmm3 pxor xmm9 xmm4 addroundconstant addroundconstant transformation xors round dependent row wise constant row p row q round independent constant row q gr xc3 xb8stl state stored row ordering constants added efficiently parallel column state example constants gr xc3 xb8stl 256 added follows movaps pxor pxor pxor pxor pxor pxor pxor pxor 6 2 2 xmm8 xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7 0xffffffffffffffff0000000000000000 round const p0 xmm8 xmm8 xmm8 xmm8 xmm8 xmm8 round const q7 subbytes subbytes usually difficult transformation implement efficiently byte slice implementation mentioned w bit registers need efficient method compute w 8 parallel aes s box lookups results parallel table lookup case 8 bit implementations w 8 unfortunately larger register sizes parallel table lookups usually non trivial gr xc3 xb8stl use mds matrix aes gr xc3 xb8stl advantage intel aes new instructions extension aes ni mixcolumns transformation applied round aes intel provides aesenclast instruction instruction able compute 16 aes s boxes parallel throughput cycle latency 4 cycles byte shuffling aesenclast instruction combined extra byte shuffling perform shiftbytes transformation gr xc3 xb8stl section 6 2 3 6 2 3 shiftbytes shiftbytes moves bytes row gr xc3 xb8stl transformation implemented byte shuffling instructions aesenclast compute s box lookups need shiftrows transformation round aes account note shiftbytes rotation constants p q additional cost resulting instructions combined subbytes shiftbytes transformation gr xc3 xb8stl 256 given pxor pshufb aesenclast pshufb aesenclast pshufb aesenclast pshufb aesenclast pshufb aesenclast pshufb aesenclast pshufb aesenclast pshufb aesenclast xmm8 xmm0 xmm0 xmm1 xmm1 xmm2 xmm2 xmm3 xmm3 xmm4 xmm4 xmm5 xmm5 xmm6 xmm6 xmm7 xmm7 xmm8 03060a0d080205090c0f0104070b0e00 xmm8 04070c0f0a03060b0e090205000d0801 xmm8 05000e090c04070d080b0306010f0a02 xmm8 0601080b0e05000f0a0d040702090c03 xmm8 0702090c0f0601080b0e0500030a0d04 xmm8 00030b0e0907020a0d080601040c0f05 xmm8 01040d080b00030c0f0a0702050e0906 xmm8 02050f0a0d01040e090c000306080b07 xmm8 14 x0c6 2 4 mixbytes mixbytes transformation costly transformation byte sliced implementation gr xc3 xb8stl need combine 8 rows gr xc3 xb8stl state according mixbytes matrix multiplication processors execute simd instruction parallel mixbytes computation minimum number instructions necessarily result fastest implementation example modern desktop cpus compute independent simd xors parallel mixbytes computation contains long chains dependencies alu parallelism fully utilised compute mixbytes simd instructions use formulas section 4 4 4 variant contains minimal possible number 16 multiplications 48 xors computations independent illustrate approach details consider implementation mixbytes equations 6 intel 64 architecture sse2 instructions order closer reflect constraints assembler code rewrite equation contain type operation pass yields following sequential formulas ti ai xe2 x8a x95 ai 1 yi ai 6 xe2 x8a x95 ti yi yi xe2 x8a x95 ti 2 xi ti xe2 x8a x95 ti 3 zi 02 xc2 xb7 xi 6 wi zi xe2 x8a x95 yi 4 vi 02 xc2 xb7 wi bi vi 3 xe2 x8a x95 yi 4 main challenge minimise number register spills performing computation 16 xmm registers reorder instructions way ensuring maximal instruction throughput algorithm shown table 4 achieves spills critical path masked operations start a0 a7 registers xmm0 xmm7 building b0 b7 xmm8 xmm15 byte wise multiplication 02 content xmm sequence instructions pxor pcmpgtb paddb pand pxor xmm j xmm j xmm xmm j xmm xmm j xmm xmm xmm k xmm j clear register comparing 0 sets 0xff bytes correspond msb bits set byte wise shift left position pick 0x1b correspond msb bit set xmm xor reduction polynomial result necessary requires extra register xmm j scratch space xmm k containing constant reduction value 1b1b 1b extra registers temporarily spill xmm8 xmm9 hold values y4 y5 critical path computation avx instructions available starting intel sandy bridge use operand instructions reduce number instructions required multiplication advantage smaller instruction sandy bridge cores recognize xoring clear register issue xc2 xb5ops case 6 3 vperm aes ni available implement gr xc3 xb8stl efficiently simd instructions need different method parallelize s box lookups subbytes method proposed hamburg 10 uses vector permute vperm instructions compute inversion affine transformation aes s box following describe gr xc3 xb8stl implementation vperm idea resulting implementation needs ssse3 instructions runs nist reference platform resulting speed comparable t table implementation 15 x0ctable 4 optimised computation mixbytes intel 64 machine sse2 instructions row describes operations 0 7 left columns content banks registers updated values shown bold rightmost column describes performed operation mul2 xmma xmmb xmmc doubles content xmma xmmb scratch assuming xmmc contains 1b 1b xmm0 xmm7 a0 a1 a7 a0 a1 a7 t0 t1 t7 xmm8 xmm15 xe2 x80 x94 a2 a3 a1 a2 a3 a1 t0 t1 t7 y4 y5 y3 x0 x1 x7 y4 y5 y3 y4 1b 1b y6 y3 xe2 x80 x94 1b 1b y6 y3 xe2 x80 x94 1b 1b y6 y3 xe2 x80 x94 1b 1b y6 y3 y4 y5 y6 y3 b0 b1 b7 z0 z1 z7 w0 w1 w7 v0 v1 v7 v0 v1 v7 v0 v1 v7 operation equation movdqa xmm 8 xmm 2 mod 8 pxor xmm xmm 1 mod 8 pxor xmm 8 xmm 4 mod 8 pxor xmm 8 xmm 6 mod 8 spill t0 t1 t2 memory computation pxor xmm xmm 3 mod 8 spill xmm8 xmm9 memory xmm9 xe2 x86 x90 0x1b 1b mul2 xmm xmm8 xmm9 pxor xmm xmm 8 y4 y5 memory mul2 xmm xmm8 xmm9 reload y4 y5 xmm8 xmm9 pxor xmm 8 xmm 3 mod 8 ti ai xe2 x8a x95 ai 1 yi ai 6 xe2 x8a x95 ti yi yi xe2 x8a x95 ti 2 xi ti xe2 x8a x95 ti 3 zi 02 xc2 xb7 xi wi zi xe2 x8a x95 yi 4 vi 02 xc2 xb7 wi bi vi 3 xe2 x8a x95 yi 4 state stored row ordering input transformation message block performed described section 6 1 following computation subbytes mixbytes somewhat merged swap order addroundconstant shiftbytes easier description 6 3 1 addroundconstant addroundconstant implementation implemented exactly instructions aes ni implementation vperm implementation uses different basis constants need transformed basis resulting constants precomputed stored memory specific constants refer actual vperm implementation gr xc3 xb8stl 6 3 2 shiftbytes shiftbytes computed single byte shuffle instructions row p q example rotation constants pshufb instruction gr xc3 xb8stl 256 given following assembly code listing pshufb pshufb pshufb pshufb pshufb pshufb pshufb pshufb 6 3 3 xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7 0x080f0e0d0c0b0a090706050403020100 0x0a09080f0e0d0c0b0007060504030201 0x0c0b0a09080f0e0d0100070605040302 0x0e0d0c0b0a09080f0201000706050403 0x0f0e0d0c0b0a09080302010007060504 0x09080f0e0d0c0b0a0403020100070605 0x0b0a09080f0e0d0c0504030201000706 0x0d0c0b0a09080f0e0605040302010007 subbytes vperm implementation inverse gf 28 aes s box computed small log tables finite field gf 24 efficiently compute log tables 128 bit pshufb instruction ssse3 4 8 bit lookup table details refer original paper 10 vperm implementation published c xcc xa7alik 4 served reference optimized implementation vperm implementation 16 aes s boxes computed parallel 10 cycles additional advantage implementation multiply resulting outputs constants 16 x0cgf 28 additional cost vperm implementation subbytes actually returns values s xi 02 xc2 xb7 s xi 04 xc2 xb7 s xi 16 input bytes xi 6 3 4 mixbytes multiplication 02 04 input bytes mixbytes computed subbytes formulas resulting 48 xors section 4 4 4 use method section 4 4 5 minimizes number xors multiplications performed note approach efficient 16 multiplications 02 expensive computed 5 instructions section 6 2 4 additional 18 xors 7 conclusions paper shown details currently best known gr xc3 xb8stl implementations aesni extensions avx instructions able implement gr xc3 xb8stl 256 close 10 cycles byte furthermore design gr xc3 xb8stl provides possibilities efficient implementation techniques presented important methods hope serve inspiration optimizations especially vperm implementation room improvements x86 cpus new platforms example neon byte permute instructions speed gr xc3 xb8stl new arm platforms references 1 k aoki g roland y sasaki m schla xcc x88ffer byte slicing gr xc3 xb8stl xe2 x80 x93 optimized intel aes ni 8 bit implementations sha 3 finalist gr xc3 xb8stl j lopez p samarati editors secrypt 2011 proceedings pages 124 xe2 x80 x93133 scitepress 2011 2 arm limited neon march 2011 available online http www arm com products processors technologies neon php 3 d j bernstein t lange ebash ecrypt benchmarking submitted hashes january 2011 available online http bench cr yp ebash html 4 c xcc xa7 c xcc xa7alik multi stream constant time sha 3 implementations nist hash function mailing list december 2010 retrieved 03 2010 http www metu edu tr ccalik software html sha3 5 d canright compact s box aes j r rao b sunar editors ches volume 3659 lncs pages 441 xe2 x80 x93455 springer 2005 6 j daemen v rijmen aes proposal rijndael nist aes algorithm submission september 1999 available online http csrc nist gov archive aes rijndael rijndael ammended pdf 7 damga xcc x8ard design principle hash functions g brassard editor advances cryptology xe2 x80 x93 crypto xe2 x80 x9989 proceedings volume 435 lecture notes computer science pages 416 xe2 x80 x93427 springer 1990 8 p gauravaram l r knudsen k matusiewicz f mendel c rechberger m schla xcc x88ffer s s thomsen gr xc3 xb8stl xe2 x80 x93 sha 3 candidate submission nist round 3 2011 available http www groestl info 2011 11 25 9 s gueron intel corp intel r advanced encryption standard aes instructions set 2010 retrieved december 21 2010 http software intel com en articles intel advanced encryption standard aes instructions set 10 m hamburg accelerating aes vector permute instructions c clavier k gaj editors ches volume 5747 lncs pages 18 xe2 x80 x9332 springer 2009 17 x0c 11 intel corporation mmx instructions transpose matrix 1996 available online ftp download intel com ids mmx mmx app transpose matrix pdf 12 intel corporation intel advanced encryption standard instructions aes ni march 2011 available online http software intel com en articles intel advanced encryption standard instructions aes ni 13 intel corporation pentium processors mmx technology march 2011 available online http edc intel com platforms previous processors pentium mmx 14 e ka xcc x88sper p schwabe faster timing attack resistant aes gcm c clavier k gaj editors ches volume 5747 lncs pages 1 xe2 x80 x9317 springer 2009 15 r c merkle way hash functions des g brassard editor advances cryptology xe2 x80 x93 crypto xe2 x80 x9989 proceedings volume 435 lecture notes computer science pages 428 xe2 x80 x93446 springer 1990 16 national institute standards technology fips pub 197 advanced encryption standard federal information processing standards publication 197 u s department commerce november 2001 available online http www itl nist gov fipspubs 17 national institute standards technology fips pub 197 advanced encryption standard aes federal information processing standards publication 197 u s department commerce november 2001 18 national institute standards technology cryptographic hash project 2007 available online http www nist gov hash competition 19 t pornin sphlib 3 0 2011 11 25 available http www saphir2 com sphlib files sphlib 3 0 zip 20 k scheibelhofer bit slice implementation whirlpool hash function m abe editor ct rsa volume 4377 lncs pages 385 xe2 x80 x93401 springer 2007 21 s tillich personal communication 2008 mixbytes computation variant 18 x0ctable 5 mixbytes computation separated factors 01 02 04 ai denote input bytes bi bi 1 xe2 x8a x95 bi 2 xe2 x8a x95 bi 4 output bytes xe2 x80 x9c xe2 x80 xa2 xe2 x80 x9d marks inputs ai 02 xc2 xb7 ai 04 xc2 xb7 ai added intermediate results bi j superscripts denote order temporary values computed results factor 02 computed multiplying results factor 01 02 bi 2 02 xc2 xb7 bi 3 mod 8 1 b0 1 b1 1 b2 1 b3 1 b4 1 b5 1 b6 1 b7 1 01 xc2 xb7 a0 xe2 x88 x92 xe2 x80 xa21 xe2 x80 xa2b xe2 x80 xa2b xe2 x80 xa21 xe2 x88 x92 xe2 x80 xa21 xe2 x88 x92 01 xc2 xb7 a1 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa23 xe2 x80 xa23 xe2 x80 xa2 xe2 x80 xa23 xe2 x88 x92 xe2 x80 xa2 01 xc2 xb7 a2 xe2 x80 xa20 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa20 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa20 xe2 x88 x92 01 xc2 xb7 a3 xe2 x88 x92 xe2 x80 xa21 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa21 xe2 x80 xa2 xe2 x80 xa21 xe2 x80 xa2 01 xc2 xb7 a4 xe2 x80 xa22 xe2 x88 x92 xe2 x80 xa22 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa22 01 xc2 xb7 a5 xe2 x80 xa20 xe2 x80 xa2 xe2 x88 x92 xe2 x80 xa20 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa20 xe2 x80 xa2 01 xc2 xb7 a6 xe2 x80 xa22 xe2 x80 xa2a xe2 x80 xa22 xe2 x88 x92 xe2 x80 xa2a xe2 x88 x92 xe2 x88 x92 xe2 x80 xa22 01 xc2 xb7 a7 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa23 xe2 x80 xa23 xe2 x88 x92 xe2 x80 xa23 xe2 x88 x92 xe2 x88 x92 b0 2 b1 2 b2 2 b3 2 b4 2 b5 2 b6 2 b7 2 02 xc2 xb7 a0 xe2 x80 xa2 xe2 x80 xa2 xe2 x88 x92 xe2 x80 xa2 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa2 xe2 x80 xa2 02 xc2 xb7 a1 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x88 x92 xe2 x80 xa2 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa2 02 xc2 xb7 a2 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x88 x92 xe2 x80 xa2 xe2 x88 x92 xe2 x88 x92 02 xc2 xb7 a3 xe2 x88 x92 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x88 x92 xe2 x80 xa2 xe2 x88 x92 02 xc2 xb7 a4 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x88 x92 xe2 x80 xa2 02 xc2 xb7 a5 xe2 x80 xa2 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x88 x92 02 xc2 xb7 a6 xe2 x88 x92 xe2 x80 xa2 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 02 xc2 xb7 a7 xe2 x80 xa2 xe2 x88 x92 xe2 x80 xa2 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa2 xe2 x80 xa2 xe2 x80 xa2 b0 4 b1 4 b2 4 b3 4 b4 4 b5 4 b6 4 b7 4 04 xc2 xb7 a0 xe2 x88 x92 xe2 x80 xa22 xe2 x80 xa22 xe2 x88 x92 xe2 x80 xa25 xe2 x80 xa25 xe2 x88 x92 xe2 x88 x92 04 xc2 xb7 a1 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa23 xe2 x80 xa23 xe2 x88 x92 xe2 x80 xa26 xe2 x80 xa26 xe2 x88 x92 04 xc2 xb7 a2 xe2 x88 x92 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa24 xe2 x80 xa24 xe2 x88 x92 xe2 x80 xa27 xe2 x80 xa27 04 xc2 xb7 a3 xe2 x80 xa20 xe2 x88 x92 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa25 xe2 x80 xa25 xe2 x88 x92 xe2 x80 xa20 04 xc2 xb7 a4 xe2 x80 xa21 xe2 x80 xa21 xe2 x88 x92 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa26 xe2 x80 xa26 xe2 x88 x92 04 xc2 xb7 a5 xe2 x88 x92 xe2 x80 xa22 xe2 x80 xa22 xe2 x88 x92 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa27 xe2 x80 xa27 04 xc2 xb7 a6 xe2 x80 xa20 xe2 x88 x92 xe2 x80 xa23 xe2 x80 xa23 xe2 x88 x92 xe2 x88 x92 xe2 x88 x92 xe2 x80 xa20 04 xc2 xb7 a7 xe2 x80 xa21 xe2 x80 xa21 xe2 x88 x92 xe2 x80 xa24 xe2 x80 xa24 xe2 x88 x92 xe2 x88 x92 xe2 x88 x92 19 02 xc2 xb7 b3 1 02 xc2 xb7 b4 1 02 xc2 xb7 b5 1 02 xc2 xb7 b6 1 02 xc2 xb7 b7 1 02 xc2 xb7 b0 1 02 xc2 xb7 b1 1 02 xc2 xb7 b2 1 x0c