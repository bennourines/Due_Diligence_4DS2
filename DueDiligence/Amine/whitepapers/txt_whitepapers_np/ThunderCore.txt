b The Thunder Protocol Rafael Pass and Elaine Shi Thunder Research 1 Introduction In this white paper we introduce the Thunder protocol a new and provably secure consensus protocol which overcomes the two main bottlenecks of classic blockchains Throughput Existing blockchains as employed by major crypto currencies (e g Bitcoin or Ethereum) require flooding the whole network with all the transactions As a consequence these blockchains do not scale well to handle a large transaction volume For instance Bitcoin and Ethereum can handle less than 10 transactions/second This small throughput severely hinders a wide spread adoption of such crypto currencies As a comparison VISA handles 2000 transactions/sec Confirmation times The security of Nakamoto\xe2\x80\x99s blockchain protocol requires the block time to be significantly larger than the maximum network latency [20] this is why in Bitcoin new blocks of transactions get mined every 10 minutes and a transaction is only considered confirmed once it has been incorporated in a block and there are 5 subsequent blocks following it thus it takes on average one hour for a transaction to be confirmed (with low confidence) While Ethereum uses a smaller block time the average confirmation time still remains relatively high\xe2\x80\x94approximately 13 minutes These long confirmation times hinder many important applications (especially smart contract applications) Our Thunder protocol overcomes both of these issues achieving both high throughput and fast confirmation time (under typical circumstances within 2 network roundtrips) while being robust up to a 50% attack While we are aware of several other recently suggested approaches for overcoming the above two bottlenecks these approaches are either restricted to only payments (and do not handle smart contracts) or provide security only against a weaker 1/3 attack additionally many approaches are based on heuristic arguments whereas our protocol is accompanied by a rigorous proof of security see Section 4 for more details The design of Thunder is inspired by a new theoretical paradigm for consensus proposed in our earlier work Thunderella [21] and provides the first practical instantiation of this general paradigm This paradigm can be instantiated using either Proof of Work or Proof of Stake 1 \x0c2 The Thunder Protocol Following our Thunderella paradigm [21] the key idea behind Thunder is to combine a \xe2\x80\x9cstandard\xe2\x80\x9d blockchain\xe2\x80\x94which we will refer to as the slow chain\xe2\x80\x94with an optimistic fast path The fast path is coordinated by a new entity referred to as the Accelerator and requires the use of a committee of \xe2\x80\x9cstake holders\xe2\x80\x9d As long as a) the Accelerator is acting honestly b) network conditions are good and c)> 3/4 of the committee are honest we barely need to use the slow chain at all instead transactions can be confirmed on the fast path by the committee using an extremely simple and lean fast path protocol This protocol offers both high throughput and instant confirmation of transactions But the fast path only confirms new transactions assuming the above mentioned good conditions are met When they are not (e g the Accelerator misbehaves or is under attack) we leverage the \xe2\x80\x9cslow chain\xe2\x80\x9d to recover in a provably sound manner We proceed to provide a more detailed description of our new consensus protocol 2 1 Consensus and Blockchains Roughly speaking a blockchain is simply a permissionless implementation of a primitive known as state machine replication or consensus in the distributed systems literature Consensus A consensus protocol enables maintaining a \xe2\x80\x9clinearly ordered log\xe2\x80\x9d of transactions in a distributed fashion such that the following two properties hold \xe2\x80\xa2 Consistency at any point in the execution all honest participants have consistent logs of transactions\xe2\x80\x94that is either their logs are identical or one participant\xe2\x80\x99s log is a prefix of the other\xe2\x80\x99s \xe2\x80\xa2 Liveness any honest protocol participant can propose to add a transaction this transaction is then guaranteed to be incorporated into their logs within some fixed small amount of time additionally whenever a participant sees some transaction in their log the same transaction will appear in every other participant\xe2\x80\x99s log within some fixed small amount of time In essence these properties mean that from the view of the participants they are communicating with a trusted third party that maintains a global ordered append only log of transactions that anyone can add to\xe2\x80\x94in essence a public ledger Our goal here is to implement a consensus protocol in the permissionless setting with high throughput and fast confirmation of transactions Blockchains A formal definition of a blockchain can be found in [20] Strictly speaking a blockchain does not directly give the above described consistency property rather the consistency property defined for a blockchain is that players have a consistent view of the blockchain when dropping the last \xce\xba blocks where \xce\xba is a security parameter in other words the last \xce\xba blocks may be \xe2\x80\x9cunstable\xe2\x80\x9d but everything before that has been stabilized (except with exponentially vanishing probability as a function of the security parameter \xce\xba) Other than the above mentioned main properties of consistency and liveness [20] also defines a notion of bounded chain growth the length of the blockchain should grow at a well define pace not to fast and not too slow We will require the use of a slow chain that satisfies such bounded chain growth Pass et al [20] show that Nakamoto\xe2\x80\x99s protocol satisfies all the above properties once the mining hardness is appropriately set (as a function of the network delay and total computing power) 2 \x0cassuming that a majority of the mining is done by honest users (a k a \xe2\x80\x9ccomputational honest majority\xe2\x80\x9d) More precisely the Nakamoto protocol satisfies consistency and liveness if and only if the mining hardness is set as a function of the maximum network latency so that the block time (which in the Bitcoin system is set to 10 minutes) significantly exceeds the maximum network latency Ethereum\xe2\x80\x99s protocol is related to Nakamoto\xe2\x80\x99s and ought to satisfy them as well Security Contexts ipants We will distinguish between two different conditions on the network partic \xe2\x80\xa2 Worst case conditions W under which the protocol is guaranteed to provide consistency and liveness (i e W are conditions under which the protocol is guaranteed to be secure) In our case W will be the conditions that 1 the underlying slow chain is secure (which in turn follows from computational honest majority in the case of Nakamoto\xe2\x80\x99s blockchain) and 2 a majority of the committee is honest Under such worst case conditions confirmation times may be slow and the transaction load may be limited (just as is the case for Bitcoin and Ethereum) \xe2\x80\xa2 Optimistic conditions O under which the transaction volume can be large and transactions are \xe2\x80\x9cinstantly\xe2\x80\x9d confirmed In our case O will be the conditions 1 the slow chain is secure 2 the Accelerator as is online and honest 3 > 43 of the committee is online and honest Our new Thunder protocol will make use of a simple fast path protocol in conjunction with an underlying slow chain to ensure worst case security under W and instant confirmation and highthroughput under O As mentioned above the key idea is to make use of the \xe2\x80\x9cfast path\xe2\x80\x9d protocol when things work well and only use the slow chain to recover from faults 2 2 A Simple Fast Path Protocol Consider first the following simple fast path protocol \xe2\x80\xa2 We have a designated entity the Accelerator \xe2\x80\xa2 All new transactions are sent to the Accelerator the Accelerator bundles up transactions into micro blocks signs each micro block with increasing sequence numbers seq and sends out the signed micro block to a \xe2\x80\x9ccommittee\xe2\x80\x9d of players \xe2\x80\xa2 The committee members \xe2\x80\x9cack\xe2\x80\x9d all Accelerator signed micro blocks by signing them but only ack at most one micro block per sequence number \xe2\x80\xa2 When a micro block has received acks (i e signatures) from more than 3/4 of the committee members we refer to the micro block as being notarized (and the notarization of the microblock is this collection of these signatures 1 Participants can directly output their longest 1 In an actual implementation one would make use of an aggregate signature scheme to describe the notarization in a compact form 3 \x0csequence of consecutive (in terms of their sequence numbers) notarized micro blocks\xe2\x80\x94all transactions contained in them are considered confirmed In this way the fast path instantly finalizes transactions It is easy to prove (and well known) that this protocol is consistent under the condition Wfast = \xe2\x80\x9c> 1/2 of the committee members are honest\xe2\x80\x9d) additionally it satisfies liveness with instant confirmation under the conditions Ofast = \xe2\x80\x9c1) the Accelerator is online and honest 2) > 3/4 of the committee members are online and honest\xe2\x80\x9d In fact under these optimistic conditions we only need 2 communication rounds to confirm a transaction This approach is extremely practical and indeed similar protocols are often used in practice\xe2\x80\x94for instance chain com uses a related protocol for their permissioned consensus protocol The problem with this approach however is that the protocol does not satisfy liveness (even \xe2\x80\x9cslow\xe2\x80\x9d liveness) under condition Wfast If the Accelerator is cheating (or is simply taken down from the network) the protocol halts (Indeed in this case chain com would have to manually fix the issue which is impossible in a decentralized setting ) 2 3 How to Recover from Faults To overcome this problem we leverage the underlying \xe2\x80\x9cslow chain\xe2\x80\x9d which we assume satisfies both consistency and liveness Roughly speaking we deal with this as follows Heartbeats For every length \xe2\x84\x93 of the slow chain the Accelerator takes the hash h of the current log (of the fast path) and sends out the tuple (\xe2\x84\x93 h seq) (where seq is the current sequence number) to get notarized by the committee members (who all check that h is correct based on the history they have seen) we refer to a notarized version of such a tuple (\xe2\x84\x93 h seq) as a heartbeat The Accelerator is subsequently required to post the heartbeat to the slow chain Cool down Next if some user notices that its transaction is not getting confirmed by the accelerator/committee some \xe2\x80\x9cevidence\xe2\x80\x9d of this will become apparent on the underlying slowchain\xe2\x80\x94as we shall see shortly the evidence is simply the fact that no heartbeat has been observed on the slow chain for a sufficiently long period of time (Note that by liveness and the bounded chain growth properties of the slow chain if Accelerator and more than 3/4 of the committee are online and honest we are guaranteed that a heartbeat for length \xe2\x84\x93 gets incorporated close to length \xe2\x84\x93) Whenever such evidence of cheating (i e no recent heartbeat are contained on the slow chain) has been found we enter a \xe2\x80\x9ccool down\xe2\x80\x9d period where committee members stop signing messages from the Accelerator yet we allow anyone to post any \xe2\x80\x9cnew\xe2\x80\x9d notarized transactions (which were not included in the most recent heartbeat) to the slow chain The length of the cool down period is counted in blocks of the slow chain (say \xce\xba blocks where \xce\xba is a security parameter) Slow mode Finally after the cool down period ends we can safely enter a \xe2\x80\x9cslow period\xe2\x80\x9d where transactions only get confirmed in the slow chain blockchain (and the fast path is no longer active) We stay in the slow chain for an appropriate amount of time counted in blocks on the slow chain (e g enough blocks to restore or replace a faulty Accelerator) and can next reboot with a new epoch of the fast path protocol more details on the reboot step can be found in Section 2 4 4 \x0cLet us point out the reason for having a cool down period Without it players may disagree on the set of fast path transactions that have been confirmed before entering the \xe2\x80\x9cslow mode\xe2\x80\x9d and thus may end up with inconsistent views The cool down period enables honest players to post all notarized transactions they have seen to the slow chain and thus (slowly) reach consensus on this set of transactions once we have reached this consistent view (at the end of the cool down) we can finally fully switch over to confirming new transactions on the slow chain Collecting evidence of cheating \xe2\x80\x9cyell\xe2\x80\x9d transactions It remains to explain how to collect evidence that the Accelerator (and/or committee) is cheating or is simply \xe2\x80\x9coffline\xe2\x80\x9d If a player notices that his transaction is not getting confirmed by the Accelerator or committee he can send a special yell transaction (which contains the transaction it wants to see confirmed) to the underlying slow chain The Accelerator is additionally instructed to confirm all such yell transactions it sees on the slow chain Now if a committee member sees some transactions on the slow chain that have not gotten notarized within a sufficiently long amount of time\xe2\x80\x94counted in blocks in the slow chain (say within \xce\xba blocks)\xe2\x80\x94they know that the Accelerator (or a large fraction of the committee members) must be cheating or offline At this point the committee member will stop signing heartbeat messages So as long as just 1/4 of the committee are honest a cheating Accelerator will be \xe2\x80\x9cchoked\xe2\x80\x9d\xe2\x80\x94 no new heartbeats by Accelerator will be notarized Consequently everyone that observes the slow chain will enter the \xe2\x80\x9ccool down\xe2\x80\x9d phase and subsequently the slow mode 2 4 How to Reboot the Fast Path Once we have entered the slow mode where all transactions are being posted on the slow chain we need to have a way to return to the fast path The simplest method is for the current Accelerator (once it has recovered from the fault) to post a \xe2\x80\x9csummon\xe2\x80\x9d message to the slow chain to summon committee members to retry at a certain point of time (expressed in terms of some future height of the slow chain) More generally Thunder nodes can use the slow chain to discuss and vote on how and when to rebootstrap possibly renegotiate the committee and leader election strategy in the meanwhile In the general form nodes can inspect a stabilized prefix of the slow chain and imagine that some predicate can be applied to the prefix to decide when nodes should make an attempt to reboot the fast path (See Section 3 4 for more discussions) 2 5 How to Select the Committee So far we have deferred the discussion of how the committee is selected Also here we may consider multiple approaches Rely on recent miners Perhaps the simplest approach is to select the committee as the miners of say the 500 most recent blocks on the slow chain (as was done in [23]) We note however that to rely on this approach we need to ensure that the underlying is slow chain is \xe2\x80\x9cfair\xe2\x80\x9d [22] in the sense that the fraction of honestly mined blocks is close to the fraction of honest players This is not the case for Nakamoto\xe2\x80\x99s original blockchain nor Ethereum (see e g [14]) but as shown in [22] any blockchain can be turned into a fair one If we use this approach the resulting protocol will now be consistent and live under simply the 5 \x0ccondition W =\xe2\x80\x9ccomputational honest majority\xe2\x80\x9d (as this condition implies that a majority of the committee will be honest) and high throughput and instant confirmation holds under the optimistic conditions O = \xe2\x80\x9c1) The Accelerator is honest 2) > 3/4 fraction of the mining power is honest \xe2\x80\x9d Subsample from all stake holders If the blockchain is used for a cryptocurrency (as we intend here) we may instead select the committee by subsampling from the recent stake holders This can be done using the method from our earlier work Snow White [11] The committee that is active when the slow chain has a length \xe2\x84\x93 is selected based on the stake holders when then the slow chain had length \xe2\x84\x93 \xe2\x88\x92 2\xce\xba by using a selection function that takes as input the hash of the chain at length \xe2\x84\x93\xe2\x88\x92\xce\xba As explained in more detail in our earlier work [11] the reasons for the 2\xce\xba \xe2\x80\x9clook back\xe2\x80\x9d is to prevent against attacks where an attacker adaptively selects its keys to have a higher probability of getting elected to the committee This approach ensures consistency and liveness under the conditions W = \xe2\x80\x9c1) the slow chain is secure 2) > 1/2 of the stake holders are honest\xe2\x80\x9d and achieves fast confirmation under the conditions O = \xe2\x80\x9c1) The Accelerator is online and honest 2) > 3/4 of the stake holders are online and honest\xe2\x80\x9d The drawback of this approach is that it may be too optimistic to assume that a majority of stake holders are online (and thus the conditions for the fast path may rarely hold) The next approach deals with that issue Select from stake holders putting down an escrow One potential drawback of the above approach is that not stake holders may want to participate in transaction validation Rather than subsampling from the full set of stake holders we may instead ask stake holders that intend to participate the to put down an escrow (as a message posted on the slow chain) We can then select from these stake holders who have put down escrow One idea is to select the members putting down the most amount of escrow since we would like to encourage more stake to join the committee and protect the fast path The actual algorithm we implemented is motivated by this idea but a carefully crafted variant such that we can prove that the equilibrium behavior satisfies certain desirable properties More generally committee selection can be performed by applying a general predicate to a stabilized part of the slow chain 3 The Full Thunder Protocol Specification We here provide the full protocol specification We let \xce\xba be a security parameter as mentioned before we will require the underlying slow chain to guarantee consistency and liveness except with negligible probability in \xce\xba (Concrete parameters will be presented in a forthcoming implementation paper ) For simplicity of exposition we first describe a protocol that starts off in the fast mode and simply enters the slow mode when the optimistic conditions stop holding later in Section 3 4 we explain how to extend the protocol to enable a \xe2\x80\x9creboot\xe2\x80\x9d of the fast mode For simplicity we also assume that each microblock contains just a single transaction tx\xe2\x80\x94in practice a microblock will contain a batch of transactions (and our protocol can be extended to deal with any batching method) 6 \x0c3 1 Notations and Useful Definitions \xe2\x80\xa2 The underlying slow chain Nodes (a k a \xe2\x80\x9cminers\xe2\x80\x9d) run an underlying blockchain protocol referred to as the \xe2\x80\x9cslow chain\xe2\x80\x9d we use the notation chain to denote a node\xe2\x80\x99s the view of the slow chain We use the notation chain[ \xe2\x84\x93] to denote the prefix of chain upto the \xe2\x84\x93 th block we use chain[ \xe2\x88\x92\xe2\x84\x93] to denote chain where the last \xe2\x84\x93 blocks have been removed (Recall that the consistency property of a blockchain does not guarantee that everyone has a consistent view of the whole chains but they do once the last \xce\xba where \xce\xba is a security parameter blocks\xe2\x80\x94that is the \xe2\x80\x9cunstable blocks\xe2\x80\x9d have been removed ) We chain[\xe2\x84\x93 \xe2\x84\x93\xe2\x80\xb2 ] to denote the part of chain from the \xe2\x84\x93 th block to the \xe2\x84\x93\xe2\x80\xb2 th block We assume there there is some commonly known starting length \xe2\x84\x93start for the slow chain at which we begin the execution of the Thunder protocol 2 \xe2\x80\xa2 Committee selection We assume that there is a publicly known function denoted comm which takes as input the stabilized part of the blockchain chain[ \xe2\x88\x92\xce\xba] and outputs a set of committee members denoted comm(chain[ \xe2\x88\x92\xce\xba]) (We discussed a few concrete committee selection methods in Section 2 5 ) \xe2\x80\xa2 Micro blocks Each micro block in the fast path log has the form (mblock seq \xe2\x84\x93 tx) where seq \xe2\x88\x88 N is a sequence number \xe2\x84\x93 is the slow chain length associated with the micro block (indicating the slow chain length when this transaction was proposed) and tx is a transaction \xe2\x80\xa2 Heartbeats A heartbeat has the same form as a micro block except that the transaction tx is replaced simply by the hash h of the log more precisely a heartbeat has the form (heartbeat seq \xe2\x84\x93 h) We say that such a heartbeat is associated with slow chain length \xe2\x84\x93 \xe2\x80\xa2 Notarization Let m be of the form (mblock seq \xe2\x84\x93 ) or (heartbeat seq \xe2\x84\x93 ) We say that \xcf\x83 is the notarization of m w r t chain if a) \xe2\x84\x93 \xe2\x89\xa4 |chain| and b) \xcf\x83 is a valid aggregate signature from more than 43 fraction of the members of comm(chain[ \xe2\x84\x93 \xe2\x88\x92 \xce\xba]) as well as from the Accelerator Whenever chain is clear from context we simply say that \xcf\x83 is a notarization of m A node i considers \xcf\x83 to be a notarization of m if \xcf\x83 is a notarization of m w r t the node i\xe2\x80\x99s view of the slow chain Finally a notarized microblock (or heartbeat) is simply a pair consisting of a microblock (or heartbeat) and a notarization of it \xe2\x80\xa2 Skipped heartbeats We say that the slow chain chain has a skipped heartbeat if there exists some \xe2\x84\x93 such that a) \xe2\x84\x93start \xe2\x89\xa4 \xe2\x84\x93 \xe2\x89\xa4 |chain| \xe2\x88\x92 2\xce\xba and b) chain[\xe2\x84\x93 \xe2\x88\x92 \xce\xba \xe2\x84\x93 + \xce\xba] does not contain a notarized heartbeat associated with length \xe2\x84\x93 3 \xe2\x80\xa2 Yell transactions A yell transaction is a transaction on the slow chain with a special typemodifier yell 2 Later when we may have multiple epochs of the fast mode we can use the slow chain to reach common knowledge on the starting length \xe2\x84\x93start 3 That is there exists a 2\xce\xba windows in the stabilized part of chain which does not contain its appropriate heartbeat 7 \x0c3 2 Fast Mode Protocol Everyone \xe2\x80\xa2 Storing notarized messages Upon receiving a message m and a notarization \xcf\x83 of m (w r t chain) store m and mark m is as being notarized \xe2\x80\xa2 Extracting the log a) A lucky sequence is defined to be a sequence of notarized tuples with consecutive sequence numbers (T1 1 \xe2\x84\x931 ) (T2 2 \xe2\x84\x932 ) (Tk k \xe2\x84\x93k ) such that \xe2\x80\x93 \xe2\x84\x931 = \xe2\x84\x93start \xe2\x80\x93 for every i \xe2\x88\x88 [k] Ti \xe2\x88\x88 {mblock heartbeat} \xe2\x80\x93 for every i \xe2\x88\x88 [k] \xe2\x84\x93i+1 = \xe2\x84\x93i + 1 if Ti = heartbeat and otherwise \xe2\x84\x93i+1 = \xe2\x84\x93i b) Let \xe2\x84\x93 be the first skipped heartbeat in chain[ \xe2\x88\x92\xce\xba] Find a lucky sequence denoted LOGstable that has been observed so far and is consistent with all heartbeats at lengths \xe2\x84\x93start \xe2\x84\x93start + 1 \xe2\x84\x93 \xe2\x88\x92 1 in chain[ \xe2\x88\x92\xce\xba] c) Let LOG be a maximal lucky sequence observed so far \xe2\x80\x94 if there are ties break ties arbitrarily Output LOGstable concatenated with all transactions in LOG whose sequence number has not appeared in LOGstable \xe2\x80\xa2 Transitioning to \xe2\x80\x9cslow mode\xe2\x80\x9d If noticing that chain contains a skipped heartbeat transition to executing the slow mode protocol (described below in Section 3 3) The Accelerator \xe2\x80\xa2 Init set seq = 0 \xe2\x80\xa2 Microblock notarization requests Upon observing any new transaction tx (either transmitted over the network or part of a yell transaction in chain) \xe2\x80\x93 let seq = seq + 1 \xe2\x80\x93 sign the tuple m = (mblock seq |chain| tx) producing the signature \xcf\x83 acc \xe2\x80\x93 send the notarization request (m \xcf\x83 acc ) to the members of comm(chain[ \xe2\x88\x92\xce\xba]) \xe2\x80\xa2 Heartbeat notarization requests Whenever the Accelerator notices that the length of the slow chain chain has grown by 1 4 \xe2\x80\x93 let LOG be the Accelerator\xe2\x80\x99s current fast path log \xe2\x80\x93 let seq = seq + 1 \xe2\x80\x93 sign the heartbeat m = (heartbeat seq \xe2\x84\x93 H(LOG)) where H(LOG) is a cryptographic digest of the fast path log and \xe2\x84\x93 is the length of the slow chain before the increment\xe2\x80\x94let \xcf\x83 acc denote the signature \xe2\x80\x93 send the notarization request (m \xcf\x83 acc ) to the members of comm(chain[ \xe2\x88\x92\xce\xba]) 4 We may without loss of generality assume that the slow chain always grows by at most one step\xe2\x80\x94we can always emulate a multi step hop by several one step hops 8 \x0c\xe2\x80\xa2 Notarization Upon receiving signatures from > 43 fraction of comm(chain[ \xe2\x84\x93 \xe2\x88\x92 \xce\xba]) on some message m of the form (mblock \xe2\x84\x93 ) or (heartbeat \xe2\x84\x93 ) for which a notarization request was sent out compute an aggregate signature \xcf\x83 from the collected signatures as well as the Accelerator\xe2\x80\x99s own signature on m and broadcast m as well as its notarization \xcf\x83 Committee members Upon receiving a tuple m of the form (mblock seq \xe2\x84\x93 tx) or (heartbeat seq \xe2\x84\x93 h) with a valid signature from the Accelerator \xe2\x80\xa2 \xe2\x80\xa2 \xe2\x80\xa2 \xe2\x80\xa2 \xe2\x80\xa2 assert that the node is a member of comm(chain[ \xe2\x84\x93 \xe2\x88\x92 \xce\xba]) assert that \xe2\x84\x93 is within \xc2\xb10 5\xce\xba of |chain| assert that no other tuple with the sequence number seq has been signed If m is of type mblock sign m and return the the tuple and signature to the Accelerator If m is of the type heartbeat \xe2\x80\x93 assert that h = H(LOG\xe2\x80\xb2 ) where LOG\xe2\x80\xb2 is the node\xe2\x80\x99s fast path log up to sequence number seq \xe2\x88\x92 15 \xe2\x80\x93 let TXs\xe2\x88\x97 be all yell transactions in chain[ \xe2\x88\x92\xce\xba] assert that LOG contains all of them \xe2\x80\x93 sign m and return the the tuple and signature to the Accelerator Clients Upon receiving a transaction tx \xe2\x80\xa2 Send tx to the accelerator \xe2\x80\xa2 If the transaction has not gotten included in the node\xe2\x80\x99s fast path log before the slow chain has grown by \xce\xba steps broadcast a yell transaction for tx (to the underlying slow chain) Miners Participate in the underlying slow chain\xe2\x80\x99s mining The input to the slow chain protocol includes \xe2\x80\xa2 every yell transaction the node is aware of that has not yet been included in the slow chain \xe2\x80\xa2 every notarized heartbeat that has not been included in the slow chain so far 3 3 Slow Mode Protocol In the slow mode committee members ignore all messages from the accelerator Clients propose transactions only to the slow chain by broadcasting any new transaction it receives as input Miners \xe2\x80\xa2 Let \xe2\x84\x93\xe2\x88\x97 be the smallest skipped heartbeat that triggered the slow mode \xe2\x80\xa2 Let h\xe2\x88\x97 be the hash digest inside the heartbeat associated with length \xe2\x84\x93\xe2\x88\x97 \xe2\x88\x92 1 in chain and let LOG\xe2\x88\x97 be the prefix of the fast path log that matches the hash h\xe2\x88\x97 \xe2\x80\xa2 Participate in the slow chain mining in every round input to the slow chain protocol 1) every notarized transaction that is not contained in LOG\xe2\x88\x97 and not in chain and 2) every other transaction it has observed (including those inside yell transactions) but has not been incorporated in LOG\xe2\x88\x97 or chain yet Everyone 5 If this condition does not hold store the transaction in an incoming message buffer until the sequence number in LOG exceeds seq 9 \x0c\xe2\x80\xa2 Broadcast the fast path log including a notarization on every micro block \xe2\x80\xa2 Let \xe2\x84\x93 be the earliest block such that chain[ \xe2\x84\x93] contains a skipped heartbeat6 \xe2\x80\xa2 Let LOG be the maximal lucky sequence (see Section 3 2) of notarized tuples (T1 1 \xe2\x84\x931 tx1 ) (T2 2 \xe2\x84\x932 tx2 ) (TL L \xe2\x84\x93L txL ) where each notarized tuple has been observed up until the end of the cool down period i e in the prefix chain[ \xe2\x84\x93 + 2\xce\xba]7 If there are multiple such lucky sequences let LOG be an arbitrary one \xe2\x80\xa2 Suppose that chain[ \xe2\x88\x92\xce\xba] contains heartbeats at consecutive slow chain lengths \xe2\x84\x931 \xe2\x84\x932 \xe2\x84\x93k where \xe2\x84\x93i = \xe2\x84\x93start + i \xe2\x88\x92 1 Let LOGstable be a lucky sequence of notarized tuples consistent with the hashes of these heartbeats8 \xe2\x80\xa2 Output the concatenation of the following in every round \xe2\x80\x93 LOGstable \xe2\x80\x93 every tuple in LOG whose sequence number is not included in LOGstable \xe2\x80\x93 all other transactions contained in chain[ \xe2\x88\x92\xce\xba] that have not yet been output (in the same order as they appear in chain) 3 4 Rebooting the Fast Path When nodes are in the slow mode they can reboot a fast path execution again as follows let start(\xc2\xb7) be some general predicate which determines when to leave the slow mode (examples of such predicates can be found in Section 2 4) Let \xe2\x84\x93 be the earliest block such that chain[ \xe2\x84\x93] contains a skipped heartbeat Let chain\xe2\x88\x97 be the shortest prefix of chain such that If \xe2\x84\x93 \xe2\x89\xa4 |chain\xe2\x88\x97 | \xe2\x88\x92 3\xce\xba and start(chain\xe2\x88\x97 [ \xe2\x88\x92\xce\xba]) = 1 where start is a policy predicate a node would now enter the fast mode and reset \xe2\x84\x93start = |chain\xe2\x88\x97 | When there are multiple transitions between slow and fast modes we need to assign a unique epoch number every time a new fast mode is initiated All mblock and heartbeat messages should be additionally tagged with the epoch number (for simplicity our earlier description omitted this epoch number) Finally when there are multiple epochs (where each epoch contains a fast mode followed by a slow mode) nodes should sequentially output the logs of all epochs one by one (our above description explained how to output the log from one such epoch) 4 Comparison with Related Initiatives We provide some comparisons with related initiatives \xe2\x80\xa2 Offchain payment channels (e g Lightning Networks [1] and Raiden networks [2]) and state channels [13 18] support fast offchain payments but existing systems offer little to no smart contract programming support moreover parties need to engage in a prior setup \xe2\x80\xa2 Several initiatives rely on \xe2\x80\x9cclassical style\xe2\x80\x9d consensus methods to build a decentralized cryptocurrency For example Zilliqa [3] and Tendermint [17] rely on PBFT [9] or its variants to reach consensus In comparison with Thunder which combines an asynchronous fast path and a synchronous \xe2\x80\x9cfallback\xe2\x80\x9d PBFT instead relies on an asynchronous recovery path This means that 6 As an optimization in practice it suffices to check the part of the slow chain chain[\xe2\x84\x93start \xe2\x88\x92 \xce\xba \xe2\x84\x93] if \xe2\x84\x93 + 2\xce\xba exceeds |chain| we round it down to |chain| 8 If such a lucky sequence has not been observed query nodes on the network for such a lucky sequence and before a reply is obtained just output the same log as the previous round 7 10 \x0c1) PBFT can tolerate at most < 31 fraction corruption due to a well known lower bound [12] (in contrast our approach tolerates up to a 50% attack) 2) PBFT requires more rounds of voting in the normal path (which is necessary for an asynchronous recovery) and thus is at least twice as slow as our protocol and 3) in comparison our approach is conceptually much simpler than PBFT and thus friendlier to implementation and large scale deployment [15 19] \xe2\x80\xa2 The beautiful work of Algorand [10] designs a new synchronous state machine replication protocol and builds a cryptocurrency on top Just like ours their protocol is provably secure However it only tolerates up to 13 corruptions moreover their approach requires complete redesign of the consensus layer whereas our approach allows us to accelerate any existing blockchain using a simple fast path protocol \xe2\x80\xa2 Several works rely on a DAG based approach [4 25] (rather than chain based) to prevent doublespending These works do not realize our notion of a linearly ordered log they also do not support general smart contracts/DApps \xe2\x80\xa2 Dfinity\xe2\x80\x99s approach [5] relies on offchain voting on blocks to reach finality in \xe2\x80\x9c2 blocks of time\xe2\x80\x9d Their approach does not improve throughput w r t to the underlying slowchain \xe2\x80\xa2 Ethereum\xe2\x80\x99s Casper [7 8] also relies on offchain voting on blocks but they do so to checkpoint blocks and not to improve speed and throughput The elegant Plasma framework by Poon and Buterin [24] and several sharding initiatives [3 6 16] are conceptually related to ours These approaches are orthogonal and complementary to our effort 5 Acknowledgments We are very grateful to the Thunder team and to Vitalik Buterin for his insightful feedback and comments References [1] https //lightning network/ [2] https //raiden network/ [3] https //www zilliqa com/ [4] http //iota org/ [5] https //dfinity org/ [6] On Sharding Blockchains https //github com/ethereum/wiki/wiki/Sharding FAQ [7] Vitalik Buterin https //medium com/@VitalikButerin/ minimal slashing conditions 20f0b500fc6c 2017 [8] Vitalik Buterin and Vlad Zamfir Casper https //blog ethereum org/2015/08/01/ introducing casper friendly ghost/ 2015 11 \x0c[9] Miguel Castro and Barbara Liskov Practical byzantine fault tolerance In OSDI 1999 [10] Jing Chen and Silvio Micali Algorand https //arxiv org/abs/1607 01341 2016 The efficient and democratic ledger [11] Phil Daian Rafael Pass and Elaine Shi Snow white Robustly reconfigurable consensus and applications to provably secure proofs of stake Cryptology ePrint Archive Report 2016/919 2016 [12] Cynthia Dwork Nancy Lynch and Larry Stockmeyer Consensus in the presence of partial synchrony J ACM 1988 [13] Stefan Dziembowski Lisa Eckey Sebastian Faust and Daniel Malinowski Perun Virtual payment channels over cryptographic currencies IACR Cryptology ePrint Archive 2017 635 2017 [14] Ittay Eyal and Emin Gun Sirer Majority is not enough Bitcoin mining is vulnerable In FC 2014 [15] Pedro Fonseca Kaiyuan Zhang Xi Wang and Arvind Krishnamurthy An empirical study on the correctness of formally verified distributed systems In Proceedings of the Twelfth European Conference on Computer Systems EuroSys \xe2\x80\x9917 pages 328\xe2\x80\x93343 New York NY USA 2017 ACM [16] E Kokoris Kogias P Jovanovic L Gasser N Gailly E Syta and B Ford Omniledger A secure scale out decentralized ledger via sharding In 2018 IEEE Symposium on Security and Privacy (SP) volume 00 pages 19\xe2\x80\x9334 2018 [17] Jae Kwon Tendermint tendermint pdf 2014 Consensus without mining http //tendermint com/docs/ [18] Andrew Miller Iddo Bentov Ranjit Kumaresan and Patrick McCorry Sprites Payment channels that go faster than lightning CoRR abs/1702 05812 2017 [19] Andrew Miller Yu Xia Kyle Croman Elaine Shi and Dawn Song The honey badger of BFT protocols In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security CCS \xe2\x80\x9916 pages 31\xe2\x80\x9342 New York NY USA 2016 ACM [20] Rafael Pass Lior Seeman and Abhi Shelat Analysis of the blockchain protocol in asynchronous networks In Eurocrypt 2017 [21] Rafael Pass and Elaine Shi Thunderella Blockchains with optimistic instant confirmation https //eprint iacr org/2017/913 pdf [22] Rafael Pass and Elaine Shi Fruitchains A fair blockchain In PODC 2017 [23] Rafael Pass and Elaine Shi Hybrid consensus Efficient consensus in the permissionless model In DISC 2017 [24] Joseph Poon and Vitalik Buterin Plasma Scalable autonomous smart contracts https //plasma io/ 12 \x0c[25] Yonatan Sompolinsky Yoad Lewenberg and Aviv Zohar SPECTRE A fast and scalable cryptocurrency protocol IACR Cryptology ePrint Archive 2016 1159 2016 13 \x0c 