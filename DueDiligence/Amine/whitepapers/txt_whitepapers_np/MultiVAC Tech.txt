b MultiVAC A High Throughput Flexible Public Blockchain Based on Trusted Sharding Computation core@mtv ac MultiVAC Foundation June 2018 version 0 1 Abstract MultiVAC is a next generation high performance public blockchain for industrial scale decentralized applications Its trusted sharding technology allows for unlimited and sustainable scalability and it provides a novel approach towards solving the blockchain scalability problem currently preventing mainsteam blockchains from reaching industrial capability MultiVAC is the first to propose a sharding model based on Verifiable Random Functions (VRF) and applies this model to transactions computation and storage We confirm transactions in our network through a classic UTXO model with miners dynamically selected through a probability model MultiVAC allows for the high levels of safety and reliability needed by industrial applications while only requiring processing on a small number of nodes producing significant speed improvements On top of our fast and scalable blockchain model MultiVAC is the first in the industry to provide a computational model for smart contracts which allows developers to flexibly decide for themselves the tradeoff between consistency availability and partition tolerance parameters that are often stiffly fixed by the designs of many public blockchains We achieve this by providing a general purpose virtual machine MVM equipped with a specially designed blockchain instruction set (BISC) and a powerful method to validate the correctness of smart contract executions (PoIE) With this suite of breakthroughs MultiVAC is extremely fast totally scalable and robustly allows for the development of extremely complicated business logic on its application layer an ideal blockchain to serve as the foundational layer of a public diversified blockchain ecosystem Keywords blockchain shard reliability probability model flexibility 1 Problems with Traditional Blockchain Blockchains must be scalable to achieve their full economic use in society This statement necessarily entails compromises It is known that blockchain protocols suffer from the so called impossible triangle it is impossible for a single blockchain to have at once the three desiderata of security decentralization and scalability The largest public blockchains today compromise between the three features for example Bitcoin[1] and Ethereum[11] are secure and decentralized but are also completely unscalable The computational power of their entire network is stuck at the level of a single miner On the other hand sharding models such as Zilliqa[16] and Dfinity[19] abandon security guarantees for scalability and models like EOS[13] abandon decentralization and attempt to solve the performance bottleneck using supernodes State channel technologies such as Plasma[28] take yet another approach by taking the transactions off chain when attempting to solve the scaling issue Massive amounts of research and development are already being invested into scaling blockchain leading to recent throughput levels of several thousand transactions per second (e g EOS[13] and Seele[18] reach 1000 3000 tps in some experiments tps = transactions per second) Despite this the low hardware processing capacity of a single miner is still the major bottleneck As these networks\ speed do not improve as they scale in node number there is no significant incentive pushing them to enlarge resulting in network growth at underwhelming rates as of 12 00 Noon (UTC time) on May 13 2018 there were only 10 424 full nodes on the ten year old Bitcoin blockchain [7] and only 14 383 on Ethereum [8] MultiVAC believes that the viability of blockchain for businesses today depend on whether or not blockchains can provide general purpose computation whole network transactions and network wide contract processing in a scalable expandable and adaptable way We propose a trusted sharding model that solves the scalability problem allowing for the unlimited accumulation of transaction power from nodes worldwide i e scalability without limit We construct and exploit a relationship between the network division of labor and consensus reliability to make our model effective MultiVAC performs sharding independently for transaction processing and for smart contract execution creating an incredibly supportive and flexible base layer blockchain platform DApps on MultiVAC can realize generalpurpose computational business logic and can flexibly decide according to their own security needs how many nodes on which they wish to run their code MultiVAC solves three fundamental problems 1 How to create shards from network nodes for transaction and smart contract processing in a trustworthy manner allowing the network to scale 2 How to process transactions and update records using trusted shards in the use case of transaction processing 3 How to verify the correct and honest execution of smart contract code by network nodes in the use case of smart contract processing We summarize the presentation of our system in this paper MultiVAC creates shards through a novel probability model based on Verifiable Random Functions (VRF) solving the problem of how to safely efficiently and randomly shard the network We use the Byzantine consensus family to reach internal consensus within a shard achieving the construction of trustworthy shard based consensus We ready our blockchain for smart contract deployment by designing an optimized virtual machine MVM capable of general purpose computation which is equipped with a special blockchain instruction set BISC and which verifies correctness of contract execution through Proof of Instruction Execution (PoIE) This creates a not only trusted but also flexible execution environment that allows for the execution of complicated general purpose business logic 2 Verifiable Random Functions A consensus algorithm is a mechanism for selecting bookkeeping nodes In this process overall consideration should be paid to the efficiency and equitability of the selection with 1 \x0ceach honest node ideally given equal opportunity to participate in the bookkeeping process This was achieved in Bitcoin and Ethereum by using Proof of Work (PoW) which guarantees that the node selection process is sufficiently random and that the network regulations can only be broken with the collusion of over 51% of the network\ s total compute power PoW is an elegant solution that embodies the equitability inherent in the paradigm of decentralization but it is also massively inefficient Another approach to node selection is the DPoS algorithm represented by Graphene which improves the throughput of a PoW system but abandons randomness by giving up the ability for common nodes to participate in consensus thus sacrificing decentralized equitability for efficiency Yet other consensus algorithms i e PBFT [2] ( (# $ ) complexity) and RAFT [21] are equitable but difficult to realize on public blockchains in large scale due to high communication costs MultiVAC believes that Bitcoin and Ethereum have a desirable degree of equitability by allowing all ordinary nodes to have a say in the verification process This property is the bedrock of blockchain\ s future development Ethereum has even designed a custom hash function called ETHash to keep its network equitable and to combat ASIC mining returning bookkeeping power from specialized miners to ordinary users However the PoW system remains to be extremely wasteful and thus we choose a better node selection process based on Verifiable Random Functions (VRF) The ideal node selection algorithm integrates both equitability (randomness) and efficiency Decentralization is the most basic value proposition of blockchains but the future of blockchains also depends on substantial efficiency improvements to current systems An optimal method for resolving this contradiction is the usage of Verifiable Random Functions (VRF) a framework also used in Algorand[4] Dfinity\ s BLS [5] and Cardano\ s Ouroboros Praos algorithm [6] Verifiable Random Functions satisfy at the same time the requirements for equitability and efficiency Intro to VRFs VRFs are pseudorandom functions such that the functions\ user can produce a proof allowing all parties to verify the function was calculated correctly without ever needing to disclose the random function itself In our case a satisfactory VRF has the following desirable characteristics 1 It can be used to verify that a random number generator has provided a rigorous level of randomness 2 It is impossible to predict or control 3 It is a non interactive algorithm and so can be implemented with lower cost and higher efficiency Definition and Properties Formally a VRF consists of three polynomial time functions VRF Verify is able to verify whether or not the encrypted output value did indeed come from the VRF Evaluate calculation given the proof the public key and the value of D Both VRF Generate and VRF Verify are probabilistic functions while VRF Evaluate is deterministic Now given any three polynomial time functions J K and L over integers such that J N \xe2\x86\x92 N \xe2\x88\xaa {\xe2\x88\x97} K N \xe2\x86\x92 N L N \xe2\x86\x92 N We say VRF = {Generate Evaluate Verify} is a verifiable pseudorandom function with input length J(C) output length K(C) and security level L(C) if the following three conditions are satisfied 1 then Prob[VRF Verify(@A D E F) = true] > 1 \xe2\x88\x92 2ST(=) where the left side of the greater than sign is over coin tosses of VRF Verify 2 VRF Generate 1= > \xe2\x86\x92 {@A BA} VRF Generate generates the pair @A (public key) and BA (secret key) according to a security parameter C VRF Evaluate(BA D) \xe2\x86\x92 {E(BA D) F(BA D)} VRF Evaluate produces an encrypted output value E and a proof F according to the private key and some input D VRF Verify(@A D E F) \xe2\x86\x92 (true|false) Unique Provability For any @A D E_ E$ F_ F$ such that E_ \xe2\x89\xa0 E$ for all a @bcK[VRF Verify(@A D Ed Fd ) = ebfg] < 2ST(=) 3 Residual Pseudorandomness For any algorithm i = ij ik > with original input 1= taking total execution count less than or equal to L(C) and for any \xe2\x8b\x85 \xe2\x89\xa0 D let ) (D Fm) \xe2\x86\x90 ijopq jrWstWuv(wx \xe2\x8b\x85 (1= @A) where @A BA are generated through yz{ |g#gbJeg Now we define a random event X which takes on two states with equal probability 0 5 each Depending on the state of X we determine a value for E} either randomly or from E(BA D) Prob~\x7f E} = E(BA D)\xc3\x84 = 0 5 pW\xc3\x89\xc3\x91\xc3\x96\xc3\x9c Prob \xc3\x87\x7f E} \xc3\xa1\xe2\x8e\xaf\xe2\x8e\xaf\xe2\x8e\xaf\xe2\x8e\xaf\xc3\xa2 {0 1}X(=) \xc3\xa4 = 0 5 We require that no prediction algorithm ik is able to accurately predict within the margin of safety the actual state of X that generated E} VRF = {Generate Evaluate Verify} These functions perform the following operations Probabilistic Correctness The probability of the following two conditions is each not less than 1 \xe2\x88\x92 2ST(=) a) Domain Range Correctness For any D \xe2\x88\x88 {0 1}W(=) we have E(BA D) \xe2\x88\x88 {0 1}X(=) b) Complete Provability For any D \xe2\x88\x88 {0 1}W(=) if (E F) = VRF Evaluate(BA D) @bcK \xc3\x87ikopq jrWstWuv(wx \xe2\x88\x97) 1= E} Fm> = \x7f\xc3\xa4 \xe2\x89\xa4 0 5 + L(C)S_ VRF defines a complete random number generator that can be used to select bookkeepers as well as to generate validation challenges We need to make a modification to VRF to make it work in our framework in addition to the above three properties (probabilistic correctness unique provability and residual pseudorandomness) we also require that the random numbers in our blockchain system be unpredictable because if the random function can be predicted then a miner\ s identity can exposed before he is finished verifying transactions allowing him to be the subject of attacks which can result in the failure of bookkeeping There exists a concept called Verifiable Unpredictable 2 \x0cFunctions (VUF) that has the same definition as VRF and which satisfies properties 1 and 2 but modifies property 3 into property 4 below 4 Unpredictability for any algorithm T for \xe2\x88\x97\xe2\x89\xa0 D Prob~i \xc3\xa7\xc3\xa9\xc3\xa8 \xc3\xaa\xc3\xab\xc3\xad\xc3\xac\xc3\xae\xc3\xad\xc3\xaf\xc3\xb1(wx \xe2\x88\x97) 1= @A> = E(BA D)\xc3\x84 \xe2\x89\xa4 L(\xce\xbb)S_ In our case we use a VRF that is also a VUF that is it satisfies condition 4 as well as 1 3 The method of adapting VRF to be unpredictable is found in [3] and is beyond the scope of this paper 3 Sharding using VRF probabilities We apply VRFs to node selection by using them in our sharding process Assuming there are N nodes in the whole network we attempt to select shards with \xc3\xb2 nodes A random number z that is generated on the MultiVAC main chain is encrypted by node a according to each node\ s VRF private key producing a 256 bit random number zd A node is picked into the shard if the following condition holds zd \xc3\xb2 \xe2\x89\xa4 2$\xc3\xb4\xc3\xb6 N Thus the probability of a node being selected as an inshard node is \xc3\xb5= \xc3\xb2 N Due to node selection being completely probabilistic it is highly likely that the number of nodes in an actual shard is not equal to \xc3\xb2 The probability that there are exactly \xc3\xba nodes in the shard is exactly N \xc3\xb5(\xc3\xb9 \xc3\x9c) = \xc3\xbb \xc3\xbc \xc3\xb5\xc3\xb9 (1 \xe2\x88\x92 \xc3\xb5)\xe2\x80\xa0S\xc3\xb9 \xc3\xba = N \xc3\xb2 \xc3\xb9 \xc3\xb2 \xe2\x80\xa0S\xc3\xb9 \xc2\xa2 \xc2\xa3 \xc2\xa21 \xe2\x88\x92 \xc2\xa3 \xc3\xba (N \xe2\x88\x92 \xc3\xba) N N Note that for \xc3\xba = 0 this value is always greater than zero thus there always exists a tiny non zero chance that we produce empty shards a probability that should not affect practical usage but which should be minimized We can use the value \xc3\xb5(\xc3\xb9 \xc3\x9c) to analyze the influences of the shard size on the reliability of the consensus in the shard In the most common case N is very large and in particular far larger than \xc3\xb2 and \xc3\xba For this case we can simplify the above formula somewhat \xc3\xb9 \xc3\xb5(\xc3\xb9 \xc3\x9c) = N \xe2\x8b\x85 (N \xe2\x88\x92 1) \xe2\x8b\x85\xe2\x8b\x85\xe2\x8b\x85 (N \xe2\x88\x92 \xc3\xba + 1) \xc3\xb2 \xc3\xb2 \xe2\x88\x99 \xe2\x88\x99 \xc2\xa21 \xe2\x88\x92 \xc2\xa3 N\xc3\xb9 \xc3\xba N N \xe2\x8b\x85 (N \xe2\x88\x92 1) \xe2\x8b\x85\xe2\x8b\x85\xe2\x8b\x85 (N \xe2\x88\x92 \xc3\xba + 1) \xe2\x89\x88 1 N\xc3\xb9 \xc3\x9c \xe2\x80\xa0S\xc3\xb9 \xc3\x9fa\xc3\xb2\xe2\x80\xa0\xe2\x86\x92\xc2\xae \xc2\xa21 \xe2\x88\x92 \xc2\xa3 \xe2\x80\xa0 Thus when N is very large \xc3\xb5m(\xc3\xb9 \xc3\x9c) \xe2\x89\x88 Blockchain as a shard of the real world As an aside our definition of shard and the above formulation gives us another way to look at blockchains 1) Blockchains are networked consensus systems which are subsets of the wider network of all connected things (the internet) and thus can be considered shards of the entire internet 2) The reliability of a blockchain\ s internal consensus is mainly related to its internal node count and not related to what its size is in proportion to the wider internet Any blockchain including Bitcoin and Ethereum has a reliability value directly positively related to the participant node number i e the number of full nodes in the network 10424 for Bitcoin [7] and 14383 for Ethereum [8] We can consider all networked entities including people objects and machines as nodes in a massive \ real world\ network with a blockchain connecting only being a subset of them Compared with node counts in any particular blockchain the size of the wider internet (the true value of N) is clearly infinitely larger Our preliminary model applies directly to the wider internet and permits us to see any particular blockchain as a \ shard\ of the real world internet from which we also derive that the reliability of a blockchain is primarily related to its node number Conditions for consensus We define a consensus algorithm\ s margin of safety \xc2\xa9 as follows if a reliable consensus among \xc3\xb2 nodes is required then the proportion of honest nodes must not be less than \xc2\xa9 We list some reference values for \xc2\xa9 below In PBFT systems with sufficiently large node number \xc2\xa9 = 0 667 In Algorand\ s BA\xe2\x8b\x86 algorithm [4] the proposed value used in the consensus of each interim step is \xc2\xa9 = 0 685 and in the final step a stronger \xc2\xa9 = 0 74 is used We can now discuss conditions for consensus and also quantify the degree of reliability obtained by the network Byzantine consensus algorithms use \xc2\xa9\xc3\xb2 as the threshold for successful consensus Let \xc3\x86 be the proportion of honest nodes in the entire network and \xc3\x98 be the proportion of honest nodes in a shard Then to reach reliable consensus in a shard we require \xe2\x88\x9ec#LebJa#e 1 \xc3\x98\xc3\xba \xe2\x89\xa5 \xc2\xa9\xc3\xb2 that is the number of honest nodes is sufficient to reach consensus We also require that (1 \xe2\x88\x92 \xc3\x98)\xc3\xba < \xc2\xa9\xc3\xb2 \xe2\x80\xa0S\xc3\xb9 Since N is far larger than \xc3\xba Finally as N \xe2\x86\x92 \xe2\x88\x9e dependent on the desired shard size \xc3\xb2 irrelevant of the number of nodes in the whole network \xc3\x9c \xe2\x80\xa0 = \xc3\x9fa\xc3\xb2\xe2\x80\xa0\xe2\x86\x92\xc2\xae \xc2\xa21 \xe2\x88\x92 \xc2\xa3 = g S\xc3\x9c \xe2\x80\xa0 \xc3\xb2 \xc3\xb9 S\xc3\x9c g \xc3\xba that is the number of malicious nodes are too few to reach consensus Yet the above inequality assumes an immediately synchronized network When the network faces fluctuations or DDoS attacks some honest nodes may fail to produce signals in time Considering this let \xe2\x89\xa4 be the proportion of non responsive honest nodes which can also be interpreted as the degree to which the network is severed with \xe2\x89\xa4 = 0 implying a strongly synchronized network and \xe2\x89\xa4 = 1 implying complete network paralysis We now refine our second constraint to prevent nonresponsive nodes and malicious nodes from together causing the next block formation to fail \xe2\x88\x9ec#LebJa#e 2 (1 \xe2\x88\x92 \xc3\x98 + \xe2\x89\xa4\xc3\x98)\xc3\xba < \xc2\xa9\xc3\xb2 Since this value is independent of N a network with a sufficiently large node count has a shard structure only 3 \x0c(a) (b) (c) Fig 1 The relationship between the network bifurcation probability 1 \xe2\x88\x92 \xe2\x89\xa5(\xc3\xb2) and the number of nodes within the shard the horizontal variable is the number of in shard nodes \xc3\xb2 and the vertical variable is the logarithm of the bifurcation probability (a) When \xc3\x86 = 0 9 \xe2\x89\xa4 = 0 2 the effect on forking probabilities for the different algorithms under different shard sizes is shown (b) When \xe2\x89\xa4 = 0 2 the effect of the proportion of malicious nodes in the network under a BFT algorithm is shown (c) When \xe2\x89\xa4 = 0 2 the effect of the proportion of malicious nodes in the network under the BA * algorithm is shown In other words a trusted consensus shall simultaneously satisfy \xc3\x98\xc3\xba \xe2\x89\xa5 \xc2\xa9\xc3\xb2 \xc2\xb5 (1 \xe2\x88\x92 \xc3\x98 + \xe2\x89\xa4\xc3\x98)\xc3\xba < \xc2\xa9\xc3\xb2 Note that when we have \xc3\xba nodes in a shard the probability of having \xc3\x98\xc3\xba honest nodes and (1 \xe2\x88\x92 \xc3\x98)\xc3\xba malicious nodes which we define as @\xe2\x88\x82 \xc3\xb9 can be directly calculated from the probability \xc3\xb5m(\xc3\xb9 \xc3\x9c) above @\xe2\x88\x82 \xc3\xb9 = \xc3\xb5m(\xe2\x88\x82\xc3\xb9 \xe2\x88\x91\xc3\x9c) \xe2\x88\x99 \xc3\xb5m (_S\xe2\x88\x82)\xc3\xb9 (_S\xe2\x88\x91)\xc3\x9c> = (\xc3\x86\xc3\xb2)\xe2\x88\x82\xc3\xb9 S\xe2\x88\x91\xc3\x9c [(1 \xe2\x88\x92 \xc3\x86)\xc3\xb2](_S\xe2\x88\x82)\xc3\xb9 S(_S\xe2\x88\x91)\xc3\x9c \xe2\x88\x99g \xe2\x88\x99 \xe2\x88\x99g (\xc3\x98\xc3\xba) [(1 \xe2\x88\x92 \xc3\x98)\xc3\xba] This is simplified to @\xe2\x88\x82 \xc3\xb9 = (\xc3\x86\xc3\xb2)\xe2\x88\x82\xc3\xb9 [(1 \xe2\x88\x92 \xc3\x86)\xc3\xb2](_S\xe2\x88\x82)\xc3\xb9 S\xc3\x9c \xe2\x88\x99 \xe2\x88\x99g (\xc3\x98\xc3\xba) [(1 \xe2\x88\x92 \xc3\x98)\xc3\xba] Quantifying Reliability In a shard built with size \xc3\xb2 the reliability \xe2\x89\xa5(\xc3\xb2) of reaching a consensus can be expressed as follows \xe2\x89\xa5(\xc3\xb2) = [1 \xe2\x88\x92 Prob(constraint 1 fails)] \xe2\x88\x99 [1 \xe2\x88\x92 Prob(constraint 2 fails)] We expand out \xe2\x89\xa5(\xc3\xb2) = \xe2\x89\xa5(\xc3\xb2) = \xc2\xaa\xc3\x9c \xcf\x801 \xe2\x88\x92 \xe2\x88\xab \xe2\x88\x82\xc3\xb9\xc2\xba\xce\xa9 \xc2\xae \xc3\xb5m(\xe2\x88\x82\xc3\xb9 \xe2\x88\x91\xc3\x9c) \xc3\xa6 \xe2\x88\x99 \xc3\xb81 \xe2\x88\x92 \xe2\x88\xab \xc2\xae \xe2\x88\xab (_S\xe2\x88\x82)\xc3\xb9\xc2\xba\xce\xa9 \xe2\x88\x82\xc3\xb9\xc2\xba\xc2\xbf\xc3\xad\xc2\xa1\xc2\xac @\xe2\x88\x82 \xc3\xb9 \xe2\x89\x88 \xc3\xb9S\xc2\xaa\xc3\x9c \xce\xa9\xc6\x92 _S\xe2\x88\x9a which is integrated only in terms of \xc3\x98 and \xc3\xba as \xc3\x86 \xc2\xa9 \xe2\x89\xa4 are parameters taken as constants To solve for \xe2\x89\xa5(\xc3\xb2) note that \xc3\x98\xc3\xba (1 \xe2\x88\x92 \xc3\x98)\xc3\xba and \xc2\xa9\xc3\xb2 are all nonnegative integers and so the integrals in the above computation can be transformed into discrete summations Note that \xe2\x89\xa5(\xc3\xb2) is monotonic and thus invertible knowing \xe2\x89\xa5(\xc3\xb2) we can quickly calculate \xc3\xb2(\xe2\x89\xa5) and effectively estimate \xc3\xb2(\xe2\x89\xa5) through binary search As shown in Fig 1 when the node number increases continuously the log of the network bifurcation probability \xc3\x9fc\xe2\x88\x86_\xce\xa9 (1 \xe2\x88\x92 \xe2\x89\xa5(\xc3\xb2)) is almost linear showing that that reliability improves exponentially in \xc3\xb2 In an example use case suppose that the honest node proportion in the entire network is \xc3\x86 = 0 9 and we adopt a PBFT or asynchronous BFT consensus\xef\xbc\x88\xc2\xa9 = 0 667\xef\xbc\x89within the shard If we assume that the proportion of nodes failing to respond is \xe2\x89\xa4 = 0 2 we find that \xe2\x89\xa5(200) = 0 9998 and \xe2\x89\xa5(300) = 0 999995 For reference in a totally synchronized Bitcoin network with \xc3\x86 = 0 9 Bitcoin has a reliability value [1] of 0 99976 after six confirmation blocks slightly lower than \xe2\x89\xa5(200) under the above parameters Again suppose that the honest node proportion is \xc3\x86 = 0 9 and that we adopt the BA\xe2\x8b\x86 consensus (with a more powerful \xc2\xa9 = 0 74) within the shard maintaining the network severity parameter at \xe2\x89\xa4 = 0 2 We then obtain \xe2\x89\xa5(500) = 0 99994 BA\xe2\x8b\x86 can also operate at \xc2\xa9 = 0 685 which gives \xe2\x89\xa5(300) = 0 99998 and \xe2\x89\xa5(500) = 0 99999994 With this comparison we see that a PBFT or asynchronous BFT algorithm reaches higher reliability with fewer nodes at the cost of the higher communication cost of (\xc3\xb2 $ ) required for consensus 4 Transactions and Consensuses Using our reliability model to pick \xc3\xb2 and using VRF to generate shards with random nodes we can decompose the entire blockchain network into several shards with each transaction designated to a specific shard for execution However as with all sharding implementations it is challenging to design an appropriate mechanism to sync up all the shards\ decisions and realize inter shard coordination A sharding solution needs to comprehensively consider the questions of how a ledger should be generated from in shard transactions whether the consensus reached within a shard is adequately secure and how to handle transactions that straddle multiple shards Existing sharding technologies including Elastico[15] and Zilliqa[16] utilize a unified shared ledger These are able to handle transactions in a sharded network but incur a heavy cost to synchronize the shards throughout the network failing to optimally solve the sharding problem at its root On the other hand the Byzantine Shard Atomic Commit (Atomix) protocol designed by OmniLedger[17] conducts atomized processing on each transaction but uses logic that is complex and difficult to engineer MultiVAC\ s UTXO mechanism solves the synchronization problem Each transaction is distributed by the network into different shards according to its account number such that all the transactions of any given account are executed on the same shard As shown in Fig 2 in the UTXO transaction mechanism confirmation of the availability of funds is conducted only when funds are spent not when funds are received Each UTXO transaction takes one or more previously confirmed transactions as input and produces output that requires no processing by the recipient By using a UTXO mechanism and always processing a particular user account within the same shard we guarantee that the write operation is only performed on data within the same shard and that all cross shard data interactions in our system are read only thereby preventing complicated crossshard logic that inhibits other technologies\ effectiveness Our method is simple easy to implement and highly effective 4 \x0canalysis to include the case of smart contracts which is more complicated than the case of transactions Considering a series of computational tasks {\xce\x93\xc5\x93 } a = 0 1 2 3 \xe2\x80\xa6 such that the corresponding runtime cost for each task is |\xce\x93d | the required reliability level for each task is \xc2\xbbd the size of the shard that each task is executed on is \xc3\xb2d and the total communication cost \xe2\x80\xa6d \xe2\x88\x99 \xe2\x88\x86d then the sharding plan within the entire network shall optimize minimize e \xe2\x88\x9e \xe2\x88\x99 \xe2\x80\xa6(\xc3\xb2) \xe2\x88\x99 \xe2\x88\x86 \xc3\xbb \xc3\xbc + \xe2\x80\x94 \xc3\xb2d \xe2\x88\x99 |\xce\x93d | + \xe2\x80\xa6d (\xc3\xb2d ) \xe2\x88\x99 \xe2\x88\x86d (\xce\x93d )> \xe2\x88\x9e subject to \xe2\x89\xa5(\xc3\xb2) \xe2\x89\xa5 \xc2\xbb \xe2\x89\xa5(\xc3\xb2d ) \xe2\x89\xa5 \xc2\xbbd \xe2\x88\x9e \xe2\x88\x99 \xc3\xb2 + \xe2\x88\x91 \xc3\xb2d \xe2\x89\xa4 N There is no global polynomial time solution for the above optimization problem However we can derive a qualitative conclusion from intuition for a task with larger computational volume |\xce\x93\xc5\x93 | we would select a consensus algorithm with a higher communication cost but which uses fewer nodes within the shard to arrive at stronger consensus (i e asynchronous BFT) For a computation task with smaller computation volume |\xce\x93\xc5\x93 | we choose an in shard consensus mechanism with a lower communication cost such as BA\xe2\x8b\x86 In summary MultiVAC uses VRF to construct a probability model that splits user transactions and miner nodes into shards and then uses UTXO and the Byzantine consensus family to reach in shard consensus This completes the construction of our trusted sharding model Together with the basic principles of security and decentralization the trusted sharding model also has large scalability implications for public blockchains because it allows for blockchain throughput to increase without limit with the number of nodes For ordinary public chain transactions the consensus strength in a single MultiVAC shard is adequate to achieve a high level of reliability However for DApps and smart contracts it is quite wasteful to require each line of code to run on hundreds or thousands of different nodes Is there a method that can use even fewer or an optionally limited number of nodes and still achieve trustworthy smart contract executions in a decentralized trustless network On the basis of our VRF sharding mechanism we achieve this by creating a MVM virtual machine equipped with a custom BISC instruction set and PoIE consensus Fig 2 The UTXO model in MultiVAC The transactions are distributed into different shards for execution according to the payers\ addresses The inputs to UTXO are transactions that have already been confirmed on other shards so cross shard data interactions in our system are all read only operations There is a potential problem with the shard UTXO method attackers attempting to tamper with transactions or to perform double payment would only need to attack specific shards as opposed to the network as a whole This increases the chances of a successful attack A common method to prevent this is dynamic shard adjustment this is to keep the users (or miners) on the same shard and randomly move the miners (or users) to different shards in a continuous fashion In our implementation we choose to dynamically adjust the miners of a shard This makes attacks on any shard as difficult as attacking the network as a whole MultiVAC additionally makes attacks harder by selecting in node consensus algorithms that will not (or are very unlikely to) produce network forks such as PBFT asynchronous BFT or BA\xe2\x8b\x86 Erroneous blocks affected by malicious nodes would thus be left with a cryptographic trace In this light the PoW algorithm in Bitcoin is not applicable to in shard consensus because the weak computational power of any single shard compared to the entire network makes it easier for the attacker to occupy the majority of computational power in the shard and create a fork Consensus for Transactions Supposing the reliability requirement of each shard is \xc2\xbb then the shard size \xc3\xb2 must satisfy \xe2\x89\xa5(\xc3\xb2) \xe2\x89\xa5 \xc2\xbb 5 On VMs and Instruction Sets Virtual Machines provide an excellent sandbox environment for executing smart contracts For public chains that should be capable of general computation and unlimited scalability the design of the virtual machine\ s instruction set is of vital importance Mainstream virtual machines and instruction sets are rather unoptimized for complicated business logic in smart contracts We thus create our own specialized blockchain dedicated instruction set the BISC (Blockchain Instruction Set Computer) On this basis we create our generalpurpose virtual machine the MultiVAC Virtual Machine (MVM) Upon satisfying the reliability condition we also wish to keep the cost to reach consensus in the entire network as low as possible Suppose in every epoch the total transaction volume is e and the total number of shards is \xe2\x88\x9e and suppose further that the communication time complexity to reach consensus within a shard is the function \xe2\x80\xa6(\xc3\xb2) of \xc3\xb2 and the cost for a single communication is \xe2\x88\x86 e \xe2\x88\x9e> Then in terms of the average number of nodes in a shard we wish our sharding plan over the entire network to satisfy e minimize \xe2\x88\x9e \xe2\x88\x99 \xe2\x80\xa6(\xc3\xb2) \xe2\x88\x99 \xe2\x88\x86 \xc3\xbb \xc3\xbc \xe2\x88\x9e subject to \xe2\x89\xa5(\xc3\xb2) \xe2\x89\xa5 \xc2\xbb 5 1 Design Goals Virtual machines need not stay virtual In the long term a blockchain virtual machine may be implemented directly as a specialized hardware CPU This would make blockchain transactions faster and immensely more powerful For this to As \xe2\x89\xa5(\xc3\xb2) is monotonic the above optimization has a deterministic solution Consensus for Smart Contracts We now extend our above 5 \x0chappen the blockchain instruction set used in the virtual machine should be mature and efficient able to support complicated toplayer contract logic with a complicated and robust base layer architecture Based on this long term vision we design the MVM and the BISC instruction set with the following features 1 2 3 Instruction Computer G instructions Standard RISC V set contains the basic I instruction and four kinds of extension packs of MAFD Support for General Purpose Computation Blockchain VMs today are rather limited in handling complicated general purpose computation Future smart contracts and DApps require VMs to not only be Turing complete but also for their instruction sets to support more complicated logic Support for Compilation from Multiple High Level Languages MultiVAC is an open source ecosystem designed to be highly friendly to developers providing a robust compilation environment for many high level languages to support smooth migration of existing programs onto our platform Effective Use of Hardware Allowing for Implementation of our Instruction Set as a Hardware Computer Present day blockchain systems cause low level hardware to suffer a large loss in potential performance when compiling or interpreting VM bytecode MVM redesigns and upgrades a mature CPU instruction set holding the potential to one day be directly installed as a hardware computer This makes it possible for computers to naturally become MultiVAC nodes while still being computers used for desktop or mobile purposes and would allow for a seamless switch between personal computer and miner Table 1 BISC Instruction Pack Instruction Instruction Extension Description Pack I Basic access instructions computation and controlling operation of integers M Multiplication and instructions division operations of integers A Trans processor atom instructions manipulation instructions such as synchronous reading and writing etc F Single precision instructions floating number operation instructions D instructions L instructions B instructions Double precision floating number operation instructions Decimal integer operation instructions Bit manipulation instructions H instructions X instructions Signature and hash instructions Encryption and decryption instructions BISC Instructions RV32G RV64G BRV256I BRV256M BRV256A BRV256L BRV256B BRV256H BRV256X The BISC instruction set framework currently supports C compilation based on LLVM the GDB debugger and the glibc standard library LLVM (Low Level Virtual Machine) is a compiler framework whose purpose is to construct a compiletime link time and run time executor for any programming language The LLVM compilation framework with RISC V as the back end will eventually support high level languages such as Java and Go Its overall architecture is shown in Fig 3 5 2 The BISC Instruction Set The MVM uses a flexible and custom made instruction set BISC BISC is based on the outstanding reduced instruction set RISC V [22] which has a mature instruction architecture and an excellent open source compilation environment BISC customizes RISC V for blockchain by adding 256 bit instruction processing plus signature and hashing instructions for public blockchains The development of BISC will be in line with global open source principles BISC supports a complete and tidy set of instruction sequences as shown in Table 1 There are multiple sets of instructions named as follows Instructions labeled with prefix RV are from the standard extensions defined by RISC V while those labeled BRV are newly defined for BISC The numbers following RV and BRV refer to the instruction bitwidth and the suffix signifies the instruction\ s functions The suffix G is a joint label that covers RISC V\ s base pack I and the four standard extensions MAFD These instructions especially RV32G and RV64G have the strong support of the RISC V community Additional RISC V extensions have suffix L and B whereas instructions newly defined for BISC have suffix H and X Fig 3 LLVM compilation framework based on BISC 5 3 The MVM Virtual Machine The MVM Virtual Machine is a blockchain VM designed to support flexible computational models capable of providing an efficient and verifiable execution environment for smart contracts sourced from high level Turing Complete programming languages MVM provides applications with static code optimization storage allocation run time inspection and execution time verification To prevent infinite loop attacks MVM adopts gas charges similar to Ethereum for each BISC instruction executed Because each executed instruction in a smart contract incurs a charge smart contracts must be executed in the most computationally efficient way possible requiring code optimization To do this MVM will include for developers a targeted suggestion and optimization engine in its test environment that will provide breakdowns of executed instructions and their gas costs and it will also provide in the compilation environment suggestions for code optimization Other than completing execution in limited time smart 6 \x0ccontracts in our flexible computational system must also be verified by honest work The PoIE consensus algorithm directly embedded into the MVM platform achieves this performing computation gas charging and verification concurrently upon every executed instruction Note that gas charges will only be levied on smart contract execution steps and not on the computational steps required for the verification logic or for gas charging itself When an instruction sequence with sufficient gas is completed and verified the node will issue the computational results through the consensus mechanism and will receive a gas reward To facilitate processing MVM provides a BISC compatible memory model that isolates a computer\xe2\x80\x99s physical memory providing flexible run time support through our built in stack and heap space The stack space provides sufficient call depth to support various types of complicated data structures and may also provide batch IO stack operations The heap space is capable of being freely allocated and supports random addressing and also provides a monitoring mechanism to recover used resources in sum guaranteeing memory allocation for general purpose computation MVM can operate on all the network nodes allowing the nodes providing computational services to schedule tasks by adding them to their priority queues in order of their gas price and to execute them in order of priority 6 that malicious nodes must incur a high real world physical cost in order to defraud and that even if they defrauded they would be able to receive a reward but would still not be able to overturn the computation\ s verified correctness From the perspective of costs malicious nodes thus have a great incentive to honestly execute computational tasks The physical cost used by PoIE is as follows We treat a program to be executed as a base layer instruction sequence For modern computers the cost of executing this sequence is far less than the cost of storing this sequence in memory the physical constraint we use to ensure reliability In reality the processing speed of modern computers is often equal to that of their CPU cache and far greater than their read/write speed on memory Even though CPU cache can reach the same processing speed as the CPU itself even in high end CPUs (i e the Intel Core i7 series) the cache is only 8 12MB but consists of 1/4 to 1/3 of its computational costs (in terms of number of transistors) Many technologies in the world are designed from similar insights The physical foundations of PoIE have some similarity with Ethereum\ s mining mechanism ETHash ETHash was made to resist ASIC mining and avoid Bitcoin level miningpool centralization by requiring miners not only to perform hashing but also to randomly and frequently read large amounts of data from memory This memory read requirement creates a bottleneck for specialized ASIC miners preventing mining from becoming a highly specialized and centralized activity Similarly to ETHash PoIE uses the physical discrepancy between computation and storage in modern computers to penalize malicious behavior PoIE Consensus Existing sharding technologies such as those proposed by Ethereum [20] Zilliqa[16] and Elastico[15] require a large number of nodes per shard usually in the hundreds to low thousands DApps are composed of smart contracts on the public blockchain and requiring all DApp code to run on hundreds or thousands of nodes is clearly too expensive In a system of untrusted nodes such as the blockchain is there a way to execute the computation task on only a tiny number of nodes such that that the soundness of both the execution process and that of the obtained result are verifiable by the network as a whole 6 2 The PoIE algorithm PoIE is an instruction set based consensus embedded into the virtual machine Its design philosophy is to consider the program execution as a string of execution instructions PoIE can verify if this instruction sequence has been honestly executed in a network with untrustworthy nodes and can distribute appropriate economic rewards for honest execution 6 1 Theoretical and Realistic Basics for PoIE 6 2 1 Preliminaries First we define an anti collision hash function with safety parameter C (\xc3\xb7) \xe2\x84\x8eJL\xe2\x84\x8e {0 1}\xe2\x88\x97 \xe2\x86\x92 {0 1}\xe2\x80\x99 Proposed by researchers at Tel Aviv University and MIT zk SNARKs[14] can verify the execution of a program without first divulging the program\ s data via solving the program\ s zeroknowledge proofs zk SNARKs create concise non interactive zero knowledge proofs by flattening the program (a transaction or smart contract) into base expressions functioning much like logic gates in a circuit By encoding the program code into a circuit and providing a proof statement to the verifier zk SNARKs can verify non interactively whether or not a computation task has actually been executed One might design a shard based internal consensus algorithm based on zk SNARKs The benefit of this is that the number of nodes within a shard is very small but they can still reach a high degree of consensus one that is easily verifiable by the out of shard nodes This is a very important quality to have in an effective consensus system the nodes which did not participate in program execution can still verify that they were executed correctly However zk SNARKs suffer from extremely high time complexity For any program \xe2\x84\x99 and a time bound i the time complexity to execute zk SNARK verification is (|\xe2\x84\x99| \xe2\x88\x99 i) [9][10][14] and thus they are not practically applicable to public blockchain systems MultiVAC introduces a brand new consensus algorithm called PoIE (Proof of Instruction Execution) a proof on the base layer of instruction sequences zk SNARKs are purely mathematical algorithms for verification but PoIE is based on physical computational constraints The basic design principle is MultiVAC uses the Merkle Tree data structure to perform verification A Merkle Tree is a tree based data structure used for efficient verification of contents For a data set B = {Jd } a = 1 2 \xe2\x80\xa6 # we build a binary Merkle Tree on B denoted \xe2\x97\x8a(B 1 \xe2\x86\x92 #) as follows \xe2\x97\x8a(Jd ) = \xe2\x84\x8eJL\xe2\x84\x8e(0D00 \xe2\x88\xaa Jd ) \xe2\x97\x8a(B a \xe2\x86\x92 a + 1) = \xe2\x84\x8eJL\xe2\x84\x8e(0D01 \xe2\x88\xaa \xe2\x97\x8a(a) \xe2\x88\xaa \xe2\x97\x8a(a + 1)) \xc2\xa4\xe2\x80\xb9\xe2\x80\xba \xe2\x97\x8a(B 1 \xe2\x86\x92 #) = \xe2\x84\x8eJL\xe2\x84\x8e(0D01 \xe2\x88\xaa \xe2\x97\x8a B 1 \xe2\x86\x92 2\xc3\xbfs\xc3\x96\xc5\xb8\xe2\x81\x84 \xef\xac\x81 > \xc2\xa4\xe2\x80\xb9\xe2\x80\xba \xe2\x88\xaa \xe2\x97\x8a B 2\xc3\xbfs\xc3\x96\xc5\xb8\xe2\x81\x84 \xef\xac\x81 + 1 \xe2\x86\x92 #>) The classic application of Merkle Trees in blockchain are their uses in packaging transactions in Bitcoin as well as in the proof of replication in Filecoin PoIE requires a computationally complete hidden verification function Scalable Computational Integrity and Privacy (SCIP) [9][10][14] SCIP is a triad SCIP = (Setup Prove Verify) and is a process of zero knowledge verification that hides the execution proof of PoIE to prevent a third party from copying 7 \x0cthe instruction set sequence We expound on each of the individual functions below PoIE Generate({@A BA} B\xc3\x8a\xc3\x8a \xe2\x84\x99) \xe2\x86\x92 {Root \xc3\x9a(\xc3\x9b) Root \xc3\x9a(\xc3\x99) F\xc3\x8a\xc3\x8a } 6 2 2 Homomorphic Hiding For any program decomposed into an instruction set sequence \xce\x93 PoIE allows the instruction executor (Prover\xef\xbc\x8c\xe2\x80\x9e) to generate a proof F(\xce\x93) in linear (|\xce\x93|) time which enables the verifier (Verifier \xe2\x80\xb0 ) to verify in \xc3\x9fc\xe2\x88\x86(|\xce\x93|)> time that the instruction set sequence has been correctly executed To simplify our presentation we combine the output \xc3\x82 (if any) of the instruction set sequence into \xce\x93 so \xce\x93 considers both instruction set sequence and its result A node owns a public secret key pair {@A BA} in addition to another pair of public secret keys {@\xc3\x8a\xc3\x8a B\xc3\x8a\xc3\x8a } used to hide information First we conduct Homomorphic Hiding (HH) on the instruction set sequence of each executor a triad expanded below \xe2\x84\x99 is the program code to be executed PoIE Generate creates a Merkle Tree root node from the instruction sequence \xce\x93 and the hidden instruction sequence \xce\x9b generated by \xe2\x84\x99 \ s execution These operations are executed simultaneously in the CPU without recording \xce\x93 or \xce\x9b The pseudo code for PoIE Generate is below PoIE Generate INPUTS Key pair {@A BA} Hide key B\xc3\x8a\xc3\x8a Program \xe2\x84\x99 OUTPUTS Root of Merkle Tree Root \xc3\x9a(\xc3\x9b) Root of Merkle Tree Root \xc3\x9a(\xc3\x99) Prove F\xc3\x8a\xc3\x8a PROCEDURE \xce\x93 \xe2\x86\x90 Run \xe2\x84\x99 \xe2\x97\x8a(\xce\x93) \xe2\x86\x90 Merkle Tree of \xce\x93 Synchronized \xc4\xb1{\xce\x9b F\xc3\x8a\xc3\x8a } \xe2\x86\x90 HH Generate({@A BA} B\xc3\x8a\xc3\x8a \xce\x93) \xe2\x97\x8a(\xce\x9b) \xe2\x86\x90 Merkle Tree of \xce\x9b Set Root \xc3\x9a(\xc3\x9b) \xe2\x86\x90 Root of \xe2\x97\x8a(\xce\x93) Set Root \xc3\x9a(\xc3\x99) \xe2\x86\x90 Root of \xe2\x97\x8a(\xce\x9b) Output Root \xc3\x9a(\xc3\x9b) Root \xc3\x9a(\xc3\x99) F\xc3\x8a\xc3\x8a HH = (Generate Prove Verify) We describe each operation in HH as follows HH Generate({@A BA} B\xc3\x8a\xc3\x8a \xce\x93) \xe2\x86\x92 {\xce\x9b F\xc3\x8a\xc3\x8a } HH Generate generates a hidden version \xce\x9b of the instruction set \xce\x93 and a proof F\xc3\x8a\xc3\x8a provided to the executor \xe2\x80\x9e to generate a proof about \xce\x9b and \xce\x93 \xce\x9b and \xce\x93 need to be doubly generated below in section 6 2 3 The pseudo code for HH Generate is below HH Generate INPUTS Key pair {@A BA} Hide key B\xc3\x8a\xc3\x8a Instruction list \xce\x93 OUTPUTS Encrypted Instruction List \xce\x9b Prove F\xc3\x8a\xc3\x8a PROCEDURE Compute \xce\x9b \xe2\x86\x90 \xc3\x88#\xe2\x88\x9eb\xc3\x8d\xc3\xb5e(\xce\x93 BA) Set D\xe2\x83\x97 \xe2\x86\x90 {@A \xce\x9b} Set \xc3\x8f \xc3\x8c\xc3\x8c\xe2\x83\x97 \xe2\x86\x90 {BA \xce\x93} Compute F\xc3\x8a\xc3\x8a \xe2\x86\x90 SCIP Prove(B\xc3\x8a\xc3\x8a D\xe2\x83\x97 \xc3\x8f \xc3\x8c\xc3\x8c\xe2\x83\x97) Output \xce\x9b F\xc3\x8a\xc3\x8a PoIE Prove defines an interactive process requiring a twophase commit protocol meaning that another execution of \xe2\x84\x99 is performed that generates a new \xe2\x97\x8a(\xce\x9b) constructing proof for the challenge \xc3\x93 given by the verifier up until the point where all challenges have been queried \xc3\x99(\xcb\x99) PoIE Prove({@A BA} B\xc3\x8a\xc3\x8a \xe2\x84\x99 \xce\xb5) \xe2\x86\x92 {F\xc3\x9b\xc3\x92 F\xc3\x99\xc3\x92 F\xc3\x94\xe2\x80\x99w\xef\xa3\xbf \xce\x9b(\xce\xb5)} The pseudo code of PoIE Prove is below PoIE Prove INPUTS Key pair {@A BA} Hide key B\xc3\x8a\xc3\x8a Program \xe2\x84\x99 Challenge \xce\xb5 OUTPUTS \xc3\x99(\xcb\x99) Prove \xcf\x80(\xce\x93) = {F\xc3\x9b\xc3\x92 F\xc3\x99\xc3\x92 F\xc3\x94\xe2\x80\x99w\xef\xa3\xbf \xce\x9b(\xce\xb5)} PROCEDURE Observe that encryption of \xce\x9b requires only verification and not reverse decryption Thus we may use easily computable oneway encryptions instead of high cost encryptions such as elliptic curves or RSA \xc3\x92 HH Prove(B\xc3\x8a\xc3\x8a \xce\x9b \xc3\x93) \xe2\x86\x92 F\xc3\x94\xe2\x80\x99w\xef\xa3\xbf \xce\x93 \xe2\x86\x90 Run \xe2\x84\x99 until \xce\xb5 is finished \xe2\x8e\xa7 M(\xce\x93) \xe2\x86\x90 Merkle Tree of \xce\x93 \xe2\x8e\xaa \xe2\x8e\xaa{\xce\x9b F\xc3\x8a\xc3\x8a } \xe2\x86\x90 HH Generate({@A BA} B\xc3\x8a\xc3\x8a \xce\x93) M(\xce\x9b) \xe2\x86\x90 Merkle Tree of \xce\x9b Synchronized \xe2\x8e\xa8 @ath\xcb\x99 \xc3\x9b \xe2\x86\x90 Merkle path of \xce\x93(\xce\xb5) in M(\xce\x93) \xe2\x8e\xaa @ath\xcb\x99 \xc3\x99 \xe2\x86\x90 Merkle path of \xce\x9b(\xce\xb5)in M(\xce\x9b) \xe2\x8e\xaa \xc3\x99(\xcb\x99) F\xc3\x94\xe2\x80\x99w\xef\xa3\xbf \xe2\x86\x90 HH Prove(B\xc3\x8a\xc3\x8a \xce\x9b(\xce\xb5) \xce\xb5) \xe2\x8e\xa9 Using \xce\x9b HH Prove generates for the executor \xe2\x80\x9e a proof corresponding to the challenge \xc3\x93 proposed by the verifier \xe2\x80\xb0 \xc3\x92 ) \xe2\x86\x92 (true|false) HH Verify(@A @\xc3\x8a\xc3\x8a \xce\x9b F\xc3\x8a\xc3\x8a \xc3\x93 F\xc3\x94\xe2\x80\x99w\xef\xa3\xbf HH Verify is used by the verifier \xe2\x80\xb0 to check the authenticity \xc3\x92 of F\xc3\x94\xe2\x80\x99w\xef\xa3\xbf HH Prove and HH Verify are both generated using SCIP Set D\xe2\x83\x97\xc3\x9b \xe2\x86\x90 #Root\xc3\x9a(\xc3\x9b) \xce\xb5$ Set \xc3\x8c\xc3\x8c\xc3\x8c\xc3\x8c\xc3\x8c\xe2\x83\x97 \xc3\x8f\xc3\x9b \xe2\x86\x90 {@ath\xcb\x99 \xc3\x9b \xce\x93(\xce\xb5)} Compute F\xc3\x9b\xc3\x92 \xe2\x86\x90 SCIP Prove(B\xc3\x8a\xc3\x8a D\xe2\x83\x97\xc3\x9b \xc3\x8c\xc3\x8c\xc3\x8c\xc3\x8c\xc3\x8c\xe2\x83\x97) \xc3\x8f\xc3\x9b Set D\xe2\x83\x97\xc3\x99 \xe2\x86\x90 #Root \xc3\x9a(\xc3\x99) \xce\xb5$ Set \xc3\x8c\xc3\x8c\xc3\x8c\xc3\x8c\xc3\x8c\xe2\x83\x97 \xc3\x8f\xc3\x99 \xe2\x86\x90 {@ath\xcb\x99 \xc3\x99 \xce\x9b(\xce\xb5)} Compute F\xc3\x99\xc3\x92 \xe2\x86\x90 SCIP Prove(B\xc3\x8a\xc3\x8a D\xe2\x83\x97\xc3\x99 \xc3\x8c\xc3\x8c\xc3\x8c\xc3\x8c\xc3\x8c\xe2\x83\x97) \xc3\x8f\xc3\x99 \xc3\x99(\xcb\x99) Output F\xc3\x9b\xc3\x92 F\xc3\x99\xc3\x92 F\xc3\x94\xe2\x80\x99w\xef\xa3\xbf \xce\x9b(\xce\xb5) 6 2 3 The Main Algorithm Now we present the full PoIE algorithm This is also a triad PoIE = (Generate Prove Verify) 8 \x0cFinally the verifier \xe2\x80\xb0 verifies the computation given its input using PoIE Verify PoIE Verify \xc2\xa2@A @\xc3\x8a\xc3\x8a Root\xc3\x9a(\xc3\x9b) Root\xc3\x9a(\xc3\x99) F\xc3\x8a\xc3\x8a \xce\xb5 \xcf\x80(\xce\x93)\xc2\xa3 \xe2\x86\x92 (ebfg|\xe2\x80\xa6J\xc3\x9fLg) system resources to reach the reliability requirements Therefore the decision +(\xc3\xb2 \xe2\x8a\x9b) made may be expressed as arg min +(\xc3\xb2 \xe2\x8a\x9b) = \xe2\x88\x99 [\xe2\x80\xa6 \xe2\x8a\x9b (\xc3\xb2) \xe2\x88\x99 \xe2\x88\x86(\xce\x93) + \xc3\xb2 \xe2\x88\x99 |\xce\x93|] + \xe2\x88\x99 \xe2\x84\x8e\xe2\x8a\x9b (\xc3\xb2) \xe2\x88\x99 g \xe2\x8a\x9b (|\xce\x93|) subject to \xe2\x89\xa5(\xc3\xb2) \xe2\x89\xa5 \xc2\xbb w r t \xc2\xa9\xe2\x8a\x9b The pseudo code for PoIE Verify is below PoIE Verify INPUTS Public Key of Prover @A Public Key of HH @\xc3\x8a\xc3\x8a Root of Merkle Tree Root \xc3\x9a(\xc3\x9b) Root of Merkle Tree Root \xc3\x9a(\xc3\x99) Prove F\xc3\x8a\xc3\x8a Challenge \xce\xb5 \xc3\x99(\xcb\x99) Prove \xcf\x80(\xce\x93) = {F\xc3\x9b\xc3\x92 F\xc3\x99\xc3\x92 F\xc3\x94\xe2\x80\x99w\xef\xa3\xbf \xce\x9b(\xce\xb5)} OUTPUTS True or false PROCEDURE Set D\xe2\x83\x97_ \xe2\x86\x90 {Root \xc3\x9a(\xc3\x9b) \xce\xb5} Compute %_ \xe2\x86\x90 SCIP Verify(@\xc3\x8a\xc3\x8a D\xe2\x83\x97_ F\xc3\x9b\xc3\x92 ) Set D\xe2\x83\x97$ \xe2\x86\x90 {Root\xc3\x9a(\xc3\x99) \xce\xb5} Compute %$ \xe2\x86\x90 SCIP Verify(@\xc3\x8a\xc3\x8a D\xe2\x83\x97$ F\xc3\x99\xc3\x92 ) \xc3\x99(\xcb\x99) Compute %& \xe2\x86\x90 HH Verify \xc2\xa2@A @\xc3\x8a\xc3\x8a \xce\x9b(\xce\xb5) F\xc3\x8a\xc3\x8a \xc3\x93 F\xc3\x94\xe2\x80\x99w\xef\xa3\xbf \xc2\xa3 Output %_ \xe2\x88\xa7 %$ \xe2\x88\xa7 %& where and are weight parameters The task submitter would prefer to set = 0 ignoring the needs of the system in order to maximize his or her self interest Because of this the final decision making power of +(\xc3\xb2 \xe2\x8a\x9b) remains with the MultiVAC public blockchain The user will be able to request a reliability level and some economic considerations but the final selection of shard size \xc3\xb2 and consensus algorithm \xe2\x8a\x9b are still decided by the MultiVAC program 7 Storage Transmission Computation and It must be noted that computers do not only compute they also store and transmit data A robust public blockchain system should be able to achieve the three desiderata of security scalability and decentralization not only for computation but also for storage and transmission This in turn requires welldesigned incentive mechanisms to encourage nodes to contribute resources for all three MultiVAC is the first scalable public blockchain that designs for all three of dimensions of blockchain robustness (computation storage and transmission) This allows for an interactive verification process executed on the instruction set sequence Since the cost of executing instructions is much lower than that of storing them in memory an attacker will incur a high cost if they chose to store or copy \xce\x93 to construct \xce\x9b This makes it not cost effective to launch an attack It also goes without saying that the cost of storing and constructing \xe2\x97\x8a(\xce\x93) and \xe2\x97\x8a(\xce\x9b) in memory is also extremely high 7 1 Computation We have already discussed computation in the above sections MultiVAC is the first system to provide a flexible sharding solution for blockchain computation using PoIE to verify the correctness of each computation PoIE provides both the actual sequence of executed instructions \xce\x93 as well as the instruction sequence after the homomorphic hide \xce\x9b Based on the execution status inferred by \xce\x9b we can easily design a reward system similar to the gas incentive of Ethereum Its reward function is 6 3 Flexible Sharding Computation Requirements of consistency availability and partition tolerance are difficult to equally satisfy in the design of any distributed system Different contracts and DApps have different levels of requirements for these properties but almost all public blockchains have a fixed compromise between them MultiVAC is unique among public blockchains in that its flexible computation model provides infrastructure guaranteeing that DApp designers have space to decide on their own the tradeoff between decentralization scalability and security Given the VRF sharding process and the PoIE task verification process MultiVAC allows the users who submitted tasks to select a required reliability level based on actual business demand and based on this to select a shard size and corresponding consensus mechanism For a computation task \xce\x93 MultiVAC allows the task submitter to choose to run their task inside of a shard with a certain size in order to reach the reliability requirement \xc2\xbb We define the communication complexity to reach consensus within the shard in terms of shard size \xc3\xb2 as a function \xe2\x80\xa6(\xc3\xb2) Also we define the cost of a single communication as a function of the proof \xe2\x88\x86(\xce\x93) Note that \xe2\x88\x86(\xce\x93) is the data volume that the PoIE algorithm needs to interact with and has complexity (\xc3\x9fc\xe2\x88\x86|\xce\x93|) \xe2\x80\xa6(\xe2\x88\x97) is fixed by the consensus type chosen (i e asynchronous BFT or BA\xe2\x8b\x86) so given a consensus algorithm \xe2\x8a\x9b we denote the consensus specific communication complexity as \xe2\x80\xa6 \xe2\x8a\x9b (\xe2\x88\x97) We also denote the reward that miners are able to receive as g \xe2\x8a\x9b (|*|) and the node count involved in distributing the reward as \xe2\x84\x8e\xe2\x8a\x9b (\xc3\xb2) The submitter of the computation task aims to achieve a desired reliability level at the minimum possible cost MultiVAC\ s public blockchain aims at using minimum possible zg\xc3\x8fJb0d (\xce\x9bd PoIE Verify) = \xc2\xb5 |\xce\x9bd | PoIE Verify \xe2\x86\x92 true \xe2\x88\x85 PoIE Verify \xe2\x86\x92 false 7 2 Storage MultiVAC is equipped with high performance transaction processing that improves with the number of nodes in the network If the average realized throughout of a public blockchain is >1 000 tps and the average transaction size is 0 4KB the blockchain ledger will have an annual file size of over 10TB Clearly normal PCs are unable to store such large ledgers and so we either require the usage of supernodes or shard storage There are many distributed storage projects such as Storj[25]\xef\xbc\x8cMaidSafe[27] and Siacoin[26] and Filecoin[24] Filecoin[24] takes IPFS[23] as its base mechanism which is a complete decentralized and distributed storage system with an addressable versioned and peer to peer file system Some wellknown blockchains including EOS also adopt IPFS Slightly different from IPFS which is based on Hash addressing MultiVAC also uses a storage and search mechanism based on Merkle Roots Merkel Roots have many benefits They not only enable us to search and retrieve data they have the additional capability of allowing us to search and retrieve only a small chunk of the data while still obtaining 9 \x0cverification of the full data\ s existence and authenticity MultiVAC supports file storage and retrieval based on both Hash and Merkle Roots In addition MultiVAC also includes a VRF sharded storage mechanism which is a distributed and decentralized storage system Similar to Bitcoin light nodes the MultiVAC nodes only store block header information maintaining the full transaction input and output in distributed storage It is important to note that in MultiVAC the data storage mechanism is only used as an internal base layer service for the system so that the storage mechanism is unable to edit the data All the rules for data generation modification deletion as well as verification and consensus are delegated to the platform\ s higher level functions The only thing that the base layer does is to store and retrieve data for the higher levels MultiVAC will provide a reward for nodes performing both storage and computational services 7 2 Transmission Finally a blockchain network also must consider data transmission issues Systems utilizing a sharded storage ledger reduce their storage costs in exchange for increased transmission costs though this issue may be relieved somewhat as IPFS has proven that the usage of a distributed storage also brings with it distributed transmission capability which may reduce bandwidth pressures on centralized nodes Suppose in a blockchain a node processes e transactions before forming a block If the entire network stores the ledger then there will be a disc IO time cost of (e) and a network syncing cost of (e) If we use shard storage there will be no disc IO time cost a network syncing cost of (e) and an additional network communication cost for verification of (e) As the transaction process likely takes place over a fragmented network instead of a synchronized network the time cost of syncing will actually be in practice somewhat higher than that of the local disc IO however in principle sharding the ledger\ s storage does not increase the time complexity of the transmission Discovering appropriate incentive mechanisms for data transmission remains an open question in academia and industry and no fully effective solutions have been presented as of date Even in the mechanisms of IPFS and filecoin where storage nodes may receive rewards through two mechanisms PoRep and PoST the storage nodes may still refuse to transmit data when other nodes require it due to reasons such as bandwidth cost In addition data transmission may be so frequent such that it is impossible to generate a corresponding reward transaction for each data request because the reward transaction itself will result in its own data transmission costs leading to an infinite recursion A well designed incentive mechanism for data transmission would take into consideration issues such as bandwidth latency transition volume and request frequency and these many variables cause the data transmission reward question to remain an unsolved problem in the near term However this mechanism is not an urgent objective as data transmission is never decoupled from the operations of storage and computation which each already have their own incentive mechanisms In summary MultiVAC comprehensively considers the three dimensions of computation storage and transmission in modern blockchains and we design an incentive mechanism for computation and storage We are the first scalable public blockchain that designs for all three dimensions 8 Conclusions MultiVAC designs a high performance public blockchain where nodes are randomly sharded based on VRF and where reliability is guaranteed with a probability model Unlike all public blockchains available today our flexible platform provides users of smart contracts the ability to self select the balance between security decentralization and scalability Unlike Bitcoin or Ethereum the processing capacity of the MultiVAC network will be continuously increased as number of nodes increases and as the total computational power of the network expands making the blockchain infinitely scalable and capable of being used in a myriad of business and industrial applications In terms of business support our distributed computation platform provides a revolutionary breakthrough in the blockchain industry with our novel BISC instruction set our MVM virtual machine and our PoIE consensus and this allows our platform to be able to supply an ever increasable level of resources to distributed applications (A Final Sidenote The name MultiVAC is derived from the name of the supercomputer in Isaac Asimov\xe2\x80\x99s The Last Question MultiVAC evolved from our present day transistor based computers into an entity existing in hyperspace beyond gravity or time having merged with all the human souls in the universe In the last days of the universe MultiVAC finally discovers the answer to the question How can the net amount of entropy of the universe be massively decreased and thus makes the pronouncement Let there be light ) References [1] Satoshi Nakamoto Bitcoin A Peer to Peer Electronic Cash System October 31 2008 [2] M Castro B Liskov Practical Byzantine fault tolerance Symposium on Operating Systems Design & Implementation 1999 20 (4) 173 186 [3] S Micali M O Rabin and S P Vadhan Verifiable random functions In Proceedings of the 40th Annual IEEE Symposium on Foundations of Computer Science (FOCS) New York NY Oct 1999 [4] Yossi Gilad Rotem Hemo Silvio Micali Georgios Vlachos Nickolai Zeldovich Algorand Scaling Byzantine Agreements for Cryptocurrencies MIT CSAIL Arxiv 1607 01341 [5] D Boneh B Lynn and H Shacham Short Signatures from the Weil Pairing In Proceedings of the 7th International Conference on the Theory and Application of Cryptology and Information Security Advances in Cryptology ASIACRYPT \xe2\x80\x9901 pages 514\xe2\x80\x93532 London UK 2001 Springer Verlag [6] B David P Gazi A Kiayias and A Russell Ouroboros Praos An Adaptively Secure Semisynchronous Proof of Stake Blockchain International Conference on the Theory & Applications of Cryptographic Techniques 2018 6698 [7] Global Bitcoin Nodes Distribution website https //bitnodes earn com/ [8] Ether Nodes Network Number website https //www ethernodes org/network/1 [9] Rosario Gennaro Craig Gentry Bryan Parno and Mariana Raykova Quadratic span programs and succinct nizks without pcps In Annual International Conference on the Theory and Applications of Cryptographic Techniques pages 626\xe2\x80\x93645 Springer 2013 [10] Nir Bitansky Alessandro Chiesa and Yuval Ishai 10 \x0c[11] [12] [13] [14] [15] [16] [17] [18] [19] [20] [21] [22] [23] [24] [25] [26] [27] [28] [29] Succinct non interactive arguments via linear interactive proofs Springer 2013 Vitalik Buterin A Next Generation Smart Contract and Decentralized Application Platform 2013 Dr Gavin Wood Ethereum A Secure Decentrailised Generalised Trasactioin Ledger The Block One EOS IO Technical White Paper March 2018 Eli Ben Sasson Alessandro Chiesa Daniel Genkin Eran Tromer and Madars Virza Snarks for c Verifying program executions succinctly and in zero knowledge In Advances in Cryptology\xe2\x80\x93CRYPTO 2013 pages 90\xe2\x80\x93108 Springer 2013 L Luu V Narayanan C Zheng K Baweja and S Gilbert A Secure Sharding Protocol For Open Blockchains Acm Sigsac Conference on Computer & Communications Security 2016 17 30 The Zilliqa Team The ZILLIQA Technical Whitepaper 2017 Eleftherios Kokoris Kogias Philipp Jovanovic Linus Gasser Nicolas Gailly Ewa Syta Bryan Ford OmniLedger A Secure Scale Out Decentralized Ledger via Sharding 2017 The Seele Team Seele Tech Whitepaper Innovate New Era of Value Internet 2018 Timo Hanke Mahnush Movahedi and Dominic Williams DFINITY Technology Overview Series Consensus System Jan 2018 Vitalik Buterin Ethereum 2 0 Mauve Paper 2016 Diego Ongaro and John Ousterhout In Search of an Understandable Consensus Algorithm 2014 USENIX Annual Technical Conference June 2014 305 219 Andrew Waterman Krste Asanovie The RISC V Instruction Set Manual May 7 2017 Juan Benet IPFS Content Addressed Versioned P2P File System 2014 The Filecoin Team Filecoin A Cryptocurrency Operated File Storage Network July 2014 Shawn Wilkinson Tome Boshevski Josh Brandoff James Prestwich Gordon Hall Patrick Gerbes Philip Hutchins and Chris Pollard Storj A Peer to Peer Cloud Storage Network Dec 2016 David Vorick and Luke Champine Sia Simple Decentralized Storage Nov 2014 The Maidsafe Team A Safe Network Premier An Introductory Guide\xe2\x80\x99s to the World\xe2\x80\x99s First Fully Autonomous Data Network Feb 2018 Joseph Poon and Vitalik Buterin Plasma Scalable Autonomous Smart Contracts August 2017 Isaac Asimov The Last Question Science Fiction Quarterly Nov 1956 11 \x0c 