CryptoNote 
 v 
 2 0 
 
 
 Nicolas 
 van 
 Saberhagen 
 October 
 17 
 2013 
 
 
 1 
 Introduction 
 
 
 \Bitcoin 
 [1] 
 has 
 been 
 a 
 successful 
 implementation 
 of 
 the 
 concept 
 of 
 p2p 
 electronic 
 cash 
 Both 
 professionals 
 and 
 the 
 general 
 public 
 have 
 come 
 to 
 appreciate 
 the 
 convenient 
 combination 
 of 
 public 
 transactions 
 and 
 proof of work 
 as 
 a 
 trust 
 model 
 Today 
 the 
 user 
 base 
 of 
 electronic 
 cash 
 is 
 growing 
 at 
 a 
 steady 
 pace 
 customers 
 are 
 attracted 
 to 
 low 
 fees 
 and 
 the 
 anonymity 
 provided 
 by 
 electronic 
 cash 
 and 
 merchants 
 value 
 its 
 predicted 
 and 
 decentralized 
 emission 
 Bitcoin 
 has 
 eectively 
 proved 
 that 
 electronic 
 cash 
 can 
 be 
 as 
 simple 
 as 
 paper 
 money 
 and 
 as 
 convenient 
 as 
 credit 
 cards 
 
 
 Unfortunately 
 Bitcoin 
 suers 
 from 
 several 
 deciencies 
 For 
 example 
 the 
 system s 
 distributed 
 nature 
 is 
 in
 exible 
 preventing 
 the 
 implementation 
 of 
 new 
 features 
 until 
 almost 
 all 
 of 
 the 
 networ
 k 
 users 
 update 
 their 
 clients 
 Some 
 critical 
 
 aws 
 that 
 cannot 
 be 
 xed 
 rapidly 
 deter 
 Bitcoin s 
 widespread 
 propagation 
 In 
 such 
 in
 exible 
 models 
 it 
 is 
 more 
 ecient 
 to 
 roll out 
 a 
 new 
 project 
 rather 
 than 
 perpetually 
 x 
 the 
 original 
 project 
 
 
 In 
 this 
 paper 
 we 
 study 
 and 
 propose 
 solutions 
 to 
 the 
 main 
 deciencies 
 of 
 Bitcoin 
 We 
 believe 
 that 
 a 
 system 
 taking 
 into 
 account 
 the 
 solutions 
 we 
 propose 
 will 
 lead 
 to 
 a 
 healthy 
 competition 
 among 
 dierent 
 electronic 
 cash 
 systems 
 We 
 also 
 propose 
 our 
 own 
 electronic 
 cash 
 \CryptoNote 
 a 
 name 
 emphasizing 
 the 
 next 
 breakthrough 
 in 
 electronic 
 cash 
 
 
 2 
 Bitcoin 
 drawbacks 
 and 
 some 
 possible 
 solutions 
 
 
 2 1 
 Traceability 
 of 
 transactions 
 Privacy 
 and 
 anonymity 
 are 
 the 
 most 
 important 
 aspects 
 of 
 electronic 
 cash 
 Peer to peer 
 payments 
 seek 
 to 
 be 
 concealed 
 from 
 third 
 party s 
 view 
 a 
 distinct 
 dierence 
 when 
 compared 
 with 
 traditional 
 banking 
 In 
 particular 
 T 
 Okamoto 
 and 
 K 
 Ohta 
 described 
 six 
 criteria 
 of 
 ideal 
 electronic 
 cash 
 which 
 included 
 \privacy 
 relationship 
 between 
 the 
 user 
 and 
 his 
 purchases 
 must 
 be 
 untraceable 
 by 
 anyone 
 [30] 
 From 
 their 
 description 
 we 
 derived 
 two 
 properties 
 which 
 a 
 fully 
 anonymous 
 electronic 
 cash 
 model 
 must 
 satisfy 
 in 
 order 
 to 
 comply 
 with 
 the 
 requirements 
 outlined 
 by 
 Okamoto 
 and 
 Ohta 
 
 
 Untraceability 
 for 
 each 
 incoming 
 transaction 
 all 
 possible 
 senders 
 are 
 equiprobable 
 
 
 Unlinkability 
 for 
 any 
 two 
 outgoing 
 transactions 
 it 
 is 
 impossible 
 to 
 prove 
 they 
 were 
 sent 
 to 
 the 
 same 
 person 
 
 
 Unfortunately 
 Bitcoin 
 does 
 not 
 satisfy 
 the 
 untraceability 
 requirement 
 Since 
 all 
 the 
 transaction
 s 
 that 
 take 
 place 
 between 
 the 
 network s 
 participants 
 are 
 public 
 any 
 transaction 
 can 
 be 
 
 
 1 
 
 
 
 unambiguously 
 traced 
 to 
 a 
 unique 
 origin 
 and 
 nal 
 recipient 
 Even 
 if 
 two 
 participants 
 exchange 
 funds 
 in 
 an 
 indirect 
 way 
 a 
 properly 
 engineered 
 path nding 
 method 
 will 
 reveal 
 the 
 origin 
 and 
 nal 
 recipient 
 
 
 It 
 is 
 also 
 suspected 
 that 
 Bitcoin 
 does 
 not 
 satisfy 
 the 
 second 
 property 
 Some 
 researchers 
 stated 
 ([33 
 35 
 29 
 31]) 
 that 
 a 
 careful 
 blockchain 
 analysis 
 may 
 reveal 
 a 
 connection 
 between 
 the 
 users 
 of 
 the 
 Bitcoin 
 network 
 and 
 their 
 transactions 
 Although 
 a 
 number 
 of 
 methods 
 are 
 disputed 
 [25] 
 it 
 is 
 suspected 
 that 
 a 
 lot 
 of 
 hidden 
 personal 
 information 
 can 
 be 
 extracted 
 from 
 the 
 public 
 database 
 
 
 Bitcoin s 
 failure 
 to 
 satisfy 
 the 
 two 
 properties 
 outlined 
 above 
 leads 
 us 
 to 
 conclude 
 that 
 it 
 is 
 not 
 an 
 anonymous 
 but 
 a 
 pseudo anonymous 
 electronic 
 cash 
 system 
 Users 
 were 
 quick 
 to 
 develop 
 solutions 
 to 
 circumvent 
 this 
 shortcoming 
 Two 
 direct 
 solutions 
 were 
 \laundering 
 services 
 [2] 
 and 
 the 
 development 
 of 
 distributed 
 methods 
 [3 
 4] 
 Both 
 solutions 
 are 
 based 
 on 
 the 
 idea 
 of 
 mixing 
 several 
 public 
 transactions 
 and 
 sending 
 them 
 through 
 some 
 intermediary 
 address 
 which 
 in 
 turn 
 suers 
 the 
 drawback 
 of 
 requiring 
 a 
 trusted 
 third 
 party 
 
 
 Recently 
 a 
 more 
 creative 
 scheme 
 was 
 proposed 
 by 
 I 
 Miers 
 et 
 al 
 [28] 
 \Zerocoin 
 Zerocoin 
 utilizes 
 a 
 cryptographic 
 one way 
 accumulators 
 and 
 zero knoweldge 
 proofs 
 which 
 permit 
 users 
 to 
 \convert 
 bitcoins 
 to 
 zerocoins 
 and 
 spend 
 them 
 using 
 anonymous 
 proof 
 of 
 ownership 
 instead 
 of 
 explicit 
 public key 
 based 
 digital 
 signatures 
 However 
 such 
 knowledge 
 proofs 
 have 
 a 
 constant 
 but 
 inconvenient 
 size 
 about 
 30kb 
 (based 
 on 
 today s 
 Bitcoin 
 limits) 
 which 
 makes 
 the 
 proposal 
 impractical 
 Authors 
 admit 
 that 
 the 
 protocol 
 is 
 unlikely 
 to 
 ever 
 be 
 accepted 
 by 
 the 
 majority 
 of 
 Bitcoin 
 users 
 [5] 
 
 
 2 2 
 The 
 proof of work 
 function 
 Bitcoin 
 creator 
 Satoshi 
 Nakamoto 
 described 
 the 
 majority 
 decision 
 making 
 algorithm 
 as 
 \oneCPU one vote
 
 and 
 used 
 a 
 CPU bound 
 pricing 
 function 
 (double 
 SHA 256) 
 for 
 his 
 proof of work 
 scheme 
 Since 
 users 
 vote 
 for 
 the 
 single 
 history 
 of 
 transactions 
 order 
 [1] 
 the 
 reasonableness 
 and 
 consistency 
 of 
 this 
 process 
 are 
 critical 
 conditions 
 for 
 the 
 whole 
 system 
 
 
 The 
 security 
 of 
 this 
 model 
 suers 
 from 
 two 
 drawbacks 
 First 
 it 
 requires 
 51% 
 of 
 the 
 network s 
 mining 
 power 
 to 
 be 
 under 
 the 
 control 
 of 
 honest 
 users 
 Secondly 
 the 
 system s 
 progress 
 (bug 
 xes 
 security 
 xes 
 etc ) 
 require 
 the 
 overwhelming 
 majority 
 of 
 users 
 to 
 support 
 and 
 agree 
 to 
 the 
 changes 
 (this 
 occurs 
 when 
 the 
 users 
 update 
 their 
 wallet 
 software) 
 [6] Finally 
 this 
 same 
 voting 
 mechanism 
 is 
 also 
 used 
 for 
 collective 
 polls 
 about 
 implementation 
 of 
 some 
 features 
 [7] 
 
 
 This 
 permits 
 us 
 to 
 conjecture 
 the 
 properties 
 that 
 must 
 be 
 satised 
 by 
 the 
 proof of work 
 pricing 
 function 
 Such 
 function 
 must 
 not 
 enable 
 a 
 network 
 participant 
 to 
 have 
 a 
 signicant 
 advantage 
 over 
 another 
 participant 
 it 
 requires 
 a 
 parity 
 between 
 common 
 hardware 
 and 
 high 
 cost 
 of 
 custom 
 devices 
 From 
 recent 
 examples 
 [8] 
 we 
 can 
 see 
 that 
 the 
 SHA 256 
 function 
 used 
 in 
 the 
 Bitcoin 
 architecture 
 does 
 not 
 posses 
 this 
 property 
 as 
 mining 
 becomes 
 more 
 ecient 
 on 
 GPUs 
 and 
 ASIC 
 devices 
 when 
 compared 
 to 
 high end 
 CPUs 
 
 
 Therefore 
 Bitcoin 
 creates 
 favourable 
 conditions 
 for 
 a 
 large 
 gap 
 between 
 the 
 voting 
 power 
 of 
 participants 
 as 
 it 
 violates 
 the 
 \one CPU one vote 
 principle 
 since 
 GPU 
 and 
 ASIC 
 owners 
 posses 
 a 
 much 
 larger 
 voting 
 power 
 when 
 compared 
 with 
 CPU 
 owners 
 It 
 is 
 a 
 classical 
 example 
 of 
 the 
 Pareto 
 principle 
 where 
 20% 
 of 
 a 
 system s 
 participants 
 control 
 more 
 than 
 80% 
 of 
 the 
 votes 
 
 
 One 
 could 
 argue 
 that 
 such 
 inequality 
 is 
 not 
 relevant 
 to 
 the 
 network s 
 security 
 since 
 it 
 is 
 not 
 the 
 small 
 number 
 of 
 participants 
 controlling 
 the 
 majority 
 of 
 the 
 votes 
 but 
 the 
 honesty 
 of 
 these 
 participants 
 that 
 matters 
 However 
 such 
 argument 
 is 
 somewhat 
 
 awed 
 since 
 it 
 is 
 rather 
 the 
 possibility 
 of 
 cheap 
 specialized 
 hardware 
 appearing 
 rather 
 than 
 the 
 participants 
 honesty 
 which 
 poses 
 a 
 threat 
 To 
 demonstrate 
 this 
 let 
 us 
 take 
 the 
 following 
 example 
 Suppose 
 a 
 malevolent 
 individual 
 gains 
 signicant 
 mining 
 power 
 by 
 creating 
 his 
 own 
 mining 
 farm 
 through 
 the 
 cheap 
 
 
 2 
 
 
 
 hardware 
 described 
 previously 
 Suppose 
 that 
 the 
 global 
 hashrate 
 decreases 
 signicantly 
 even 
 for 
 a 
 moment 
 he 
 can 
 now 
 use 
 his 
 mining 
 power 
 to 
 fork 
 the 
 chain 
 and 
 double spend 
 As 
 we 
 shall 
 see 
 later 
 in 
 this 
 article 
 it 
 is 
 not 
 unlikely 
 for 
 the 
 previously 
 described 
 event 
 to 
 take 
 place 
 
 
 2 3 
 Irregular 
 emission 
 Bitcoin 
 has 
 a 
 predetermined 
 emission 
 rate 
 each 
 solved 
 block 
 produces 
 a 
 xed 
 amount 
 of 
 coins 
 Approximately 
 every 
 four 
 years 
 this 
 reward 
 is 
 halved 
 The 
 original 
 intention 
 was 
 to 
 create 
 a 
 limited 
 smooth 
 emission 
 with 
 exponential 
 decay 
 but 
 in 
 fact 
 we 
 have 
 a 
 piecewise 
 linear 
 emission 
 function 
 whose 
 breakpoints 
 may 
 cause 
 problems 
 to 
 the 
 Bitcoin 
 infrastructure 
 
 
 When 
 the 
 breakpoint 
 occurs 
 miners 
 start 
 to 
 receive 
 only 
 half 
 of 
 the 
 value 
 of 
 their 
 previous 
 reward 
 The 
 absolute 
 dierence 
 between 
 12 5 
 and 
 6 25 
 BTC 
 (projected 
 for 
 the 
 year 
 2020) 
 may 
 seem 
 tolerable 
 However 
 when 
 examining 
 the 
 50 
 to 
 25 
 BTC 
 drop 
 that 
 took 
 place 
 on 
 November 
 28 
 2012 
 felt 
 inappropriate 
 for 
 a 
 signicant 
 number 
 of 
 members 
 of 
 the 
 mining 
 community 
 Figure 
 1 
 shows 
 a 
 dramatic 
 decrease 
 in 
 the 
 network s 
 hashrate 
 in 
 the 
 end 
 of 
 November 
 exactly 
 when 
 the 
 halving 
 took 
 place 
 This 
 event 
 could 
 have 
 been 
 the 
 perfect 
 moment 
 for 
 the 
 malevolent 
 individual 
 described 
 in 
 the 
 proof of work 
 function 
 section 
 to 
 carry out 
 a 
 double 
 spending 
 attack 
 [36] 
 
 
 
 Fig 
 1 
 Bitcoin 
 hashrate 
 chart 
 (source 
 http //bitcoin sipa be) 
 
 
 2 4 
 Hardcoded 
 constants 
 Bitcoin 
 has 
 many 
 hard coded 
 limits 
 where 
 some 
 are 
 natural 
 elements 
 of 
 the 
 original 
 design 
 (e g 
 block 
 frequency 
 maximum 
 amount 
 of 
 money 
 supply 
 number 
 of 
 conrmations) 
 whereas 
 other 
 seem 
 to 
 be 
 articial 
 constraints 
 It 
 is 
 not 
 so 
 much 
 the 
 limits 
 as 
 the 
 inability 
 of 
 quickly 
 changing 
 
 
 3 
 
 
 
 them 
 if 
 necessary 
 that 
 causes 
 the 
 main 
 drawbacks 
 Unfortunately 
 it 
 is 
 hard 
 to 
 predict 
 when 
 the 
 constants 
 may 
 need 
 to 
 be 
 changed 
 and 
 replacing 
 them 
 may 
 lead 
 to 
 terrible 
 consequences 
 
 
 A 
 good 
 example 
 of 
 a 
 hardcoded 
 limit 
 change 
 leading 
 to 
 disastrous 
 consequences 
 is 
 the 
 block 
 size 
 limit 
 set 
 to 
 250kb1 
 
 This 
 limit 
 was 
 sucient 
 to 
 hold 
 about 
 10000 
 standard 
 transactions 
 In 
 early 
 2013 
 this 
 limit 
 had 
 almost 
 been 
 reached 
 and 
 an 
 agreement 
 was 
 reached 
 to 
 increase 
 the 
 limit 
 The 
 change 
 was 
 implemented 
 in 
 wallet 
 version 
 0 8 
 and 
 ended 
 with 
 a 
 24 blocks 
 chain 
 split 
 and 
 a 
 successful 
 double spend 
 attack 
 [9] 
 While 
 the 
 bug 
 was 
 not 
 in 
 the 
 Bitcoin 
 protocol 
 but 
 rather 
 in 
 the 
 database 
 engine 
 it 
 could 
 have 
 been 
 easily 
 caught 
 by 
 a 
 simple 
 stress 
 test 
 if 
 there 
 was 
 no 
 articially 
 introduced 
 block 
 size 
 limit 
 
 
 Constants 
 also 
 act 
 as 
 a 
 form 
 of 
 centralization 
 point 
 Despite 
 the 
 peer to peer 
 nature 
 of 
 Bitcoin 
 an 
 overwhelming 
 majority 
 of 
 nodes 
 use 
 the 
 ocial 
 reference 
 client 
 [10] 
 developed 
 by 
 a 
 small 
 group 
 of 
 people 
 This 
 group 
 makes 
 the 
 decision 
 to 
 implement 
 changes 
 to 
 the 
 protocol 
 and 
 most 
 people 
 accept 
 these 
 changes 
 irrespective 
 of 
 their 
 \correctness 
 Some 
 decisions 
 caused 
 heated 
 discussions 
 and 
 even 
 calls 
 for 
 boycott 
 [11] 
 which 
 indicates 
 that 
 the 
 community 
 and 
 the 
 developers 
 may 
 disagree 
 on 
 some 
 important 
 points 
 It 
 therefore 
 seems 
 logical 
 to 
 have 
 a 
 protocol 
 with 
 user congurable 
 and 
 self adjusting 
 variables 
 as 
 a 
 possible 
 way 
 to 
 avoid 
 these 
 problems 
 
 
 2 5 
 Bulky 
 scripts 
 The 
 scripting 
 system 
 in 
 Bitcoin 
 is 
 a 
 heavy 
 and 
 complex 
 feature 
 It 
 potentially 
 allows 
 one 
 to 
 create 
 sophisticated 
 transactions 
 [12] 
 but 
 some 
 of 
 its 
 features 
 are 
 disabled 
 due 
 to 
 security 
 concerns 
 and 
 some 
 have 
 never 
 even 
 been 
 used 
 [13] 
 The 
 script 
 (including 
 both 
 senders 
 and 
 receivers 
 parts) 
 for 
 the 
 most 
 popular 
 transaction 
 in 
 Bitcoin 
 looks 
 like 
 this 
 
 
 <sig> 
 <pubKey> 
 OP 
 DUP 
 OP 
 HASH160 
 <pubKeyHash> 
 OP 
 EQUALVERIFY 
 OP 
 CHECKSIG 
 
 
 The 
 script 
 is 
 164 
 bytes 
 long 
 whereas 
 its 
 only 
 purpose 
 is 
 to 
 check 
 if 
 the 
 receiver 
 possess 
 the 
 secret 
 key 
 required 
 to 
 verify 
 his 
 signature 
 
 
 3 
 The 
 CryptoNote 
 Technology 
 
 
 Now 
 that 
 we 
 have 
 covered 
 the 
 limitations 
 of 
 the 
 Bitcoin 
 technology 
 we 
 will 
 concentrate 
 on 
 presenting 
 the 
 features 
 of 
 CryptoNote 
 
 
 4 
 Untraceable 
 Transactions 
 
 
 In 
 this 
 section 
 we 
 propose 
 a 
 scheme 
 of 
 fully 
 anonymous 
 transactions 
 satisfying 
 both 
 untraceability 
 and 
 unlinkability 
 conditions 
 An 
 important 
 feature 
 of 
 our 
 solution 
 is 
 its 
 autonomy 
 the 
 sender 
 is 
 not 
 required 
 to 
 cooperate 
 with 
 other 
 users 
 or 
 a 
 trusted 
 third 
 party 
 to 
 make 
 his 
 transactions 
 hence 
 each 
 participant 
 produces 
 a 
 cover 
 trac 
 independently 
 
 
 4 1 
 Literature 
 review 
 Our 
 scheme 
 relies 
 on 
 the 
 cryptographic 
 primitive 
 called 
 a 
 group 
 signature 
 First 
 presented 
 by 
 
 
 D 
 Chaum 
 and 
 E 
 van 
 Heyst 
 [19] 
 it 
 allows 
 a 
 user 
 to 
 sign 
 his 
 message 
 on 
 behalf 
 of 
 the 
 group 
 After 
 signing 
 the 
 message 
 the 
 user 
 provides 
 (for 
 verication 
 purposes) 
 not 
 his 
 own 
 single 
 public 
 1This 
 is 
 so called 
 \soft 
 limit 
 
 the 
 reference 
 client 
 restriction 
 for 
 creating 
 new 
 blocks 
 Hard 
 maximum 
 of 
 possible 
 blocksize 
 was 
 1 
 MB 
 
 
 4 
 
 
 
 key 
 but 
 the 
 keys 
 of 
 all 
 the 
 users 
 of 
 his 
 group 
 A 
 verier 
 is 
 convinced 
 that 
 the 
 real 
 signer 
 is 
 a 
 member 
 of 
 the 
 group 
 but 
 cannot 
 exclusively 
 identify 
 the 
 signer 
 
 
 The 
 original 
 protocol 
 required 
 a 
 trusted 
 third 
 party 
 (called 
 the 
 Group 
 Manager) 
 and 
 he 
 was 
 the 
 only 
 one 
 who 
 could 
 trace 
 the 
 signer 
 The 
 next 
 version 
 called 
 a 
 ring 
 signature 
 introduced 
 by 
 Rivest 
 et 
 al 
 in 
 [34] 
 was 
 an 
 autonomous 
 scheme 
 without 
 Group 
 Manager 
 and 
 anonymity 
 revocation 
 Various 
 modications 
 of 
 this 
 scheme 
 appeared 
 later 
 linkable 
 ring 
 signature 
 [26 
 27 
 
 
 17] 
 allowed 
 to 
 determine 
 if 
 two 
 signatures 
 were 
 produced 
 by 
 the 
 same 
 group 
 member 
 traceable 
 ring 
 signature 
 [24 
 23] 
 limited 
 excessive 
 anonymity 
 by 
 providing 
 possibility 
 to 
 trace 
 the 
 signer 
 of 
 two 
 messages 
 with 
 respect 
 to 
 the 
 same 
 metainformation 
 (or 
 \tag 
 in 
 terms 
 of 
 [24]) 
 A 
 similar 
 cryptographic 
 construction 
 is 
 also 
 known 
 as 
 a 
 ad hoc 
 group 
 signature 
 [16 
 38] 
 It 
 emphasizes 
 the 
 arbitrary 
 group 
 formation 
 whereas 
 group/ring 
 signature 
 schemes 
 rather 
 imply 
 a 
 xed 
 set 
 of 
 members 
 
 
 For 
 the 
 most 
 part 
 our 
 solution 
 is 
 based 
 on 
 the 
 work 
 \Traceable 
 ring 
 signature 
 by 
 E 
 Fujisaki 
 and 
 K 
 Suzuki 
 [24] 
 In 
 order 
 to 
 distinguish 
 the 
 original 
 algorithm 
 and 
 our 
 modication 
 we 
 will 
 call 
 the 
 latter 
 a 
 one time 
 ring 
 signature 
 stressing 
 the 
 user s 
 capability 
 to 
 produce 
 only 
 one 
 valid 
 signature 
 under 
 his 
 private 
 key 
 We 
 weakened 
 the 
 traceability 
 property 
 and 
 kept 
 the 
 linkability 
 only 
 to 
 provide 
 one timeness 
 the 
 public 
 key 
 may 
 appear 
 in 
 many 
 foreign 
 verifying 
 sets 
 and 
 the 
 private 
 key 
 can 
 be 
 used 
 for 
 generating 
 a 
 unique 
 anonymous 
 signature 
 In 
 case 
 of 
 a 
 double 
 spend 
 attempt 
 these 
 two 
 signatures 
 will 
 be 
 linked 
 together 
 but 
 revealing 
 the 
 signer 
 is 
 not 
 necessary 
 for 
 our 
 purposes 
 
 
 4 2 
 Denitions 
 4 2 1 
 Elliptic 
 curve 
 parameters 
 As 
 our 
 base 
 signature 
 algorithm 
 we 
 chose 
 to 
 use 
 the 
 fast 
 scheme 
 EdDSA 
 which 
 is 
 developed 
 and 
 implemented 
 by 
 D J 
 Bernstein 
 et 
 al 
 [18] 
 Like 
 Bitcoin s 
 ECDSA 
 it 
 is 
 based 
 on 
 the 
 elliptic 
 curve 
 discrete 
 logarithm 
 problem 
 so 
 our 
 scheme 
 could 
 also 
 be 
 applied 
 to 
 Bitcoin 
 in 
 future 
 
 
 Common 
 parameters 
 are 
 
 
 q 
 a 
 prime 
 number 
 q 
 =2255 
 
 19 
 d 
 an 
 element 
 of 
 Fq 
 d 
 = 
 121665=121666 
 2 
 
 E 
 an 
 elliptic 
 curve 
 equation 
 x2 
 + 
 y 
 =1+ 
 dx2y2 
 G 
 a 
 base 
 point 
 G 
 =(x 
 4=5) 
 l 
 a 
 prime 
 order 
 of 
 the 
 base 
 point 
 l 
 =2252 
 + 
 27742317777372353535851937790883648493 
 Hs 
 a 
 cryptographic 
 hash 
 function 
 f0 
 1g* 
 
 Fq 
 
 
 Hp 
 a 
 deterministic 
 hash 
 function 
 E(Fq) 
 
 E(Fq) 
 
 
 4 2 2 
 Terminology 
 Enhanced 
 privacy 
 requires 
 a 
 new 
 terminology 
 which 
 should 
 not 
 be 
 confused 
 with 
 Bitcoin 
 entities 
 
 
 private 
 ec key 
 is 
 a 
 standard 
 elliptic 
 curve 
 private 
 key 
 a 
 number 
 a 
 
 [1 l 
 
 1] 
 
 
 public 
 ec key 
 is 
 a 
 standard 
 elliptic 
 curve 
 public 
 key 
 a 
 point 
 A 
 = 
 aG 
 
 
 one time 
 keypair 
 is 
 a 
 pair 
 of 
 private 
 and 
 public 
 ec keys 
 
 
 5 
 
 
 
 private 
 user 
 key 
 is 
 a 
 pair 
 (a 
 b) 
 of 
 two 
 dierent 
 private 
 ec keys 
 
 
 tracking 
 key 
 is 
 a 
 pair 
 (a 
 B) 
 of 
 private 
 and 
 public 
 ec key 
 (where 
 B 
 = 
 bG 
 and 
 a 
 =6 
 b) 
 
 
 public 
 user 
 key 
 is 
 a 
 pair 
 (A 
 B) 
 of 
 two 
 public 
 ec keys 
 derived 
 from 
 (a 
 b) 
 
 
 standard 
 address 
 is 
 a 
 representation 
 of 
 a 
 public 
 user 
 key 
 given 
 into 
 human 
 friendly 
 string 
 with 
 error 
 correction 
 
 
 truncated 
 address 
 is 
 a 
 representation 
 of 
 the 
 second 
 half 
 (point 
 B) 
 of 
 a 
 public 
 user 
 key 
 given 
 into 
 human 
 friendly 
 string 
 with 
 error 
 correction 
 
 
 The 
 transaction 
 structure 
 remains 
 similar 
 to 
 the 
 structure 
 in 
 Bitcoin 
 every 
 user 
 can 
 choose 
 several 
 independent 
 incoming 
 payments 
 (transactions 
 outputs) 
 sign 
 them 
 with 
 the 
 corresponding 
 private 
 keys 
 and 
 send 
 them 
 to 
 dierent 
 destinations 
 
 
 Contrary 
 to 
 Bitcoin s 
 model 
 where 
 a 
 user 
 possesses 
 unique 
 private 
 and 
 public 
 key 
 in 
 the 
 proposed 
 model 
 a 
 sender 
 generates 
 a 
 one time 
 public 
 key 
 based 
 on 
 the 
 recipient s 
 address 
 and 
 some 
 random 
 data 
 In 
 this 
 sense 
 an 
 incoming 
 transaction 
 for 
 the 
 same 
 recipient 
 is 
 sent 
 to 
 a 
 one time 
 public 
 key 
 (not 
 directly 
 to 
 a 
 unique 
 address) 
 and 
 only 
 the 
 recipient 
 can 
 recover 
 the 
 corresponding 
 private 
 part 
 to 
 redeem 
 his 
 funds 
 (using 
 his 
 unique 
 private 
 key) 
 The 
 recipient 
 can 
 spend 
 the 
 funds 
 using 
 a 
 ring 
 signature 
 keeping 
 his 
 ownership 
 and 
 actual 
 spending 
 anonymous 
 The 
 details 
 of 
 the 
 protocol 
 are 
 explained 
 in 
 the 
 next 
 subsections 
 
 
 4 3 
 Unlinkable 
 payments 
 Classic 
 Bitcoin 
 addresses 
 once 
 being 
 published 
 become 
 unambiguous 
 identier 
 for 
 incoming 
 payments 
 linking 
 them 
 together 
 and 
 tying 
 to 
 the 
 recipient s 
 pseudonyms 
 If 
 someone 
 wants 
 to 
 receive 
 an 
 \untied 
 transaction 
 he 
 should 
 convey 
 his 
 address 
 to 
 the 
 sender 
 by 
 a 
 private 
 channel 
 If 
 he 
 wants 
 to 
 receive 
 dierent 
 transactions 
 which 
 cannot 
 be 
 proven 
 to 
 belong 
 to 
 the 
 same 
 owner 
 he 
 should 
 generate 
 all 
 the 
 dierent 
 addresses 
 and 
 never 
 publish 
 them 
 in 
 his 
 own 
 pseudonym 
 
 
 Public 
 
 
 Private 
 
 
 AliceCarolBob saddr1Bob saddr2Bob skey1Bob skey2
 Bob 
 
 
 Fig 
 2 
 Traditional 
 Bitcoin 
 keys/transactions 
 model 
 
 
 We 
 propose 
 a 
 solution 
 allowing 
 a 
 user 
 to 
 publish 
 a 
 single 
 address 
 and 
 receive 
 unconditional 
 unlinkable 
 payments 
 The 
 destination 
 of 
 each 
 CryptoNote 
 output 
 (by 
 default) 
 is 
 a 
 public 
 key 
 derived 
 from 
 recipient s 
 address 
 and 
 sender s 
 random 
 data 
 The 
 main 
 advantage 
 against 
 Bitcoin 
 is 
 that 
 every 
 destination 
 key 
 is 
 unique 
 by 
 default 
 (unless 
 the 
 sender 
 uses 
 the 
 same 
 data 
 for 
 each 
 of 
 his 
 transactions 
 to 
 the 
 same 
 recipient) 
 Hence 
 there 
 is 
 no 
 such 
 issue 
 as 
 \address 
 reuse 
 by 
 design 
 and 
 no 
 observer 
 can 
 determine 
 if 
 any 
 transactions 
 were 
 sent 
 to 
 a 
 specic 
 address 
 or 
 link 
 two 
 addresses 
 together 
 
 
 6 
 
 
 
 PublicPrivateAliceCarolOne timekeyOne timekeyOne timekeyBobBob sKeyBob sAddressAliceCarolOne timekeyOne timekeyOne timekeyBobBob sKeyBob sAddress
 Fig 
 3 
 CryptoNote 
 keys/transactions 
 model 
 
 
 First 
 the 
 sender 
 performs 
 a 
 Die Hellman 
 exchange 
 to 
 get 
 a 
 shared 
 secret 
 from 
 his 
 data 
 and 
 half 
 of 
 the 
 recipient s 
 address 
 Then 
 he 
 computes 
 a 
 one time 
 destination 
 key 
 using 
 the 
 shared 
 secret 
 and 
 the 
 second 
 half 
 of 
 the 
 address 
 Two 
 dierent 
 ec keys 
 are 
 required 
 from 
 the 
 recipient 
 for 
 these 
 two 
 steps 
 so 
 a 
 standard 
 CryptoNote 
 address 
 is 
 nearly 
 twice 
 as 
 large 
 as 
 a 
 Bitcoin 
 wallet 
 address 
 The 
 receiver 
 also 
 performs 
 a 
 Die Hellman 
 exchange 
 to 
 recover 
 the 
 corresponding 
 secret 
 key 
 
 
 A 
 standard 
 transaction 
 sequence 
 goes 
 as 
 follows 
 
 
 1 
 Alice 
 wants 
 to 
 send 
 a 
 payment 
 to 
 Bob 
 who 
 has 
 published 
 his 
 standard 
 address 
 She 
 unpacks 
 the 
 address 
 and 
 gets 
 Bob s 
 public 
 key 
 (A 
 B) 
 2 
 Alice 
 generates 
 a 
 random 
 r 
 
 [1 l 
 1] 
 and 
 computes 
 a 
 one time 
 public 
 key 
 P 
 = 
 Hs(rA)G+ 
 B 
 3 
 Alice 
 uses 
 P 
 as 
 a 
 destination 
 key 
 for 
 the 
 output 
 and 
 also 
 packs 
 value 
 R 
 = 
 rG 
 (as 
 a 
 part 
 of 
 the 
 Die Hellman 
 exchange) 
 somewhere 
 into 
 the 
 transaction 
 Note 
 that 
 she 
 can 
 create 
 other 
 outputs 
 with 
 unique 
 public 
 keys 
 dierent 
 recipients 
 keys 
 (Ai Bi) 
 imply 
 dierent 
 Pi 
 even 
 with 
 the 
 same 
 r 
 TransactionTxpublickeyTxoutputAmountDestinationkeyR=rGP=Hs(rA)G+BReceiver spublickeySender sran domdatar(A B)
 Fig 
 4 
 Standard 
 transaction 
 structure 
 
 
 4 
 Alice 
 sends 
 the 
 transaction 
 5 
 Bob 
 checks 
 every 
 passing 
 transaction 
 with 
 his 
 private 
 key 
 (a 
 b) 
 and 
 computes 
 P 
 0 
 = 
 Hs(aR)G 
 + 
 B 
 If 
 Alice s 
 transaction 
 for 
 with 
 Bob 
 as 
 the 
 recipient 
 was 
 among 
 them 
 then 
 aR 
 = 
 arG 
 = 
 rA 
 and 
 P 
 0 
 = 
 P 
 
 7 
 
 
 
 6 
 Bob 
 can 
 recover 
 the 
 corresponding 
 one time 
 private 
 key 
 x 
 = 
 Hs(aR)+ 
 b 
 so 
 as 
 P 
 = 
 xG 
 He 
 can 
 spend 
 this 
 output 
 at 
 any 
 time 
 by 
 signing 
 a 
 transaction 
 with 
 x 
 TransactionTxpublickeyTxoutputAmountDestinationkeyP0=Hs(aR)G+bGone timepublickeyx=Hs(aR)+bone timeprivatekeyReceiver sprivatekey(a b)RP0 =P
 Fig 
 5 
 Incoming 
 transaction 
 check 
 
 
 As 
 a 
 result 
 Bob 
 gets 
 incoming 
 payments 
 associated 
 with 
 one time 
 public 
 keys 
 which 
 are 
 unlinkable 
 for 
 a 
 spectator 
 Some 
 additional 
 notes 
 
 
 
 When 
 Bob 
 \recognizes 
 his 
 transactions 
 (see 
 step 
 5) 
 he 
 practically 
 uses 
 only 
 half 
 of 
 his 
 private 
 information 
 (a 
 B) 
 This 
 pair 
 also 
 known 
 as 
 the 
 tracking 
 key 
 can 
 be 
 passed 
 to 
 a 
 third 
 party 
 (Carol) 
 Bob 
 can 
 delegate 
 her 
 the 
 processing 
 of 
 new 
 transactions 
 Bob 
 doesn t 
 need 
 to 
 explicitly 
 trust 
 Carol 
 because 
 she 
 can t 
 recover 
 the 
 one time 
 secret 
 key 
 p 
 without 
 Bob s 
 full 
 private 
 key 
 (a 
 b) 
 This 
 approach 
 is 
 useful 
 when 
 Bob 
 lacks 
 bandwidth 
 or 
 computation 
 power 
 (smartphones 
 hardware 
 wallets 
 etc ) 
 
 In 
 case 
 Alice 
 wants 
 to 
 prove 
 she 
 sent 
 a 
 transaction 
 to 
 Bob s 
 address 
 she 
 can 
 either 
 disclose 
 r 
 or 
 use 
 any 
 kind 
 of 
 zero knowledge 
 protocol 
 to 
 prove 
 she 
 knows 
 r 
 (for 
 example 
 by 
 signing 
 the 
 transaction 
 with 
 r) 
 
 If 
 Bob 
 wants 
 to 
 have 
 an 
 audit 
 compatible 
 address 
 where 
 all 
 incoming 
 transaction 
 are 
 linkable 
 he 
 can 
 either 
 publish 
 his 
 tracking 
 key 
 or 
 use 
 a 
 truncated 
 address 
 That 
 address 
 represent 
 only 
 one 
 public 
 ec key 
 B 
 and 
 the 
 remaining 
 part 
 required 
 by 
 the 
 protocol 
 is 
 derived 
 from 
 it 
 as 
 follows 
 a 
 = 
 Hs(B) 
 and 
 A 
 = 
 Hs(B)G 
 In 
 both 
 cases 
 every 
 person 
 is 
 able 
 to 
 \recognize 
 all 
 of 
 Bob s 
 incoming 
 transaction 
 but 
 of 
 course 
 none 
 can 
 spend 
 the 
 funds 
 enclosed 
 within 
 them 
 without 
 the 
 secret 
 key 
 b 
 4 4 
 One time 
 ring 
 signatures 
 A 
 protocol 
 based 
 on 
 one time 
 ring 
 signatures 
 allows 
 users 
 to 
 achieve 
 unconditional 
 unlinkability 
 Unfortunately 
 ordinary 
 types 
 of 
 cryptographic 
 signatures 
 permit 
 to 
 trace 
 transactions 
 to 
 their 
 respective 
 senders 
 and 
 receivers 
 Our 
 solution 
 to 
 this 
 deciency 
 lies 
 in 
 using 
 a 
 dierent 
 signature 
 type 
 than 
 those 
 currently 
 used 
 in 
 electronic 
 cash 
 systems 
 
 
 We 
 will 
 rst 
 provide 
 a 
 general 
 description 
 of 
 our 
 algorithm 
 with 
 no 
 explicit 
 reference 
 to 
 electronic 
 cash 
 
 
 A 
 one time 
 ring 
 signature 
 contains 
 four 
 algorithms 
 (GEN 
 SIG 
 VER 
 LNK) 
 
 
 GEN 
 takes 
 public 
 parameters 
 and 
 outputs 
 an 
 ec pair 
 (P 
 x) 
 and 
 a 
 public 
 key 
 I 
 
 
 SIG 
 takes 
 a 
 message 
 m 
 a 
 set 
 S0 
 of 
 public 
 keys 
 fPigi6=s 
 a 
 pair 
 (Ps xs) 
 and 
 outputs 
 a 
 signature 
 s 
 and 
 a 
 set 
 S 
 = 
 S0 
 [fPsg 
 
 
 8 
 
 
 
 VER 
 takes 
 a 
 message 
 m 
 a 
 set 
 S 
 a 
 signature 
 s 
 and 
 outputs 
 \true 
 or 
 \false 
 
 
 LNK 
 takes 
 a 
 set 
 I 
 = 
 fIig 
 a 
 signature 
 s 
 and 
 outputs 
 \linked 
 or 
 \indep 
 
 
 The 
 idea 
 behind 
 the 
 protocol 
 is 
 fairly 
 simple 
 a 
 user 
 produces 
 a 
 signature 
 which 
 can 
 be 
 checked 
 by 
 a 
 set 
 of 
 public 
 keys 
 rather 
 than 
 a 
 unique 
 public 
 key 
 The 
 identity 
 of 
 the 
 signer 
 is 
 indistinguishable 
 from 
 the 
 other 
 users 
 whose 
 public 
 keys 
 are 
 in 
 the 
 set 
 until 
 the 
 owner 
 produces 
 a 
 second 
 signature 
 using 
 the 
 same 
 keypair 
 
 
 Privatekeysx0xixnPublickeysP0PiPnRingSignaturesignverify
 Fig 
 6 
 Ring 
 signature 
 anonymity 
 
 
 GEN 
 The 
 signer 
 picks 
 a 
 random 
 secret 
 key 
 x 
 
 [1 l 
 
 1] 
 and 
 computes 
 the 
 corresponding 
 public 
 key 
 P 
 = 
 xG 
 Additionally 
 he 
 computes 
 another 
 public 
 key 
 I 
 = 
 xHp(P 
 ) 
 which 
 we 
 will 
 call 
 the 
 \key 
 image 
 
 
 SIG 
 The 
 signer 
 generates 
 a 
 one time 
 ring 
 signature 
 with 
 a 
 non interactive 
 zero knowledge 
 proof 
 using 
 the 
 techniques 
 from 
 [21] 
 He 
 selects 
 a 
 random 
 subset 
 S0 
 of 
 n 
 from 
 the 
 other 
 users 
 public 
 keys 
 Pi 
 his 
 own 
 keypair 
 (x 
 P 
 ) 
 and 
 key 
 image 
 I 
 Let 
 0 
 = 
 s 
 = 
 n 
 be 
 signer s 
 secret 
 index 
 in 
 S 
 (so 
 that 
 his 
 public 
 key 
 is 
 Ps) 
 
 
 He 
 picks 
 a 
 random 
 fqi 
 | 
 i 
 =0 
 n} 
 and 
 fwi 
 | 
 i 
 =0 
 
 
 
 n 
 i 
 6
 = 
 s} 
 from 
 (1 
 l) 
 and 
 applies 
 the 
 following 
 transformations 
 
 
 ( 
 
 
 qiG 
 if 
 i 
 = 
 s 
 
 
 Li 
 = 
 
 
 qiG 
 + 
 wiPi 
 if 
 i 
 =6 
 s 
 
 
 ( 
 
 
 qiHp(Pi) 
 if 
 i 
 = 
 s 
 
 
 Ri 
 = 
 
 
 qiHp(Pi)+ 
 wiI 
 if 
 i 
 6
 = 
 s 
 
 
 The 
 next 
 step 
 is 
 getting 
 the 
 non interactive 
 challenge 
 
 
 c 
 = 
 Hs(m 
 L1 Ln R1 Rn) 
 
 
 Finally 
 the 
 signer 
 computes 
 the 
 response 
 
 <wi 
 if 
 i 
 6
 = 
 s 
 ci 
 = 
 c 
 
 nP 
 ci 
 mod 
 l 
 if 
 i 
 = 
 s 
 i=0 
 ( 
 qi 
 if 
 i 
 6
 = 
 s 
 ri 
 = 
 qs 
 
 csx 
 mod 
 l 
 if 
 i 
 = 
 s 
 
 
 The 
 resulting 
 signature 
 is 
 s 
 =(I c1 cn r1 rn) 
 
 
 9 
 
 
 
 VER 
 The 
 verier 
 checks 
 the 
 signature 
 by 
 applying 
 the 
 inverse 
 transformations 
 
 
 ( 
 
 
 L0 
 
 
 i 
 = 
 riG 
 + 
 ciPi 
 R0 
 = 
 riHp(Pi)+ 
 ciI
 
 i 
 
 
 n
 
 P 
 
 
 Finally 
 the 
 verier 
 checks 
 if 
 ci 
 = 
 Hs(m 
 L0 
 0 
 L0 
 R0 
 0 
 R0 
 ) 
 mod 
 l
 
 nn 
 
 
 i=0 
 
 
 If 
 this 
 equality 
 is 
 correct 
 the 
 verier 
 runs 
 the 
 algorithm 
 LNK 
 Otherwise 
 the 
 verier 
 rejects 
 the 
 signature 
 
 
 LNK 
 The 
 verier 
 checks 
 if 
 I 
 has 
 been 
 used 
 in 
 past 
 signatures 
 (these 
 values 
 are 
 stored 
 in 
 the 
 set 
 I) 
 Multiple 
 uses 
 imply 
 that 
 two 
 signatures 
 were 
 produced 
 under 
 the 
 same 
 secret 
 key 
 
 
 The 
 meaning 
 of 
 the 
 protocol 
 by 
 applying 
 L transformations 
 the 
 signer 
 proves 
 that 
 he 
 knows 
 such 
 x 
 that 
 at 
 least 
 one 
 Pi 
 = 
 xG 
 To 
 make 
 this 
 proof 
 non repeatable 
 we 
 introduce 
 the 
 key 
 image 
 as 
 I 
 = 
 xHp(P 
 ) 
 The 
 signer 
 uses 
 the 
 same 
 coecients 
 (ri ci) 
 to 
 prove 
 almost 
 the 
 same 
 statement 
 
 
 1
 
 he 
 knows 
 such 
 x 
 that 
 at 
 least 
 one 
 Hp(Pi)= 
 I 
 
 x 
 
 If 
 the 
 mapping 
 x 
 
 I 
 is 
 an 
 injection 
 
 
 1 
 Nobody 
 can 
 recover 
 the 
 public 
 key 
 from 
 the 
 key 
 image 
 and 
 identify 
 the 
 signer 
 2 
 The 
 signer 
 cannot 
 make 
 two 
 signatures 
 with 
 dierent 
 I s 
 and 
 the 
 same 
 x 
 A 
 full 
 security 
 analysis 
 is 
 provided 
 in 
 Appendix 
 A 
 
 
 4 5 
 Standard 
 CryptoNote 
 transaction 
 By 
 combining 
 both 
 methods 
 (unlinkable 
 public 
 keys 
 and 
 untraceable 
 ring 
 signature) 
 Bob 
 achieves 
 new 
 level 
 of 
 privacy 
 in 
 comparison 
 with 
 the 
 original 
 Bitcoin 
 scheme 
 It 
 requires 
 him 
 to 
 store 
 only 
 one 
 private 
 key 
 (a 
 b) 
 and 
 publish 
 (A 
 B) 
 to 
 start 
 receiving 
 and 
 sending 
 anonymous 
 transactions 
 
 
 While 
 validating 
 each 
 transaction 
 Bob 
 additionally 
 performs 
 only 
 two 
 elliptic 
 curve 
 multiplication
 s 
 and 
 one 
 addition 
 per 
 output 
 to 
 check 
 if 
 a 
 transaction 
 belongs 
 to 
 him 
 For 
 his 
 every 
 output 
 Bob 
 recovers 
 a 
 one time 
 keypair 
 (pi Pi) 
 and 
 stores 
 it 
 in 
 his 
 wallet 
 Any 
 inputs 
 can 
 be 
 circumstantially 
 proved 
 to 
 have 
 the 
 same 
 owner 
 only 
 if 
 they 
 appear 
 in 
 a 
 single 
 transaction 
 In 
 fact 
 this 
 relationship 
 is 
 much 
 harder 
 to 
 establish 
 due 
 to 
 the 
 one time 
 ring 
 signature 
 
 
 With 
 a 
 ring 
 signature 
 Bob 
 can 
 eectively 
 hide 
 every 
 input 
 among 
 somebody 
 else s 
 all 
 possible 
 spenders 
 will 
 be 
 equiprobable 
 even 
 the 
 previous 
 owner 
 (Alice) 
 has 
 no 
 more 
 information 
 than 
 any 
 observer 
 
 
 When 
 signing 
 his 
 transaction 
 Bob 
 species 
 n 
 foreign 
 outputs 
 with 
 the 
 same 
 amount 
 as 
 his 
 output 
 mixing 
 all 
 of 
 them 
 without 
 the 
 participation 
 of 
 other 
 users 
 Bob 
 himself 
 (as 
 well 
 as 
 anybody 
 else) 
 does 
 not 
 know 
 if 
 any 
 of 
 these 
 payments 
 have 
 been 
 spent 
 an 
 output 
 can 
 be 
 used 
 in 
 thousands 
 of 
 signatures 
 as 
 an 
 ambiguity 
 factor 
 and 
 never 
 as 
 a 
 target 
 of 
 hiding 
 The 
 double 
 spend 
 check 
 occurs 
 in 
 the 
 LNK 
 phase 
 when 
 checking 
 against 
 the 
 used 
 key 
 images 
 set 
 
 
 Bob 
 can 
 choose 
 the 
 ambiguity 
 degree 
 on 
 his 
 own 
 n 
 = 
 1 
 means 
 that 
 the 
 probability 
 he 
 has 
 spent 
 the 
 output 
 is 
 50% 
 probability 
 n 
 = 
 99 
 gives 
 1% 
 The 
 size 
 of 
 the 
 resulting 
 signature 
 increases 
 linearly 
 as 
 O(n 
 + 
 1) 
 so 
 the 
 improved 
 anonymity 
 costs 
 to 
 Bob 
 extra 
 transaction 
 fees 
 He 
 also 
 can 
 set 
 n 
 = 
 0 
 and 
 make 
 his 
 ring 
 signature 
 to 
 consist 
 of 
 only 
 one 
 element 
 however 
 this 
 will 
 instantly 
 reveal 
 him 
 as 
 a 
 spender 
 
 
 10 
 
 
 
 TransactionTxinputOutput0 Outputi OutputnKeyimageSignaturesRingSignatureDestinationkeyOutput1DestinationkeyOutputnForeigntransactionsSender soutputDestinationkeyOne timekeypairOne timeprivatekeyI=xHp(P)P xOutput0 Outputi OutputnKeyimageSignatures
 RingSignatureDestinationkeyOutput1DestinationkeyOutputnForeigntransactionsSender soutputDestinationkeyOne timekeypairOne timeprivatekeyI=xHp(P)P x
 Fig 
 7 
 Ring 
 signature 
 generation 
 in 
 a 
 standard 
 transaction 
 
 
 5 
 Egalitarian 
 Proof of work 
 
 
 In 
 this 
 section 
 we 
 propose 
 and 
 ground 
 the 
 new 
 proof of work 
 algorithm 
 Our 
 primary 
 goal 
 is 
 to 
 close 
 the 
 gap 
 between 
 CPU 
 (majority) 
 and 
 GPU/FPGA/ASIC 
 (minority) 
 miners 
 It 
 is 
 appropriate 
 that 
 some 
 users 
 can 
 have 
 a 
 certain 
 advantage 
 over 
 others 
 but 
 their 
 investments 
 should 
 grow 
 at 
 least 
 linearly 
 with 
 the 
 power 
 More 
 generally 
 producing 
 special purpose 
 devices 
 has 
 to 
 be 
 as 
 less 
 protable 
 as 
 possible 
 
 
 5 1 
 Related 
 works 
 The 
 original 
 Bitcoin 
 proof of work 
 protocol 
 uses 
 the 
 CPU intensive 
 pricing 
 function 
 SHA 256 
 It 
 mainly 
 consists 
 of 
 basic 
 logical 
 operators 
 and 
 relies 
 solely 
 on 
 the 
 computational 
 speed 
 of 
 processor 
 therefore 
 is 
 perfectly 
 suitable 
 for 
 multicore/conveyer 
 implementation 
 
 
 However 
 modern 
 computers 
 are 
 not 
 limited 
 by 
 the 
 number 
 of 
 operations 
 per 
 second 
 alone 
 but 
 also 
 by 
 memory 
 size 
 While 
 some 
 processors 
 can 
 be 
 substantially 
 faster 
 than 
 others 
 [8] 
 memory 
 sizes 
 are 
 less 
 likely 
 to 
 vary 
 between 
 machines 
 
 
 Memory bound 
 price 
 functions 
 were 
 rst 
 introduced 
 by 
 Abadi 
 et 
 al 
 and 
 were 
 dened 
 as 
 \functions 
 whose 
 computation 
 time 
 is 
 dominated 
 by 
 the 
 time 
 spent 
 accessing 
 memory 
 [15] 
 The 
 main 
 idea 
 is 
 to 
 construct 
 an 
 algorithm 
 allocating 
 a 
 large 
 block 
 of 
 data 
 (\scratchpad ) 
 within 
 memory 
 that 
 can 
 be 
 accessed 
 relatively 
 slowly 
 (for 
 example 
 RAM) 
 and 
 \accessing 
 an 
 unpredictable 
 sequence 
 of 
 locations 
 within 
 it 
 A 
 block 
 should 
 be 
 large 
 enough 
 to 
 make 
 preserving 
 the 
 data 
 more 
 advantageous 
 than 
 recomputing 
 it 
 for 
 each 
 access 
 The 
 algorithm 
 also 
 should 
 prevent 
 internal 
 parallelism 
 hence 
 N 
 simultaneous 
 threads 
 should 
 require 
 N 
 times 
 more 
 memory 
 at 
 once 
 
 
 Dwork 
 et 
 al 
 [22] 
 investigated 
 and 
 formalized 
 this 
 approach 
 leading 
 them 
 to 
 suggest 
 another 
 variant 
 of 
 the 
 pricing 
 function 
 \Mbound 
 One 
 more 
 work 
 belongs 
 to 
 F 
 Coelho 
 [20] 
 who 
 
 
 11 
 
 
 
 proposed 
 the 
 most 
 eective 
 solution 
 \Hokkaido 
 
 
 To 
 our 
 knowledge 
 the 
 last 
 work 
 based 
 on 
 the 
 idea 
 of 
 pseudo random 
 searches 
 in 
 a 
 big 
 array 
 is 
 the 
 algorithm 
 known 
 as 
 \scrypt 
 by 
 C 
 Percival 
 [32] 
 Unlike 
 the 
 previous 
 functions 
 it 
 focuses 
 on 
 key 
 derivation 
 and 
 not 
 proof of work 
 systems 
 Despite 
 this 
 fact 
 scrypt 
 can 
 serve 
 our 
 purpose 
 it 
 works 
 well 
 as 
 a 
 pricing 
 function 
 in 
 the 
 partial 
 hash 
 conversion 
 problem 
 such 
 as 
 SHA 256 
 in 
 Bitcoin 
 
 
 By 
 now 
 scrypt 
 has 
 already 
 been 
 applied 
 in 
 Litecoin 
 [14] 
 and 
 some 
 other 
 Bitcoin 
 forks 
 However
 
 its 
 implementation 
 is 
 not 
 really 
 memory bound 
 the 
 ratio 
 \memory 
 access 
 time 
 / 
 overall 
 time 
 is 
 not 
 large 
 enough 
 because 
 each 
 instance 
 uses 
 only 
 128 
 KB 
 This 
 permits 
 GPU 
 miners 
 to 
 be 
 roughly 
 10 
 times 
 more 
 eective 
 and 
 continues 
 to 
 leave 
 the 
 possibility 
 of 
 creating 
 relatively 
 cheap 
 but 
 highly ecient 
 mining 
 devices 
 
 
 Moreover 
 the 
 scrypt 
 construction 
 itself 
 allows 
 a 
 linear 
 trade off 
 between 
 memory 
 size 
 and 
 CPU 
 speed 
 due 
 to 
 the 
 fact 
 that 
 every 
 block 
 in 
 the 
 scratchpad 
 is 
 derived 
 only 
 from 
 the 
 previous 
 For 
 example 
 you 
 can 
 store 
 every 
 second 
 block 
 and 
 recalculate 
 the 
 others 
 in 
 a 
 lazy 
 way 
 i e 
 only 
 when 
 it 
 becomes 
 necessary 
 The 
 pseudo random 
 indexes 
 are 
 assumed 
 to 
 be 
 uniformly 
 distributed 
 hence 
 the 
 expected 
 value 
 of 
 the 
 additional 
 blocks 
 recalculations 
 is 
 1 
 
 N 
 where 
 N 
 is 
 the 
 number 
 
 
 2 
 
 
 of 
 iterations 
 The 
 overall 
 computation 
 time 
 increases 
 less 
 than 
 by 
 half 
 because 
 there 
 are 
 also 
 time 
 independent 
 (constant 
 time) 
 operations 
 such 
 as 
 preparing 
 the 
 scratchpad 
 and 
 hashing 
 on 
 
 
 11
 
 every 
 iteration 
 Saving 
 2=3 
 of 
 the 
 memory 
 costs 
 
 N 
 + 
 
 2 
 
 N 
 = 
 N 
 additional 
 recalculations 
 
 33 
 
 
 11
 
 9=10 
 results 
 in 
 
 N 
 + 
 
 + 
 
 9 
 
 N 
 =4 5N 
 It 
 is 
 easy 
 to 
 show 
 that 
 storing 
 only 
 1 
 of 
 all 
 blocks 
 
 
 10 
 10 
 s 
 
 
 increases 
 the 
 time 
 less 
 than 
 by 
 a 
 factor 
 of 
 s 1 
 
 This 
 in 
 turn 
 implies 
 that 
 a 
 machine 
 with 
 a 
 CPU
 
 2 
 
 
 200 
 times 
 faster 
 than 
 the 
 modern 
 chips 
 can 
 store 
 only 
 320 
 bytes 
 of 
 the 
 scratchpad 
 
 
 5 2 
 The 
 proposed 
 algorithm 
 We 
 propose 
 a 
 new 
 memory bound 
 algorithm 
 for 
 the 
 proof of work 
 pricing 
 function 
 It 
 relies 
 on 
 random 
 access 
 to 
 a 
 slow 
 memory 
 and 
 emphasizes 
 latency 
 dependence 
 As 
 opposed 
 to 
 scrypt 
 every 
 new 
 block 
 (64 
 bytes 
 in 
 length) 
 depends 
 on 
 all 
 the 
 previous 
 blocks 
 As 
 a 
 result 
 a 
 hypothetical 
 \memory saver 
 should 
 increase 
 his 
 calculation 
 speed 
 exponentially 
 
 
 Our 
 algorithm 
 requires 
 about 
 2 
 Mb 
 per 
 instance 
 for 
 the 
 following 
 reasons 
 
 
 1 
 It 
 ts 
 in 
 the 
 L3 
 cache 
 (per 
 core) 
 of 
 modern 
 processors 
 which 
 should 
 become 
 mainstream 
 in 
 a 
 few 
 years 
 2 
 A 
 megabyte 
 of 
 internal 
 memory 
 is 
 an 
 almost 
 unacceptable 
 size 
 for 
 a 
 modern 
 ASIC 
 pipeline 
 3 
 GPUs 
 may 
 run 
 hundreds 
 of 
 concurrent 
 instances 
 but 
 they 
 are 
 limited 
 in 
 other 
 ways 
 GDDR5 
 memory 
 is 
 slower 
 than 
 the 
 CPU 
 L3 
 cache 
 and 
 remarkable 
 for 
 its 
 bandwidth 
 not 
 random 
 access 
 speed 
 4 
 Signicant 
 expansion 
 of 
 the 
 scratchpad 
 would 
 require 
 an 
 increase 
 in 
 iterations 
 which 
 in 
 turn 
 implies 
 an 
 overall 
 time 
 increase 
 \Heavy 
 calls 
 in 
 a 
 trust less 
 p2p 
 network 
 may 
 lead 
 to 
 serious 
 vulnerabilities 
 because 
 nodes 
 are 
 obliged 
 to 
 check 
 every 
 new 
 block s 
 proof of work 
 If 
 a 
 node 
 spends 
 a 
 considerable 
 amount 
 of 
 time 
 on 
 each 
 hash 
 evaluation 
 it 
 can 
 be 
 easily 
 DDoSed 
 by 
 a 
 
 ood 
 of 
 fake 
 objects 
 with 
 arbitrary 
 work 
 data 
 (nonce 
 values) 
 12 
 
 
 
 6 
 Further 
 advantages 
 
 
 6 1 
 Smooth 
 emission 
 264 
 
 1
 
 The 
 upper 
 bound 
 for 
 the 
 overall 
 amount 
 of 
 CryptoNote 
 digital 
 coins 
 is 
 MSupply 
 = 
 atomic 
 units 
 This 
 is 
 a 
 natural 
 restriction 
 based 
 only 
 on 
 implementation 
 limits 
 not 
 on 
 intuition 
 such 
 as 
 \N 
 coins 
 ought 
 to 
 be 
 enough 
 for 
 anybody 
 
 
 To 
 ensure 
 the 
 smoothness 
 of 
 the 
 emission 
 process 
 we 
 use 
 the 
 following 
 formula 
 for 
 block 
 rewards 
 BaseReward 
 =(MSupply 
 
 A) 
 18 
 
 
 where 
 A 
 is 
 amount 
 of 
 previously 
 generated 
 coins 
 
 
 6 2 
 Adjustable 
 parameters 
 6 2 1 
 Diculty 
 CryptoNote 
 contains 
 a 
 targeting 
 algorithm 
 which 
 changes 
 the 
 diculty 
 of 
 every 
 block 
 This 
 decreases 
 the 
 system s 
 reaction 
 time 
 when 
 the 
 network 
 hashrate 
 is 
 intensely 
 growing 
 or 
 shrinking 
 preserving 
 a 
 constant 
 block 
 rate 
 The 
 original 
 Bitcoin 
 method 
 calculates 
 the 
 relation 
 of 
 actual 
 and 
 target 
 time span 
 between 
 the 
 last 
 2016 
 blocks 
 and 
 uses 
 it 
 as 
 the 
 multiplier 
 for 
 the 
 current 
 diculty 
 Obviously 
 this 
 is 
 unsuitable 
 for 
 rapid 
 recalculations 
 (because 
 of 
 large 
 inertia) 
 and 
 results 
 in 
 oscillations 
 
 
 The 
 general 
 idea 
 behind 
 our 
 algorithm 
 is 
 to 
 sum 
 all 
 the 
 work 
 completed 
 by 
 the 
 nodes 
 and 
 divide 
 it 
 by 
 the 
 time 
 they 
 have 
 spent 
 The 
 measure 
 of 
 work 
 is 
 the 
 corresponding 
 diculty 
 values 
 in 
 each 
 block 
 But 
 due 
 to 
 inaccurate 
 and 
 untrusted 
 timestamps 
 we 
 cannot 
 determine 
 the 
 exact 
 time 
 interval 
 between 
 blocks 
 A 
 user 
 can 
 shift 
 his 
 timestamp 
 into 
 the 
 future 
 and 
 the 
 next 
 time 
 intervals 
 might 
 be 
 improbably 
 small 
 or 
 even 
 negative 
 Presumably 
 there 
 will 
 be 
 few 
 incidents 
 of 
 this 
 kind 
 so 
 we 
 can 
 just 
 sort 
 the 
 timestamps 
 and 
 cut off 
 the 
 outliers 
 (i e 
 20%) 
 The 
 range 
 of 
 the 
 rest 
 values 
 is 
 the 
 time 
 which 
 was 
 spent 
 for 
 80% 
 of 
 the 
 corresponding 
 blocks 
 
 
 6 2 2 
 Size 
 limits 
 Users 
 pay 
 for 
 storing 
 the 
 blockchain 
 and 
 shall 
 be 
 entitled 
 to 
 vote 
 for 
 its 
 size 
 Every 
 miner 
 deals 
 with 
 the 
 trade off 
 between 
 balancing 
 the 
 costs 
 and 
 prot 
 from 
 the 
 fees 
 and 
 sets 
 his 
 own 
 \soft limit 
 for 
 creating 
 blocks 
 Also 
 the 
 core 
 rule 
 for 
 the 
 maximum 
 block 
 size 
 is 
 necessary 
 for 
 preventing 
 the 
 blockchain 
 from 
 being 
 
 ooded 
 with 
 bogus 
 transaction 
 however 
 this 
 value 
 should 
 not 
 be 
 hard coded 
 
 
 Let 
 MN 
 be 
 the 
 median 
 value 
 of 
 the 
 last 
 N 
 blocks 
 sizes 
 Then 
 the 
 \hard limit 
 for 
 the 
 size 
 of 
 accepting 
 blocks 
 is 
 2 
 
 MN 
 
 It 
 averts 
 the 
 blockchain 
 from 
 bloating 
 but 
 still 
 allows 
 the 
 limit 
 to 
 slowly 
 grow 
 with 
 time 
 if 
 necessary 
 
 
 Transaction 
 size 
 does 
 not 
 need 
 to 
 be 
 limited 
 explicitly 
 It 
 is 
 bounded 
 by 
 the 
 size 
 of 
 a 
 block 
 and 
 if 
 somebody 
 wants 
 to 
 create 
 a 
 huge 
 transaction 
 with 
 hundreds 
 of 
 inputs/outputs 
 (or 
 with 
 the 
 high 
 ambiguity 
 degree 
 in 
 ring 
 signatures) 
 he 
 can 
 do 
 so 
 by 
 paying 
 sucient 
 fee 
 
 
 6 2 3 
 Excess 
 size 
 penalty 
 A 
 miner 
 still 
 has 
 the 
 ability 
 to 
 stuff 
 a 
 block 
 full 
 of 
 his 
 own 
 zero fee 
 transactions 
 up 
 to 
 its 
 maximum 
 size 
 2 
 
 Mb 
 Even 
 though 
 only 
 the 
 majority 
 of 
 miners 
 can 
 shift 
 the 
 median 
 value 
 there 
 is 
 still 
 a 
 
 
 13 
 
 
 
 possibility 
 to 
 bloat 
 the 
 blockchain 
 and 
 produce 
 an 
 additional 
 load 
 on 
 the 
 nodes 
 To 
 discourage 
 malevolent 
 participants 
 from 
 creating 
 large 
 blocks 
 we 
 introduce 
 a 
 penalty 
 function 
 
 
 2
 
 BlkSize 
 
 
 NewReward 
 = 
 BaseReward 
  
 1 
 
 
 MN 
 
 
 This 
 rule 
 is 
 applied 
 only 
 when 
 BlkSize 
 is 
 greater 
 than 
 minimal 
 free 
 block 
 size 
 which 
 should 
 be 
 close 
 to 
 max(10kb MN 
 110%) 
 Miners 
 are 
 permitted 
 to 
 create 
 blocks 
 of 
 \usual 
 size 
 and 
 even 
 exceed 
 it 
 with 
 prot 
 when 
 the 
 overall 
 fees 
 surpass 
 the 
 penalty 
 But 
 fees 
 are 
 unlikely 
 to 
 grow 
 quadratically 
 unlike 
 the 
 penalty 
 value 
 so 
 there 
 will 
 be 
 an 
 equilibrium 
 
 
 6 3 
 Transaction 
 scripts 
 CryptoNote 
 has 
 a 
 very 
 minimalistic 
 scripting 
 subsystem 
 A 
 sender 
 species 
 an 
 expression 
 F 
 = 
 f 
 (x1 x2 xn) 
 where 
 n 
 is 
 the 
 number 
 of 
 destination 
 public 
 keys 
 fPign 
 Only 
 ve 
 binary
 
 i=1 
 operators 
 are 
 supported 
 min 
 max 
 sum 
 mul 
 and 
 cmp 
 When 
 the 
 receiver 
 spends 
 this 
 payment 
 he 
 produces 
 0 
 = 
 k 
 = 
 n 
 signatures 
 and 
 passes 
 them 
 to 
 transaction 
 input 
 The 
 verication 
 process 
 simply 
 evaluates 
 F 
 with 
 xi 
 = 
 1 
 to 
 check 
 for 
 a 
 valid 
 signature 
 for 
 the 
 public 
 key 
 Pi 
 and 
 xi 
 = 
 0 
 A 
 verier 
 accepts 
 the 
 proof 
 iff 
 F 
 > 
 0 
 Despite 
 its 
 simplicity 
 this 
 approach 
 covers 
 every 
 possible 
 case 
 
 
 
 Multi /Threshold 
 signature 
 For 
 the 
 Bitcoin style 
 \M out of N 
 multi signature 
 (i e 
 the 
 receiver 
 should 
 provide 
 at 
 least 
 0 
 = 
 M 
 = 
 N 
 valid 
 signatures) 
 F 
 = 
 x1+x2+ +xN 
 = 
 M 
 (for 
 clarity 
 we 
 are 
 using 
 common 
 algebraic 
 notation) 
 The 
 weighted 
 threshold 
 signature 
 (some 
 keys 
 can 
 be 
 more 
 important 
 than 
 other) 
 could 
 be 
 expressed 
 as 
 F 
 = 
 w1 
 
 x1 
 + 
 w2 
 
 x2 
 + 
 
 + 
 wN 
 
 xN 
 = 
 wM 
 
 And 
 scenario 
 where 
 the 
 master key 
 corresponds 
 to 
 F 
 = 
 max(M 
 
 x 
 x1 
 + 
 x2 
 + 
 
 + 
 xN 
 ) 
 = 
 M 
 It 
 is 
 easy 
 to 
 show 
 that 
 any 
 sophisticated 
 case 
 can 
 be 
 expressed 
 with 
 these 
 operators 
 i e 
 they 
 form 
 basis 
 
 Password 
 protection 
 Possession 
 of 
 a 
 secret 
 password 
 s 
 is 
 equivalent 
 to 
 the 
 knowledge 
 of 
 a 
 private 
 key 
 deterministically 
 derived 
 from 
 the 
 password 
 k 
 = 
 KDF(s) 
 Hence 
 a 
 receiver 
 can 
 prove 
 that 
 he 
 knows 
 the 
 password 
 by 
 providing 
 another 
 signature 
 under 
 the 
 key 
 k 
 The 
 sender 
 simply 
 adds 
 the 
 corresponding 
 public 
 key 
 to 
 his 
 own 
 output 
 Note 
 that 
 this 
 method 
 is 
 much 
 more 
 secure 
 than 
 the 
 \transaction 
 puzzle 
 used 
 in 
 Bitcoin 
 [13] 
 where 
 the 
 password 
 is 
 explicitly 
 passed 
 in 
 the 
 inputs 
 
 Degenerate 
 cases 
 F 
 = 
 1 
 means 
 that 
 anybody 
 can 
 spend 
 the 
 money 
 F 
 = 
 0 
 marks 
 the 
 output 
 as 
 not 
 spendable 
 forever 
 In 
 the 
 case 
 when 
 the 
 output 
 script 
 combined 
 with 
 public 
 keys 
 is 
 too 
 large 
 for 
 a 
 sender 
 he 
 can 
 use 
 special 
 output 
 type 
 which 
 indicates 
 that 
 the 
 recipient 
 will 
 put 
 this 
 data 
 in 
 his 
 input 
 while 
 the 
 sender 
 provides 
 only 
 a 
 hash 
 of 
 it 
 This 
 approach 
 is 
 similar 
 to 
 Bitcoin s 
 \pay to hash 
 feature 
 but 
 instead 
 of 
 adding 
 new 
 script 
 commands 
 we 
 handle 
 this 
 case 
 at 
 the 
 data 
 structure 
 level 
 
 
 7 
 Conclusion 
 
 
 We 
 have 
 investigated 
 the 
 major 
 
 aws 
 in 
 Bitcoin 
 and 
 proposed 
 some 
 possible 
 solutions 
 These 
 advantageou
 s 
 features 
 and 
 our 
 ongoing 
 development 
 make 
 new 
 electronic 
 cash 
 system 
 CryptoNote 
 a 
 serious 
 rival 
 to 
 Bitcoin 
 outclassing 
 all 
 its 
 forks 
 
 
 14 
 
 
 
 Nobel 
 prize 
 laureate 
 Friedrich 
 Hayek 
 in 
 his 
 famous 
 work 
 proves 
 that 
 the 
 existence 
 of 
 concurren
 t 
 independent 
 currencies 
 has 
 a 
 huge 
 positive 
 eect 
 Each 
 currency 
 issuer 
 (or 
 developer 
 in 
 our 
 case) 
 is 
 trying 
 to 
 attract 
 users 
 by 
 improving 
 his 
 product 
 Currency 
 is 
 like 
 a 
 commodity 
 it 
 can 
 have 
 unique 
 benets 
 and 
 shortcomings 
 and 
 the 
 most 
 convenient 
 and 
 trusted 
 currency 
 has 
 the 
 greatest 
 demand 
 Suppose 
 we 
 had 
 a 
 currency 
 excelling 
 Bitcoin 
 it 
 means 
 that 
 Bitcoin 
 would 
 develop 
 faster 
 and 
 become 
 better 
 The 
 biggest 
 support 
 as 
 an 
 open 
 source 
 project 
 would 
 come 
 from 
 its 
 own 
 users 
 who 
 are 
 interested 
 in 
 it 
 
 
 We 
 do 
 not 
 consider 
 CryptoNote 
 as 
 a 
 full 
 replacement 
 to 
 Bitcoin 
 On 
 the 
 contrary 
 having 
 two 
 (or 
 more) 
 strong 
 and 
 convenient 
 currencies 
 is 
 better 
 than 
 having 
 just 
 one 
 Running 
 two 
 and 
 more 
 dierent 
 projects 
 in 
 parallel 
 is 
 the 
 natural 
 
 ow 
 of 
 electronic 
 cash 
 economics 
 (La identidad de la persona que emite el certificado es desconocida) Firmado por Nicolas van Saberhagen <nvsaberhagen@gmail com> Hora 2013 10 17 14 44 50 +02 00 
 
 
 15 
 
 
 
 A 
 Security 
 
 
 We 
 shall 
 give 
 a 
 proof 
 for 
 our 
 one time 
 ring 
 signature 
 scheme 
 At 
 some 
 point 
 it 
 coincides 
 with 
 the 
 parts 
 of 
 the 
 proof 
 in 
 [24] 
 but 
 we 
 decided 
 to 
 rewrite 
 them 
 with 
 a 
 reference 
 rather 
 than 
 to 
 force 
 a 
 reader 
 to 
 rush 
 about 
 from 
 one 
 paper 
 to 
 another 
 
 
 These 
 are 
 the 
 properties 
 to 
 be 
 established 
 
 
 
 Linkability 
 Given 
 all 
 the 
 secret 
 keys 
 fxign 
 for 
 a 
 set 
 S 
 it 
 is 
 impossible 
 to 
 produce 
 n 
 +1
 i=1 
 
 
 valid 
 signatures 
 1 2 n+1 
 such 
 that 
 all 
 of 
 them 
 pass 
 the 
 LNK 
 phase 
 (i e 
 with 
 n 
 + 
 1 
 dierent 
 key 
 images 
 Ii) 
 This 
 property 
 implies 
 the 
 double 
 spending 
 protection 
 in 
 the 
 context 
 of 
 CryptoNote 
 
 
 
 Exculpability 
 Given 
 set 
 S 
 at 
 most 
 n 
 
 1 
 corresponding 
 private 
 keys 
 xi 
 (excluding 
 i 
 = 
 j) 
 and 
 the 
 image 
 Ij 
 of 
 the 
 keys 
 xj 
 it 
 is 
 impossible 
 to 
 produce 
 a 
 valid 
 signature 
 s 
 with 
 Ij 
 This 
 property 
 implies 
 theft 
 protection 
 in 
 the 
 context 
 of 
 CryptoNote 
 
 Unforgeability 
 Given 
 only 
 a 
 public 
 keys 
 set 
 S 
 it 
 is 
 impossible 
 to 
 produce 
 a 
 valid 
 signature 
  
 
 Anonymity 
 Given 
 a 
 signature 
 s 
 and 
 the 
 corresponding 
 set 
 S 
 it 
 is 
 impossible 
 to 
 determine 
 1
 
 the 
 secret 
 index 
 j 
 of 
 the 
 signer 
 with 
 a 
 probability 
 p> 
 
 
 
 n 
 
 
 Linkability 
 
 
 Theorem 
 1 
 Our 
 one time 
 ring 
 signature 
 scheme 
 is 
 linkable 
 under 
 the 
 random 
 oracle 
 model 
 
 
 Proof 
 Suppose 
 an 
 adversary 
 can 
 produce 
 n 
 + 
 1 
 valid 
 signatures 
 i 
 with 
 key 
 images 
 Ii 
 6
 = 
 Ij 
 for 
 any 
 i 
 j 
 
 [1 
 n] 
 Since 
 #S 
 = 
 n 
 at 
 least 
 one 
 Ii 
 6
 = 
 xiHp(Pi) 
 for 
 every 
 i 
 Consider 
 the 
 corresponding 
 signature 
 s 
 =(I c1 cn r1 rn) 
 VER() 
 = 
 \true 
 this 
 means 
 that 
 
 
 
 
 
 L0
 
 
 i 
 = 
 riG 
 + 
 ciPi
 
 
 
 
 R0 
 = 
 riHp(Pi)+ 
 ciI
 
 i 
 
 
 n
 
 P
 
 >
 
 
 ci 
 = 
 Hs(m 
 L0 
 1 L0 
 R1 
 0 
 R0 
 ) 
 mod 
 l
 
 nn 
 
 
 i=1 
 
 
 The 
 rst 
 two 
 equalities 
 imply 
 
 
 ( 
 
 
 logG 
 L0 
 = 
 ri 
 + 
 cixi
 
 i 
 logHp(Pi) 
 R0 
 = 
 ri 
 + 
 ci 
 logHp(Pi) 
 I
 
 i 
 
 
 where 
 logA 
 B 
 informally 
 denotes 
 the 
 discrete 
 logarithm 
 of 
 B 
 to 
 the 
 base 
 A 
 
 
 As 
 in 
 [24] 
 we 
 note 
 that 
 @i 
 
 xi 
 = 
 logHp(Pi) 
 I 
 implies 
 that 
 all 
 ci s 
 are 
 uniquely 
 determined 
 The 
 third 
 equality 
 forces 
 the 
 adversary 
 to 
 nd 
 a 
 pre image 
 of 
 Hs 
 to 
 succeed 
 in 
 the 
 attack 
 an 
 event 
 whose 
 probability 
 is 
 considered 
 to 
 be 
 negligible 
 
 
 Exculpability 
 
 
 Theorem 
 2 
 Our 
 one time 
 ring 
 signature 
 scheme 
 is 
 exculpable 
 under 
 the 
 discrete 
 logarithm 
 assumption 
 in 
 the 
 random 
 oracle 
 model 
 
 
 16 
 
 
 
 Proof 
 Suppose 
 an 
 adversary 
 can 
 produce 
 a 
 valid 
 signature 
 s 
 =(I c1 cn r1 rn) 
 with 
 I 
 = 
 xjHP 
 (Pj) 
 with 
 given 
 fxi 
 | 
 i 
 =1 j 
 1 j 
 +1 ng 
 Then 
 we 
 can 
 construct 
 an 
 algorithm 
 A 
 which 
 solves 
 the 
 discrete 
 logarithm 
 problem 
 in 
 E(Fq) 
 
 
 Suppose 
 inst 
 = 
 (G 
 P 
 ) 
 
 E(Fq) 
 is 
 a 
 given 
 instance 
 of 
 the 
 DLP 
 and 
 the 
 goal 
 is 
 to 
 get 
 s 
 such 
 that 
 P 
 = 
 sG 
 Using 
 the 
 standard 
 technique 
 (as 
 in 
 [24]) 
 A 
 simulates 
 the 
 random 
 and 
 signing 
 oracles 
 and 
 makes 
 the 
 adversary 
 produce 
 two 
 valid 
 signatures 
 with 
 Pj 
 = 
 P 
 in 
 the 
 set 
 S 
 
 
 00 
 0
 
 s 
 =(I c1 cn r1 rn) 
 and 
 0 
 =(I c0 
 1 c 
 r1 r 
 ) 
 
 nn 
 
 
 j
 
 Since 
 I 
 = 
 xj 
 Hp(Pj 
 ) 
 in 
 both 
 signatures 
 we 
 compute 
 xj 
 = 
 logHp(Pj 
 ) 
 I 
 = 
 r 
 0 
 j r 
 0 
 mod 
 l 
 
 
 cj cj 
 00
 
 A 
 outputs 
 xj 
 because 
 Lj 
 = 
 rjG 
 + 
 cjPj 
 = 
 rjG 
 + 
 cjPj 
 and 
 Pj 
 = 
 P 
 
 
 
 Unforgeability 
 
 
 It 
 has 
 been 
 shown 
 in 
 [24] 
 that 
 unforgeability 
 is 
 just 
 an 
 implication 
 of 
 both 
 linkability 
 and 
 exculpability
 
 
 
 Theorem 
 3 
 If 
 a 
 one time 
 ring 
 signature 
 scheme 
 is 
 linkable 
 and 
 exculpable 
 then 
 it 
 is 
 unforgeable 
 
 
 Proof 
 Suppose 
 an 
 adversary 
 can 
 forge 
 a 
 signature 
 for 
 a 
 given 
 set 
 S 
 0 
 =(I0 ) 
 Consider 
 all 
 valid 
 signatures 
 (produced 
 by 
 the 
 honest 
 signers) 
 for 
 the 
 same 
 message 
 m 
 and 
 the 
 set 
 S 
 1 2 n 
 There 
 are 
 two 
 possible 
 cases 
 
 
 1 
 I0 
 2fIign 
 Which 
 contradicts 
 exculpability 
 i=1 
 
 
 2 
 I0 
 6
 
 fIign 
 Which 
 contradicts 
 linkability 
 i=1 
 
 
 Anonymity 
 
 
 Theorem 
 4 
 Our 
 one time 
 ring 
 signature 
 scheme 
 is 
 anonymous 
 under 
 the 
 decisional 
 Die Hellman 
 assumption 
 in 
 the 
 random 
 oracle 
 model 
 
 
 Proof 
 Suppose 
 an 
 adversary 
 can 
 determine 
 the 
 secret 
 index 
 j 
 of 
 the 
 Signer 
 with 
 a 
 probability 
 
 
 1
 
 p 
 =+ 
  
 Then 
 we 
 can 
 construct 
 algorithm 
 A 
 which 
 solves 
 the 
 decisional 
 Die Hellman 
 
 
 n 
 
 
 
 
 problem 
 in 
 E(Fq) 
 with 
 the 
 probability 
 1 
 + 
 
 22 
 
 
 Let 
 inst 
 = 
 (G1 G2 Q1 Q2) 
 
 E(Fq) 
 be 
 the 
 instance 
 of 
 DDH 
 and 
 the 
 goal 
 to 
 determine 
 if 
 logG1 
 Q1 
 = 
 logG2 
 Q2 
 A 
 feeds 
 the 
 adversary 
 with 
 valid 
 signature 
 0 
 =(I 
 ) 
 where 
 Pj 
 = 
 xj 
 G1 
 = 
 Q1 
 and 
 I 
 = 
 Q2 
 and 
 simulates 
 oracle 
 Hp 
 returning 
 G2 
 for 
 query 
 Hp(Pj 
 ) 
 
 
 The 
 adversary 
 returns 
 k 
 as 
 his 
 guess 
 for 
 the 
 index 
 i 
 I 
 = 
 xiHP 
 (Pi) 
 If 
 k 
 = 
 j 
 then 
 A 
 returns 
 1 
 (for 
 \yes ) 
 otherwise 
 a 
 random 
 r 
 2f1 
 0g 
 The 
 probability 
 of 
 the 
 right 
 choice 
 is 
 com
 
 
 11
 
 puted 
 as 
 in 
 [24] 
 +Pr(1 
 | 
 inst 
 
 DDH) Pr 
 (1 
 | 
 inst 
 2/ 
 DDH) 
 = 
 +Pr(k 
 = 
 j 
 | 
 inst 
 
 DDH)+ 
 
 
 22 
 
 
 Pr 
 (k 
 6
 = 
 j 
 | 
 inst 
 
 DDH)Pr 
 (r 
 = 
 1) Pr 
 (k 
 = 
 j 
 | 
 inst 
 2/ 
 DDH) Pr 
 (k 
 =6 
 j 
 | 
 inst 
 2/ 
 DDH)Pr 
 (r 
 = 
 0) 
 = 
 
 
 11 
 1 
 
 1 
 
 n 11 
 1 
 
 
 ++ 
 +( 
 n 1 
 
 ) 
  
 =+
 
 2 
 nn 
 2 
 nn 
 2 
 22 
 
 
 In 
 fact 
 the 
 result 
 should 
 be 
 reduced 
 by 
 the 
 probability 
 of 
 collision 
 in 
 Hs 
 but 
 this 
 value 
 is 
 considered 
 to 
 be 
 negligible 
 
 
 Notes 
 on 
 the 
 hash 
 function 
 Hp 
 
 
 We 
 dened 
 Hp 
 as 
 deterministic 
 hash 
 function 
 E(Fq) 
 
 E(Fq) 
 None 
 of 
 the 
 proofs 
 demands 
 Hp 
 to 
 be 
 an 
 ideal 
 cryptographic 
 hash 
 function 
 It s 
 main 
 purpose 
 is 
 to 
 get 
 a 
 pseudo random 
 base 
 for 
 image 
 key 
 I 
 = 
 xHp(xG) 
 in 
 some 
 determined 
 way 
 
 
 With 
 xed 
 base 
 (I 
 = 
 xG2) 
 the 
 following 
 scenario 
 is 
 possible 
 
 
 17 
 
 
 
 1 
 Alice 
 sends 
 two 
 standard 
 transactions 
 to 
 Bob 
 generating 
 one time 
 tx keys 
 P2 
 = 
 Hs(r1A)G+ 
 B 
 and 
 P1 
 = 
 Hs(r2A)G 
 + 
 B 
 2 
 Bob 
 recovers 
 corresponding 
 one time 
 private 
 tx keys 
 x1 
 and 
 x2 
 and 
 spends 
 the 
 outputs 
 with 
 valid 
 signatures 
 and 
 images 
 keys 
 I1 
 = 
 x1G2 
 and 
 I2 
 = 
 x2G2 
 
 
 3 
 Now 
 Alice 
 can 
 link 
 these 
 signatures 
 checking 
 the 
 equality 
 I1 I2 
 =(Hs(r1A) Hs(r2A))G2 
 The 
 problem 
 is 
 that 
 Alice 
 knows 
 the 
 linear 
 correlation 
 between 
 public 
 keys 
 P1 
 and 
 P2 
 and 
 in 
 case 
 of 
 xed 
 base 
 G2 
 she 
 also 
 gets 
 the 
 same 
 correlation 
 between 
 key 
 images 
 I1 
 and 
 I2 
 Replacing 
 G2 
 with 
 Hp(xG2) 
 which 
 does 
 not 
 preserve 
 linearity 
 xes 
 that 
 
 aw 
 
 
 
 (BEGIN PGP PUBLIC KEY BLOCK mQMtBE8FUXgRCACHMhPE75UUaM/2v1UWPlkPDEItBq5iqUNfsmcGbVCZdogQYFX+ RXN4KtMdxNEk5uHILpfPHl4ExeAW1VJNMc3rv4zNJT4gvXQzgJcJuGLyr06V5PdK nApaOszEENENGdK8TOgVVULY3dSDTItmPIIUrnjD2hPCL/NzbT/XN2++TGGsnlwa RjkOgcoDBomXjrPPdlEp6GQLPoDlohsSVBRZWrt2IXWgPUIVKX7KBuPmH0DPgLg3 baPHu+Ln2sJmOWIlB6Yl0WW6WGIJIy1OIbR3665lTHWIcAGousih0zUwiJ1Xgl3s hSGH/Ivu4jE6UQ1BOuXcZHjnR58GpHE2RXi3AQD4zYriL1xyyxEdMJMj3QZj7m2T iJbXMR4ApmTP0ukCHwf9HKGl38Zo42fK0iErCEGfkKIjm95+WE3CCo8o0SUZ8eC3 gSWijN0aZZuuCLs1ORDsGnFp0imkbhgtCs6JyjvGpoOl89/UgKh2zh+1Tf+rpFXY og+Q7lxydzTbjMrklS1INW7vEfa05SOavD9llXM2rUWj/iRkExEr3Qqo+NHrh6SH UBVreogyw4Fs1kgBPcZvXt5nJu/QxX8G4cumg2EJORzkqYApf1c/s8C4bbYM+tO3 wmssAOMvxGLw0uhWy8F8gqa7z9l/5pszyXjnH8jbFI3CiOSDkNbkQi98DCFRMt3V PZBkIuhFJoY7KjsCfXOXkgwOsPlfUU/MinGmm/H+Ogf1GHUyzZWaxRFeNz3yc4Zd +SKqOYOY0YRaChMOMy0pdWfAwHAgNT+LspFfqVQXRPIlPsZuWClcp5QpnJdigdtN HU2fdk4PZqtbLaRe6R8pA7ls5Kd/tPFJ0MANRXfo0Or9/Pk8tOxl3WaTi+IrOxVZ RRrjQpPSZiKYFn/GOA/3GDJINzWhHoTPmd4L+JldZqmbnnC0OJ0DIPM0snZf6/YC CGAxo63qdChE2czo3fExQZhpFG5OIx1WcA4SWMOMPjc/oNdNHWNmI9Ad4e0hbMXM m/rCJvJ9MYrRE3fJepn5jCzCTF840PHMQvyeM7PD9ltW/Iqnp8fJEdWUxxB5riwK tC9OaWNvbGFzIHZhbiBTYWJlcmhhZ2VuIDxudnNhYmVyaGFnZW5AZ21haWwuY29t Poh6BBMRCAAiBQJPBVF4AhsDBgsJCAcDAgYVCAIJCgsEFgIDAQIeAQIXgAAKCRBE YUazCitjTp6iAQCd2NIG809iSH5f8Xq0LIFECfnXlHAUA5thKoI8l25HQQEA8CSu waVyrhh4sRhvMHVuMyVQx/H8PuqYqfbiMiFmeuG5Ag0ETwVReBAIAJ30u98R3avw F/rf+Y6+MGzjOWGZCaQebpr+/PeFErE8LK76Mv8LPG3U5ePSLjBl613eScRBrwPg yzHPRR+iXl9ozb+b6YGNhSi++y8rTr9AMbCguxVeh8AM/vTQS28JTDLypdn06q7Z zREV/pwaeYiC9eRfVcWtsHtpOHcbXv/lNvXA1qqXg0AkOaslqg4MdAkKHgrjUREi v5DF6lIbz410qtfzbYzzj/gxTMagBjkg6uuq1EaWPYGNQIqRvqmxKinOvrCXJFOw ppyCED4tI4C4XMPFoMjsyKuGWBQpOVaeAUK2okciN2IipYhPR++4a/2SDSSyEJGy +vgaK7FATdMAAwYH/juW4RaDS8YVkQvVaBg+8Ibdjwze4Ytl7L7xJduJFgkaUWXm B/9RN/Qzxv2l/4ursywdCQzIblv6K+A4xquvk2J+/Ye/0AhaDWtdKvZrij6u+Auc V1C/+qgCAkOJjXtaZaGLtK3gju36xlQoXDkR/wnEOZUaB5Wxo2/4VHxp3rqpU02t dluW6TF929gMDhkETFwmUdKEy9RUXoK4Kd9YVBof1DyT9npSg3Ha/DiHIbBBSd8Z tFuGmd7j5Hk7HBNehZhg+/D1cOZLDrNxZR4qi+xTvKLenG1gwzxPn7SDXW83xWrq m7O5e0rh0XDJjDORd555J1/3+GRGsUv+0WSMakWIYQQYEQgACQUCTwVReAIbDAAK CRBEYUazCitjTvBNAQDJetTV/FKd3EJhgy156IeSJMkh5G2rr/yQ/SyzDvA3NgD/ WMMC/jFoXOSkVFfq5RbCvWfZ0dbARCpSdMgtKOLDvz4= =Qw8g END PGP PUBLIC KEY BLOCK) Desactivado
 For 
 constructing 
 deterministic 
 Hp 
 we 
 use 
 algorithm 
 presented 
 in 
 [37] 
 
 
 18 
 
 
 
 References 
 
 
 [1] 
 http //bitcoin org 
 [2] 
 https //en bitcoin it/wiki/Category Mixing 
 Services 
 [3] 
 http //blog ezyang com/2012/07/secure multiparty bitcoin anonymization 
 [4] 
 https //bitcointalk org/index php topic=279249 0 
 [5] 
 http //msrvideo vo msecnd net/rmcvideos/192058/dl/192058 pdf 
 [6] 
 https //github com/bitcoin/bips/blob/master/bip 0034 mediawiki#Specication 
 [7] 
 https //github com/bitcoin/bips/blob/master/bip 0016 mediawiki#Backwards 
 Compatibility 
 
 
 [8] 
 https //en bitcoin it/wiki/Mining 
 hardware 
 comparison 
 [9] 
 https //github com/bitcoin/bips/blob/master/bip 0050 mediawiki 
 [10] 
 http //luke dashjr org/programs/bitcoin/les/charts/branches html 
 [11] 
 https //bitcointalk org/index php topic=196259 0 
 [12] 
 https //en bitcoin it/wiki/Contracts 
 [13] 
 https //en bitcoin it/wiki/Script 
 [14] 
 http //litecoin org 
 [15] 
 Martn 
 Abadi 
 Michael 
 Burrows 
 and 
 Ted 
 Wobber 
 Moderately 
 hard 
 memory bound 
 functions
 
 In 
 NDSS 
 2003 
 [16] 
 Ben 
 Adida 
 Susan 
 Hohenberger 
 and 
 Ronald 
 L 
 Rivest 
 Ad hoc group 
 signatures 
 from 
 hijacke
 d 
 keypairs 
 In 
 in 
 DIMACS 
 Workshop 
 on 
 Theft 
 in 
 E Commerce 
 2005 
 [17] 
 Man 
 Ho 
 Au 
 Sherman 
 S 
 M 
 Chow 
 Willy 
 Susilo 
 and 
 Patrick 
 P 
 Tsang 
 Short 
 linkable 
 ring 
 signatures 
 revisited 
 In 
 EuroPKI 
 pages 
 101{115 
 2006 
 [18] 
 Daniel 
 J 
 Bernstein 
 Niels 
 Duif 
 Tanja 
 Lange 
 Peter 
 Schwabe 
 and 
 Bo Yin 
 Yang 
 High speed 
 high security 
 signatures 
 J 
 Cryptographic 
 Engineering 
 2(2) 77{89 
 2012 
 [19] 
 David 
 Chaum 
 and 
 Eugene 
 van 
 Heyst 
 Group 
 signatures 
 In 
 EUROCRYPT 
 pages 
 257{265 
 1991 
 [20] 
 Fabien 
 Coelho 
 Exponential 
 memory bound 
 functions 
 for 
 proof 
 of 
 work 
 protocols 
 IACR 
 Cryptology 
 ePrint 
 Archive 
 2005 356 
 2005 
 [21] 
 Ronald 
 Cramer 
 Ivan 
 Damgard 
 and 
 Berry 
 Schoenmakers 
 Proofs 
 of 
 partial 
 knowledge 
 and 
 simplied 
 design 
 of 
 witness 
 hiding 
 protocols 
 In 
 CRYPTO 
 pages 
 174{187 
 1994 
 [22] 
 Cynthia 
 Dwork 
 Andrew 
 Goldberg 
 and 
 Moni 
 Naor 
 On 
 memory bound 
 functions 
 for 
 ghting 
 spam 
 In 
 CRYPTO 
 pages 
 426{444 
 2003 
 [23] 
 Eiichiro 
 Fujisaki 
 Sub linear 
 size 
 traceable 
 ring 
 signatures 
 without 
 random 
 oracles 
 In 
 CTRSA
 
 pages 
 393{415 
 2011 
 19 
 
 
 
 [24] 
 Eiichiro 
 Fujisaki 
 and 
 Koutarou 
 Suzuki 
 Traceable 
 ring 
 signature 
 In 
 Public 
 Key 
 Cryptography
 
 pages 
 181{200 
 2007 
 [25] 
 Jezz 
 Garzik 
 Peer 
 review 
 of 
 \quantitative 
 analysis 
 of 
 the 
 full 
 bitcoin 
 transaction 
 graph 
 https //gist github com/3901921 
 2012 
 [26] 
 Joseph 
 K 
 Liu 
 Victor 
 K 
 Wei 
 and 
 Duncan 
 S 
 Wong 
 Linkable 
 spontaneous 
 anonymous 
 group 
 signature 
 for 
 ad 
 hoc 
 groups 
 (extended 
 abstract) 
 In 
 ACISP 
 pages 
 325{335 
 2004 
 [27] 
 Joseph 
 K 
 Liu 
 and 
 Duncan 
 S 
 Wong 
 Linkable 
 ring 
 signatures 
 Security 
 models 
 and 
 new 
 schemes 
 In 
 ICCSA 
 (2) 
 pages 
 614{623 
 2005 
 [28] 
 Ian 
 Miers 
 Christina 
 Garman 
 Matthew 
 Green 
 and 
 Aviel 
 D 
 Rubin 
 Zerocoin 
 Anonymous 
 distributed 
 e cash 
 from 
 bitcoin 
 In 
 IEEE 
 Symposium 
 on 
 Security 
 and 
 Privacy 
 pages 
 397 
 411 
 2013 
 [29] 
 Micha 
 Ober 
 Stefan 
 Katzenbeisser 
 and 
 Kay 
 Hamacher 
 Structure 
 and 
 anonymity 
 of 
 the 
 bitcoin 
 transaction 
 graph 
 Future 
 internet 
 5(2) 237{250 
 2013 
 [30] 
 Tatsuaki 
 Okamoto 
 and 
 Kazuo 
 Ohta 
 Universal 
 electronic 
 cash 
 In 
 CRYPTO 
 pages 
 324{337 
 1991 
 [31] 
 Marc 
 Santamaria 
 Ortega 
 The 
 bitcoin 
 transaction 
 graph 
 
 anonymity 
 Master s 
 thesis 
 Universitat 
 Oberta 
 de 
 Catalunya 
 June 
 2013 
 [32] 
 Colin 
 Percival 
 Stronger 
 key 
 derivation 
 via 
 sequential 
 memory hard 
 functions 
 Presented 
 at 
 BSDCan 09 
 May 
 2009 
 [33] 
 Fergal 
 Reid 
 and 
 Martin 
 Harrigan 
 An 
 analysis 
 of 
 anonymity 
 in 
 the 
 bitcoin 
 system 
 CoRR 
 abs/1107 4524 
 2011 
 [34] 
 Ronald 
 L 
 Rivest 
 Adi 
 Shamir 
 and 
 Yael 
 Tauman 
 How 
 to 
 leak 
 a 
 secret 
 In 
 ASIACRYPT 
 pages 
 552{565 
 2001 
 [35] 
 Dorit 
 Ron 
 and 
 Adi 
 Shamir 
 Quantitative 
 analysis 
 of 
 the 
 full 
 bitcoin 
 transaction 
 graph 
 IACR 
 Cryptology 
 ePrint 
 Archive 
 2012 584 
 2012 
 [36] 
 Meni 
 Rosenfeld 
 Analysis 
 of 
 hashrate based 
 double spending 
 2012 
 [37] 
 Maciej 
 Ulas 
 Rational 
 points 
 on 
 certain 
 hyperelliptic 
 curves 
 over 
 nite 
 elds 
 Bulletin 
 of 
 the 
 Polish 
 Academy 
 of 
 Sciences 
 Mathematics 
 55(2) 97{104 
 2007 
 [38] 
 Qianhong 
 Wu 
 Willy 
 Susilo 
 Yi 
 Mu 
 and 
 Fangguo 
 Zhang 
 Ad 
 hoc 
 group 
 signatures 
 In 
 IWSEC 
 pages 
 120{135 
 2006 
 (I am not Satoshi Nakamoto) Desactivado
 20 
 
 
 
 